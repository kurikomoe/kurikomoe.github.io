{"total":50,"pageSize":8,"pageCount":7,"data":[{"title":"Real World Haskell 学习笔记","subtitle":"进度：FPを勉強していました","author":"Kuriko Moe (栗子Chan)","excerpt":"<p>人人都想学的 FP ！既然没有对象，那不妨试试函数式编程叭！</p>\n<p>内容提示：本篇 Blog 将会持续更新，记录本栗子从 0 到 1 的「Real World Haskell」学习</p>\n","render_content":"<p>人人都想学的 FP ！既然没有对象，那不妨试试函数式编程叭！</p>\n<p>内容提示：本篇 Blog 将会持续更新，记录本栗子从 0 到 1 的「Real World Haskell」学习</p>\n<!-- more -->\n<h1 id=\"day-1%EF%BC%8Cinstallation\" tabindex=\"-1\">Day 1，Installation</h1>\n<h2 id=\"%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E\" tabindex=\"-1\">环境说明</h2>\n<div class=\"warning\">\n<p>本部分可能需要根据 Haskell 的发展进行更新。 ---- by 栗子 2020/08/28</p>\n</div>\n<p>栗子使用的是 2018 款 MBP，i5 处理器，因此学习笔记基于<code>macOS</code>，但也不排除<code>Linux</code>环境下的一些操作。</p>\n<p>面对一个新语言，最重要的是学会如何安装。相较于 Rust 的一行代码解决 rustup + cargo 的美好安装体验，Haskel 的安装要稍微复杂一点。按照<a href=\"https://www.haskell.org/platform/mac.html\" target=\"_blank\" rel=\"noopener\">官网</a>上的说明，分为两个步骤，ghcup 和 stack。</p>\n<div class=\"info\">\n<p>The recommended way to install the components of the mac platform is using <a href=\"https://www.haskell.org/ghcup/\" target=\"_blank\" rel=\"noopener\">ghcup</a> to install ghc and cabal-install, and following the instructions at <a href=\"https://www.haskellstack.org\" target=\"_blank\" rel=\"noopener\">haskellstack.org</a> to install stack.</p>\n<p><strong>ghcup</strong> is an installer for the general purpose language Haskell</p>\n<p><strong>Stack</strong> is a cross-platform program for developing Haskell projects. It is aimed at Haskellers both new and experienced.</p>\n</div>\n<p>实际上，在安装第一步，小小的咱就冒出了一个大大的疑问。<code>ghcup</code> 和 <code>stack</code> 都是什么鬼。。按照 StackOverflow 上的描述，两者应该是 <code>rustup</code> 和 <code>cargo</code> 的关系。<a href=\"https://stackoverflow.com/questions/59030132/how-do-i-install-haskell-stack-on-mac\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<p>然而问题是，<code>ghcup</code> 在安装的时候，顺便送了你一个<code>cabal</code>，这玩意。。似乎也能用于管理项目。。。<a href=\"https://stackoverflow.com/questions/30913145/what-is-the-difference-between-cabal-and-stack\" target=\"_blank\" rel=\"noopener\">What is the difference between Cabal and Stack?</a></p>\n<p>不过无所谓了，现在推荐使用的还是<code>stack</code>。</p>\n<p>具体的安装方式的话，还是请参照对应的官网上的安装方法，防止咱的 Blog 内容过时带来意外的后果。</p>\n<p><code>ghcup</code> 安装传送门：<a href=\"https://www.haskell.org/ghcup/\" target=\"_blank\" rel=\"noopener\">https://www.haskell.org/ghcup/</a></p>\n<p><code>stack</code> 安装传送门：<a href=\"https://docs.haskellstack.org/en/stable/README/\" target=\"_blank\" rel=\"noopener\">https://docs.haskellstack.org/en/stable/README/</a></p>\n<h2 id=\"chapter-1%3A-getting-started\" tabindex=\"-1\">Chapter 1: Getting Started</h2>\n<p>论如何让<code>kuriko</code>成为你的<code>prompt</code>：</p>\n<pre><code class=\"language-haskell\">ghci&gt; :set prompt &quot;kuriko&gt; &quot;\nkuriko&gt; ...\n</code></pre>\n<h3 id=\"simple-arithmetic\" tabindex=\"-1\">Simple Arithmetic</h3>\n<p><code>Haskell</code> 支持中缀表达式的表示方式<code>(+) 2 2</code>。</p>\n<p><code>Haskell</code> 的单目运算符<code>-</code> 在表示负数的时候，需要加上括号<code>2 + (-3)</code>、<code>2*(-3)</code>之类的。。</p>\n<h3 id=\"boolean-logic-and-others\" tabindex=\"-1\">Boolean Logic and others</h3>\n<p>和类C的语言不同，<code>Haskell</code> 里面的 True 和 False 与数值等类型数据不能隐式转换。因此以下的表达式会触发异常：</p>\n<pre><code class=\"language-haskell\">kuriko&gt; True &amp;&amp; 1\n\n&lt;interactive&gt;:47:9: error:\n    • No instance for (Num Bool) arising from the literal ‘1’\n    • In the second argument of ‘(&amp;&amp;)’, namely ‘1’\n      In the expression: True &amp;&amp; 1\n      In an equation for ‘it’: it = True &amp;&amp; 1\n</code></pre>\n<div class=\"warning\">\n<p>和 <code>C/CPP</code> 里面有很大的不同，<code>Haskell</code> 中的“不等于”（is not equal to）使用的运算符为<code>/=</code>（来自于数学的  \\(\\not=\\) 符号）</p>\n<p>另一个不同点在于，<code>Haskel</code> 使用 <code>not</code> 作为逻辑取反，而 <code>C/CPP</code> 通常使用 <code>!</code> 运算符</p>\n<p>另外，<code>^</code> 在<code>Haskell</code>里面代表的是<code>次方</code></p>\n<pre><code class=\"language-haskell\">kuriko&gt; 2^10\n1024\n\nkuriko&gt; :info (^)\n(^) :: (Num a, Integral b) =&gt; a -&gt; b -&gt; a       -- Defined in ‘GHC.Real’\ninfixr 8 ^\n</code></pre>\n</div>\n<h3 id=\"list\" tabindex=\"-1\">List</h3>\n<p><code>List[1, 2, 3]</code> 中的元素必须是相同类型。同时<strong>不同于</strong> Python 等动态语言（甚至不同于 C++11），列表的最后不能是 <code>,</code>。</p>\n<pre><code class=\"language-haskell\">kuriko&gt; [1, 2, 3, &quot;hello&quot;]\n\n&lt;interactive&gt;:51:2: error:\n    • No instance for (Num [Char]) arising from the literal ‘1’\n    • In the expression: 1\n      In the expression: [1, 2, 3, &quot;hello&quot;]\n      In an equation for ‘it’: it = [1, 2, 3, ....]\n      \nkuriko&gt; [1, 2, 3,]\n\n&lt;interactive&gt;:52:10: error: parse error on input ‘]’\n</code></pre>\n<h4 id=\"enumeration-%E7%89%B9%E6%80%A7\" tabindex=\"-1\">Enumeration 特性</h4>\n<p>类似于<code>rust</code>中的 <code>0..233</code> （话说。。怕不是 <code>rust</code> 抄的），<code>Haskell</code> 中支持在<code>List</code>中利用 <code>..</code> 做枚举。</p>\n<pre><code class=\"language-haskell\">kuriko&gt; [1..10]\n[1,2,3,4,5,6,7,8,9,10]\nkuriko&gt; [10..1]\n[]\nkuriko&gt; [10,9..1]\n[10,9,8,7,6,5,4,3,2,1]\nkuriko&gt; ['a'..'z']\n&quot;abcdefghijklmnopqrstuvwxyz&quot;\nkuriko&gt; ['z', 'x'..'a']\n&quot;zxvtrpnljhfdb&quot;\n</code></pre>\n<div class=\"info\">\n<p>List 中前两个元素可以用来指定枚举的步长： <code>[0, 2..233]</code></p>\n</div>\n<h4 id=\"list-%E6%93%8D%E4%BD%9C\" tabindex=\"-1\">List 操作</h4>\n<p><code>(++)</code>操作符用于连接两个 List，<code>(:)</code> 操作符用于将元素合入 List 中</p>\n<div class=\"warning\">\n<p>根据定义：</p>\n<pre><code class=\"language-haskell\">kuriko&gt; :info :\ndata [] a = ... | a : [a]       -- Defined in ‘GHC.Types’\ninfixr 5 :\n</code></pre>\n<p><code>(:)</code> 必须是元素在前，列表在后。如果想在尾端插入元素，可以：</p>\n<pre><code class=\"language-haskell\">kuriko&gt; [1,2] ++ 3 : []\n[1,2,3]\n</code></pre>\n</div>\n<h3 id=\"string-and-characters\" tabindex=\"-1\">String and Characters</h3>\n<p><code>putStrLn</code> 是输出字符串用的。而<code>String</code>本质上是 List of Characters。</p>\n<pre><code class=\"language-haskell\">kuriko&gt; &quot;abcde&quot;\n&quot;abcde&quot;\nkuriko&gt; ['a', 'b', 'c', 'd', 'e']\n&quot;abcde&quot;\n</code></pre>\n<p>因此有如下很有趣的操作：</p>\n<pre><code class=\"language-haskell\">kuriko&gt; &quot;&quot; == []\nTrue\nkuriko&gt; 'a' : &quot;bc&quot;\n&quot;abc&quot;\nkuriko&gt; &quot;ab&quot; ++ &quot;cd&quot;\n&quot;abcd&quot;\n</code></pre>\n<div class=\"extra\">\n<p><spoiler>啊，伟大的 Javascript == 真值图呀。</spoiler></p>\n<p><img src=\"https://kurikomoe-1300672427.image.myqcloud.com/images/haskell/relational_in_js.png\" alt=\"relational_in_js\" /></p>\n</div>\n<h2 id=\"hello%2C-haskell-world!\" tabindex=\"-1\">Hello, Haskell World!</h2>\n<pre><code class=\"language-haskell\">--- file: helloworld.hs\n--- author: kuriko\n--- date: 2020/08/28\n\nmain = interact wordCount\n  where wordCount input = show (length (lines input)) ++ &quot;\\n&quot;\n</code></pre>\n<pre><code class=\"language-bash\">$ runghc helloworld.hk &lt; test.txt\n</code></pre>\n<h1 id=\"day-2%3A-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C...%E6%91%B8%E9%B1%BC\" tabindex=\"-1\">Day 2: 基本概念和...摸鱼</h1>\n<h2 id=\"chapter-2%3A-types-and-functions\" tabindex=\"-1\">Chapter 2: Types and Functions</h2>\n<p>在 Haskell 中，类型是：强类型(Strong)，静态(Static)和可以自动推断(Inferred)的。</p>\n<ul>\n<li>强类型 (Strong) 意味着 Haskell 的类型系统会拒绝类似于将 String 赋值给 Int 这种无意义的操作。换句话说，Haskell 编译器只接受 <em>well typed</em>，对于 <em>ill typed</em> 会触发 <em>type error</em>。\n强类型的第二个特性是 Haskell 的编译器不会自动对变量进行强转 (casting or conversion)。例如 C 会对 int -&gt; float 进行隐式转换，但是 Haskell 要求必须显式声明。\n因此，C 中常见的黑魔法操作：将一块 bytes buffer 强制认为是某种复杂的数据结构从而避免数据的拷贝操作。这种做法在 Haskell 中则需要进行部分拷贝。</li>\n<li>静态类型  (Static Types) 意味着编译器在编译时、程序运行前能够知道所有值的类型和表达式。</li>\n<li>类型推断 (Type Inference) 意味着许多地方的类型声明可以由编译器自行推断出来。</li>\n</ul>\n<h3 id=\"%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B\" tabindex=\"-1\">基础类型</h3>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>类型</th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Char</td>\n<td>Unicode 字符</td>\n<td></td>\n</tr>\n<tr>\n<td>Bool</td>\n<td>True &amp; False</td>\n<td></td>\n</tr>\n<tr>\n<td>Int</td>\n<td>有符号，固定宽度的整型值，取决于系统最长的 <code>Native</code> 整型，例如 32 位机为 32 位整型。Haskell 保证整型值的位宽不小于 28bits</td>\n<td></td>\n</tr>\n<tr>\n<td>Integer</td>\n<td>有符号无限位宽</td>\n<td></td>\n</tr>\n<tr>\n<td>Double</td>\n<td>浮点数，通常是 64bits，使用系统的 <code>Native</code> 表示</td>\n<td>Float  也存在，但是不鼓励使用，Haskell 更多的在优化 Double 的性能。</td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"info\">\n<p>注意，类型是大写字母开头。</p>\n</div>\n<p>可以使用 <code>expression :: MyTepe</code> 表示该表达式是 <code>MyType</code> 类型的。其中 <code>:: MyType</code> 可以略去，由 Haskell 编译器自行推导。</p>\n<pre><code class=\"language-haskell\">GHCi, version 8.8.4: https://www.haskell.org/ghc/  :? for help\nPrelude&gt; :set prompt &quot;Kuriko&gt; &quot;\nKuriko&gt; :type 'a'\n'a' :: Char\nKuriko&gt; 'a' :: Char\n'a'\nKuriko&gt; [1, 2, 3] :: Int\n\n&lt;interactive&gt;:4:1: error:\n    • Couldn't match expected type ‘Int’ with actual type ‘[Integer]’\n    • In the expression: [1, 2, 3] :: Int\n      In an equation for ‘it’: it = [1, 2, 3] :: Int\nKuriko&gt; [1, 2, 3] :: List[Int]\n\n&lt;interactive&gt;:5:14: error:\n    Not in scope: type constructor or class ‘List’\nKuriko&gt; [1, 2, 3] :: [Int]\n[1,2,3]\nKuriko&gt; [1, 2, 3] :: [Double]\n[1.0,2.0,3.0]\n</code></pre>\n<h3 id=\"function-application\" tabindex=\"-1\">Function Application</h3>\n<p>在 Haskell 中调用函数，需要写出函数名，并依次列出其参数。</p>\n<pre><code class=\"language-haskell\">Kuriko&gt; odd 3\nTrue\nKuriko&gt; even 6\nTrue\nKuriko&gt; compare 2 3\nLT\n</code></pre>\n<p>利用<code>括号</code>可以表明结合关系：</p>\n<pre><code class=\"language-haskell\">Kuriko&gt; compare 2.0 sqrt 3\n\n&lt;interactive&gt;:20:1: error:\n    • Couldn't match expected type ‘Integer -&gt; t’\n                  with actual type ‘Ordering’\n    • The function ‘compare’ is applied to three arguments,\n      but its type ‘(Double -&gt; Double) -&gt; (Double -&gt; Double) -&gt; Ordering’\n      has only two\n      In the expression: compare 2.0 sqrt 3\n      In an equation for ‘it’: it = compare 2.0 sqrt 3\n    • Relevant bindings include it :: t (bound at &lt;interactive&gt;:20:1)\nKuriko&gt; compare 2 (sqrt 3)\nGT\n</code></pre>\n<div class=\"warning\">\n<p>如果没有括号， <code>compare 2 sqrt 3</code> 意思是将三个参数<code>2</code>，<code>sqrt</code>，<code>3</code> 传给函数 <code>compare</code>。显然这是不对的。</p>\n</div>\n<h3 id=\"%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9Alists-and-tuples\" tabindex=\"-1\">复合数据类型：Lists and Tuples</h3>\n<h4 id=\"lists\" tabindex=\"-1\">Lists</h4>\n<p>在 Haskell 中最常见的复合 (Composite) 数据类型是 Lists and Tuples。</p>\n<p>由于 List 中可以承载各种数据类型（但是一旦确定，List 中元素的数据类型必须全部相同），因此 List Type 是 （不定形）<code>polymorphic</code> 的。当我们写出一个 polymorphic type 的时候，可以用 <code>type variable</code> 来表示，规定用小写字母表示。</p>\n<div class=\"explain\">\n<p>Type Name 必须用以大写字母开头：Int</p>\n<p>Type Variable 必须用小写字母开头</p>\n<p>[[Int]] is a list of lists int</p>\n</div>\n<h4 id=\"tuples\" tabindex=\"-1\">Tuples</h4>\n<p>元组是固定大小的数据的集合，允许将不同的数据类型组合在一起。</p>\n<p>其中 <code>()</code> 为特殊的类型，代表零元素的元组。通常被叫做 &quot;unit&quot;，在 C 中可以等价于 <code>void</code></p>\n<pre><code class=\"language-haskell\">Kuriko&gt; :type (1, &quot;2&quot;, (1, True))\n(1, &quot;2&quot;, (1, True)) :: (Num a1, Num a2) =&gt; (a1, [Char], (a2, Bool))\n\nKuriko&gt; :type ()\n() :: ()\n</code></pre>\n<div class=\"info\">\n<p>Haskell 中不存在单元素元组，2-tuple 称之为 <code>pair</code>，3-tuple 称之为 (triple)。</p>\n</div>\n<h3 id=\"functions-over-lists-and-tuples\" tabindex=\"-1\">Functions over Lists and Tuples</h3>\n<div class=\"warning\">\n<p>注意 <code>fst</code> 和 <code>snd</code> 只能作用于 <code>pair</code> 上</p>\n</div>\n<pre><code class=\"language-haskell\">Kuriko&gt; head [1, 2, 3, 4]\n1\nKuriko&gt; tail [1, 2, 3, 4]\n[2,3,4]\nKuriko&gt; fst [1, 2, 3, 4]\n\n&lt;interactive&gt;:34:5: error:\n    • Couldn't match expected type ‘(a, b0)’\n                  with actual type ‘[Integer]’\n    • In the first argument of ‘fst’, namely ‘[1, 2, 3, 4]’\n      In the expression: fst [1, 2, 3, 4]\n      In an equation for ‘it’: it = fst [1, 2, 3, ....]\n    • Relevant bindings include it :: a (bound at &lt;interactive&gt;:34:1)\nKuriko&gt; fst (1, 2, 3)\n\n&lt;interactive&gt;:35:5: error:\n    • Couldn't match expected type ‘(a, b0)’\n                  with actual type ‘(Integer, Integer, Integer)’\n    • In the first argument of ‘fst’, namely ‘(1, 2, 3)’\n      In the expression: fst (1, 2, 3)\n      In an equation for ‘it’: it = fst (1, 2, 3)\n    • Relevant bindings include it :: a (bound at &lt;interactive&gt;:35:1)\nKuriko&gt; fst (1, 2)\n1\nKuriko&gt; snd (1, 2)\n2\n</code></pre>\n<h3 id=\"passing-an-expression-to-a-function\" tabindex=\"-1\">Passing an Expression to a Function</h3>\n<p>在 Haskell 中，函数调用是左结合的，因此 <code>a b c d</code> 等价于 <code>(((a b) c ) d)</code> 所以在改变结合顺序的时候，需要显式的加上括号：</p>\n<pre><code class=\"language-haskell\">Kuriko&gt; drop 3 [1, 2, 3, 4]\n[4]\nKuriko&gt; head (drop 2 [1, 2, 3, 4])\n3\n</code></pre>\n<h3 id=\"function-types-and-purity\" tabindex=\"-1\">Function Types and Purity</h3>\n<div class=\"info\">\n<p>Purity，函数式编程里面的概念，纯函数。</p>\n</div>\n<p>首先看一下函数的类型：</p>\n<pre><code class=\"language-haskell\">Kuriko&gt; :type lines\nlines :: String -&gt; [String]\n\nKuriko&gt; lines &quot;abc\\n111\\n$$$&quot;\n[&quot;abc&quot;,&quot;111&quot;,&quot;$$$&quot;]\n</code></pre>\n<p>可以看出 <code>lines</code> 是一个接收 <code>String</code> 吐出 <code>[String]</code> 的函数。</p>\n<h4 id=\"%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0%EF%BC%9A\" tabindex=\"-1\">什么是纯函数：</h4>\n<p>在解释纯函数之前，请允许栗子先引入一个概念：<code>side effect</code>：</p>\n<div class=\"define\">\n<h5 id=\"side-effect-%E5%89%AF%E4%BD%9C%E7%94%A8\" tabindex=\"-1\">Side Effect 副作用</h5>\n<p>副作用意味着函数的行为和系统的全局状态相挂钩。例如，如果一个函数在执行中依赖于某个全局变量，那么如果某些代码改变了全局状态，则这个函数即使给定了相同的输入参数，也可能会输出不同的结果。因此我们称这个函数是有 <code>side effect</code> 的（即使这个函数自身没有修改过全局变量）</p>\n</div>\n<p>因此基于<code>side effect</code>我们有：</p>\n<div class=\"define\">\n<h4 id=\"%E7%BA%AF%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%9E%E7%BA%AF%E5%87%BD%E6%95%B0-(pure-and-impure)\" tabindex=\"-1\">纯函数与非纯函数 (pure and impure)</h4>\n<p>如果一个函数没有任何的 <code>side effects</code> ，函数的结果完全取决与其参数输入，则该函数是 <code>pure</code>，否则是 <code>impure</code>。</p>\n</div>\n<p>区分 <code>pure</code> and <code>impure</code> 的好处是，Haskell 的类型系统会自动防止我们混用 <code>pure</code> 和 <code>impure</code> 代码。</p>\n<div class=\"extra\">\n<p>函数式编程的哲学思想是：假定副作用是造成不当行为的主要原因，因此如果我们可以控制 impure function 的使用，就能防止 bug 的发生。</p>\n<p>我们确实生活在一个需要 impure 的世界，但是我们可以尽量小心地去和 impure 的东西交互。</p>\n<spoiler>\n<p>栗子姬の吐槽：隔壁的 rust 可能欲言又止 23333。</p>\n<div class=\"quote\">\n<p>世界是 unsafe 的，我们并不是要禁止 unsafe，但是需要小心的区分出 safe 和 unsafe 的边界。</p>\n</div>\n</div>\n</spoiler>\n<p>判断一个函数是不是 <code>pure</code> 的，可以根据函数签名来判断：</p>\n<pre><code class=\"language-haskell\">Kuriko&gt; :type readFile\nreadFile :: FilePath -&gt; IO String\n</code></pre>\n<p><code>IO</code> 代表函数存在 side effect。</p>\n<h3 id=\"%E6%BA%90%E6%96%87%E4%BB%B6%E5%92%8C%E7%AE%80%E5%8D%95%E5%87%BD%E6%95%B0\" tabindex=\"-1\">源文件和简单函数</h3>\n<p>下面我们进入「如何撰写一个简单的函数」的部分。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-08-31\n\nadd a b = a + b\n\n-------------\nGHCi, version 8.8.4: https://www.haskell.org/ghc/  :? for help\nPrelude&gt; :set prompt kuriko &gt;\nkuriko &gt;:load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\nkuriko &gt;add 1 2\n3\n</code></pre>\n<h3 id=\"%E5%8F%98%E9%87%8F-variable\" tabindex=\"-1\">变量 Variable</h3>\n<p>在 Haskell 中，变量实际上是绑定了一个表达式，和传统的编程语言不同，变量并不代表任何一个「存储空间位置」，因此实际上我们并不能改变变量的值，再次定义变量会导致重复声明的错误。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-08-31\n\nx = 10\nx = 11\n\n-------------\nkuriko &gt;:load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\n\nmain.hs:6:1: error:\n    Multiple declarations of ‘x’\n    Declared at: main.hs:5:1\n                 main.hs:6:1\n  |\n6 | x = 11\n  | ^\nFailed, no modules loaded.\n\n</code></pre>\n<h3 id=\"condition-evaluation\" tabindex=\"-1\">Condition Evaluation</h3>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-08-31\n\nmyDrop n xs = if n &lt;= 0 || null xs\n              then xs\n              else myDrop(n-1) (tail xs)\n--------------\nkuriko &gt;:load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\nkuriko &gt;myDrop 2 &quot;123456&quot;\n&quot;3456&quot;\nkuriko &gt;:type null\nnull :: Foldable t =&gt; t a -&gt; Bool\nkuriko &gt;null &quot;t&quot;\nFalse\nkuriko &gt;null &quot;&quot;\nTrue\nkuriko &gt;\n</code></pre>\n<div class=\"info\">\n<ol>\n<li>\n<p><code>xs</code> 代表的 <code>plure of x</code></p>\n</li>\n<li>\n<p>因为 Haskell 是面向表达式的语言 (expression-oriented) 所以 if 这个 expression 如果只有 then 而没有 else 是没有意义的。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-08-31\n\nmyDrop n xs = if n &lt;= 0 || null xs\n              then xs\n\n--------------\nkuriko &gt;:load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\n\nmain.hs:7:1: error:\n    parse error (possibly incorrect indentation or mismatched brackets)\nFailed, no modules loaded.\n</code></pre>\n</li>\n</ol>\n</div>\n<h3 id=\"lazy-evaluation-and-short-circuiting\" tabindex=\"-1\">Lazy Evaluation and Short-circuiting</h3>\n<p>由于 Haskell 语言 Lazy Evaluation 的特点，Haskell 天生具有 Short-circuiting 的特性。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-08-31\n\nnewOr a b = if a\n            then a\n            else b\n---------\nkuriko &gt;newOr True (length [1..] &gt; 0)\nTrue\n</code></pre>\n<p>正常来讲 <code>length [1..] &gt; 0</code> 会因为尝试计算无限长的列表 <code>[1..]</code>而死循环，但是因为 <code>a</code> 永远为 <code>True</code> 导致 表达式 <code>b</code> 不会被计算。因此程序不会死机。</p>\n<h3 id=\"polymorphism-in-haskell\" tabindex=\"-1\">Polymorphism in Haskell</h3>\n<p>当函数的签名存在 Type Variable 的时候，说明她的某些参数可以是任意类型的。这种函数称之为泛函(?)</p>\n<p>举例来说 <code>:type last</code> 的签名是 <code>last :: [a] -&gt; a</code> 这种被称之为 <code>parametric polymorphism</code></p>\n<p>当我们看到一个泛型形参的时候，我们可以肯定「函数无法判断该参数的真正类型」或者「无法操纵该变量的类型」。因此对于函数来讲，这个变量是一个「黑盒」状态。</p>\n<div class=\"info\">\n<p>和其他语言不同，Haskell 不存在：</p>\n<ul>\n<li>子类泛型</li>\n<li>隐式转换泛型，ie 编译器自动进行的 int 和 float 等数值之间的转换。</li>\n</ul>\n</div>\n<p>举一个栗子：</p>\n<pre><code class=\"language-haskell\">kuriko &gt;:type fst\nfst :: (a, b) -&gt; a\n</code></pre>\n<p>对于函数 <code>fst</code> 来讲，其接受一个 pair，同时 pair 的元素的类型可以不同（也可以相同），因为 fst 并不知道 a 和 b 的具体情况，因此她能做的只有返回 a 类型的元素这一件事情。即返回元组的第一个元素。</p>\n<h3 id=\"%E5%A4%9A%E5%BD%A2%E5%8F%82%E5%87%BD%E6%95%B0%E7%9A%84%E7%AD%BE%E5%90%8D\" tabindex=\"-1\">多形参函数的签名</h3>\n<p>对于多形参的函数，举个栗子：</p>\n<pre><code class=\"language-haskell\">kuriko &gt;:type newOr\nnewOr :: Bool -&gt; Bool -&gt; Bool\n</code></pre>\n<p><code>-&gt;</code> 是右结合的，因此上面的等价于 <code>Bool -&gt; (Bool -&gt; Bool)</code>。可以理解为，吃进去一个 Bool，吐出一个「吃进去一个 Bool 吐出一个 Bool」的函数 <spoiler>（套。。。。套娃！）</spoiler></p>\n<div class=\"alert\">\n<p>这种套娃逻辑会对以后的函数编程思想有极大的影响，之后的「Partial Function Application and Currying（偏函数和柯里化）」会讲到。</p>\n</div>\n<h1 id=\"day-3%2C-step-into-the-hell\" tabindex=\"-1\">Day 3, Step into the HELL</h1>\n<div class=\"info\">\n<p>今天开始学习的时候有点困。。打算看看<code>Haskell</code>转换一下心情。</p>\n</div>\n<h2 id=\"chapter-3%3A-defining-types%2C-streamlining-functions\" tabindex=\"-1\">Chapter 3: Defining Types, Streamlining Functions</h2>\n<h3 id=\"%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\" tabindex=\"-1\">定义新的数据类型</h3>\n<p>以一个书店的数据为例：</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\ndata BookInfo = Book Int String [String]\n                deriving (Show)\n</code></pre>\n<p><code> data BookInfo</code> 定义新类型的名字为 <code>BookInfo</code> （由于是定义了一个新的 Type，所以必须首字母大写），称之为 <code>Type Constructor</code>。</p>\n<pre><code class=\"language-haskell\">kuriko&gt; :load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\n\nmain.hs:5:6: error:\n    Malformed head of type or class declaration: bookInfo\n  |\n5 | data bookInfo = Book Int String [String]\n  |      ^^^^^^^^\nFailed, no modules loaded.\n</code></pre>\n<p><code>Book</code> 是 <code>value constructor</code>（有时候也叫做 data constructor）。和 <code>Type</code> 类型一样，也需要首字母大写。</p>\n<p><code>Book</code> 之后的 <code>Int, String, [String]</code> 是 <code>components of the type</code> 在 Haskell 中和其他语言中的结构体或类一样，用作数据的存放位置 (slot)。</p>\n<p>本例子中，<code>Int</code> 用来表示书的标识，<code>String</code> 标识书名，<code>[String]</code> 标识作者的名字。</p>\n<p>注意，即使我们定义了一个仅名字不同的数据类型：<code>data MagazineInfo  = Magazine Int String [String]</code> 两者也属于不同的数据类型。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-01\n\ndata BookInfo = Book Int String [String]\n                deriving (Show)\n\nmyInfo = Book 114514 &quot;Screaming&quot; [&quot;Senpai&quot;, &quot;Kuriko&quot;]\n---------------\nKuriko&gt; :load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\nKuriko&gt; :type myInfo\nmyInfo :: BookInfo\nKuriko&gt; myInfo\nBook 114514 &quot;Screaming&quot; [&quot;Senpai&quot;,&quot;Kuriko&quot;]\n</code></pre>\n<h3 id=\"naming-types-and-values\" tabindex=\"-1\">Naming Types and Values</h3>\n<p>Type Contructor 和 Value Constructor 可以是相同的名字，因为 Type Constructor 只会在定义 type 和 type 签名的时候使用。Value Constructor only in actual code。由于使用的环境不同，两者不会产生歧义。</p>\n<h3 id=\"type-synonyms%EF%BC%88%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%EF%BC%89\" tabindex=\"-1\">Type Synonyms（类型别名）</h3>\n<pre><code class=\"language-haskell\">type CustomerID = Int\ntype ReviewBody = String\n\ndata BetterReview = BetterReview BookInfo CustomerID ReviewBody\n\ntype BookRecord = (BookInfo, BookReview)\n</code></pre>\n<div class=\"alert\">\n<p>使用 <code>type</code> 定义的数据类型仅仅是别名。。两者其实是相同的数据类型。<code>type synonyms</code> 的作用仅仅是提高代码的可读性。</p>\n</div>\n<h3 id=\"algebraic-data-types-%EF%BC%88%E4%BB%A3%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%89\" tabindex=\"-1\">Algebraic Data Types （代数数据类型）</h3>\n<pre><code class=\"language-haskell\">data Bool = False | True\n</code></pre>\n<p><code>Bool</code> 是最简单和常用的 <code>algebraic data type</code>，<s>ADT</s> <code>Algebraic Data Type</code> 可以有多个<code>value constructor</code>。每个 <code>value constructor</code> 用 <code>|</code> 分割。</p>\n<p>:::error</p>\n<p>Algebraic Data Type 不能简称为 ADT，因为 ADT 通常指 Abstract Data Type。</p>\n<p>:::</p>\n<pre><code class=\"language-haskell\">data BillingInfo = CreditCard CardNumber CardHolder Address\n                 | CashOnDelivery\n                 | Invoice CustomID\n                 deriving (Show)\n</code></pre>\n<div class=\"info\">\n<p>实际上我们可以认为所有的 <code>data</code> 定义的数据类型都是 <code>algebraic data type</code>，一些是单分支，一些是多分支的而已。</p>\n</div>\n<h3 id=\"pattern-matching\" tabindex=\"-1\">Pattern Matching</h3>\n<p>在讲完如何生成 <code>algebraic data type</code> 之后，现在开始讨论如何使用这些数据。有两个要点：</p>\n<ul>\n<li>如果类型有多个 <code>value constructor</code>，我们需要知道数据是由哪个 <code>value constructor</code> 生成的。</li>\n<li>如果数据有多个 <code>data components</code> 我们需要获取各个数据的方法。</li>\n</ul>\n<p>以 <code>Not</code> 函数为例：</p>\n<pre><code class=\"language-haskell\">myNot True = False\nmyNot False = True\n</code></pre>\n<div class=\"explain\">\n<p>这里看起来可能有些奇怪，似乎我们定义了两个 myNot 函数。实际上这是因为 Haskell 允许我们定义函数为「一系列等式」：这两个语句在定义相同函数在不同输入状态下的行为。</p>\n</div>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-01\n\nmyNot True = False\nmyNot False = True\nmyNot a = True\n----------\nKuriko&gt; :load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\n\nmain.hs:7:1: warning: [-Woverlapping-patterns]\n    Pattern match is redundant\n    In an equation for ‘myNot’: myNot a = ...\n  |\n7 | myNot a = True\n  | ^^^^^^^^^^^^^^\nOk, one module loaded.\nKuriko&gt; myNot a\n\n&lt;interactive&gt;:20:7: error: Variable not in scope: a :: Bool\nKuriko&gt; myNot 123\n\n&lt;interactive&gt;:21:7: error:\n    • No instance for (Num Bool) arising from the literal ‘123’\n    • In the first argument of ‘myNot’, namely ‘123’\n      In the expression: myNot 123\n      In an equation for ‘it’: it = myNot 123\nKuriko&gt; myNot True\nFalse  \n</code></pre>\n<p>下面分析一个更加复杂的栗子：</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-01\n\nsumList (x:xs) = x + sumList xs\nsumList [] = 0\n----------------\nKuriko&gt; :load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\nKuriko&gt; sumList [1, 2, 3, 4, 5]\n15\nKuriko&gt; :type sumList\nsumList :: Num p =&gt; [p] -&gt; p\n</code></pre>\n<div class=\"explain\">\n<p><code>[1, 2]</code> 是 <code>(1:(2:[]))</code> 的简写</p>\n<p><code>(x:xs)</code> 中 <code>:</code> 是 <code>familiar list constructor</code> ，换句话说，模式匹配的结果为：</p>\n<ul>\n<li>\n<p>x = 1, xs = (2:[])</p>\n</li>\n<li>\n<p>所以，其实写成如下也是可以的：</p>\n<pre><code class=\"language-haskell\">sumList (a:b) = a + sumList b\nsumList [] = 0\n</code></pre>\n</li>\n</ul>\n</div>\n<div class=\"alert\">\n<p>注意，定义是顺序有关的，Haskell 严格按照从上到下的顺序解析定义，找到第一个匹配就会停止匹配。</p>\n</div>\n<h4 id=\"construction-and-deconstruction\" tabindex=\"-1\">Construction and Deconstruction</h4>\n<p>Pattern Matching 可以认为是 <code>Construction</code> 的反过程，可以被认为是 <code>deconstruction</code>。但是注意的是，和 OOP 语言不同，<code>deconstruction</code> 并不对应 <code>destroyer</code> （析构器）的意思，只是单纯的将元素解包找出内部的元素。</p>\n<h4 id=\"further-adventures\" tabindex=\"-1\">Further Adventures</h4>\n<p>一个很复杂的栗子：</p>\n<pre><code class=\"language-haskell\">complicated (True, a, x:xs, 5) = (a, xs)\n-----------\nKuriko&gt; :load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\nKuriko&gt; complicate True, 233, [1, 2, 3, 4], 5\n\n&lt;interactive&gt;:32:16: error: parse error on input ‘,’\nKuriko&gt; complicate (True, 233, [1, 2, 3, 4], 5)\n(233,[2,3,4])\n</code></pre>\n<div class=\"alert\">\n<p>第一次 <code>complicate True, 233, [1, 2, 3, 4], 5</code> 不能成功匹配是因为 <code>[1, 2, 3, 4]</code> 实际上是 <code>(1:(2:(3:(4:(5:[]))))</code> 的简写，很明显这个并不能直接对应到 <code>x:xs</code> 上。</p>\n</div>\n<h4 id=\"%E9%80%9A%E9%85%8D%E7%AC%A6%E6%A8%A1%E5%BC%8F\" tabindex=\"-1\">通配符模式</h4>\n<p>如果我们不关心某些模式，可以用 <code>_</code> 来替代。这个符号叫做通配符。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-01\n\ntype Id = Int\ntype Book = String\ntype Title = String\ntype Author = [String]\n\ngetID (id, book, title, author) = id\nsimpGetId (id, _, _, _) = id\n\n-------------\nKuriko&gt; :load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\nKuriko&gt; getID(1, &quot;hi&quot;, &quot;Hello&quot;, [&quot;a&quot;, &quot;b&quot;])\n1\n</code></pre>\n<h4 id=\"exhaustive-patterns-and-wild-cards\" tabindex=\"-1\">Exhaustive Patterns and Wild Cards</h4>\n<p>小 Trick，我们可以利用 <code>_</code> 来匹配最终表达式。</p>\n<pre><code class=\"language-haskell\">goodExample (x:xs) = x + goodExample xs\ngoodExample _ = 0\n</code></pre>\n<h3 id=\"record-syntax\" tabindex=\"-1\">Record Syntax</h3>\n<p>给每一个 <code>Data Type</code> 写访问器。是一个繁琐但是必须的事情，但是 Haskell 提供了一个语法糖来处理部分代码。</p>\n<pre><code class=\"language-haskell\">data Customer = Customer {\n  customerID :: CustomID,\n  customerName :: String,\n  customerAddress :: Address,\n} deriving (Show)\n\n------ 上下两种表达等价，显示表达访问器\n\ndata Customer = Customer Int String [String]\n                deriving (Show)\ncustomerID :: Customer -&gt; Int\ncustomerID (Customer id _ _) = id\n\ncustomerName :: Customer -&gt; String\ncustomerName (Customer _ name _) = name\n\ncustomerAddress :: customerAddress -&gt; [String]\ncustomerAddress (Customer _ _ address) = address\n\n----- 使用栗子\n\ncustomer1 = Customer 114514 &quot;Kuriko Moe&quot; [&quot;N/A&quot;, &quot;Mars&quot;]\n\ncustomer2 = Customer {\n    customerID = 114514,\n    customerAddress = [&quot;N/A&quot;, &quot;Mars&quot;],\n    customerName = &quot;Kuriko Moe&quot;\n}\n</code></pre>\n<h3 id=\"parameterized-types-(%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B)\" tabindex=\"-1\">Parameterized Types (参数化类型)</h3>\n<p><code>Prelude</code> 中定义了一个名叫 <code>Maybe</code> 的类型，用来表示存在或不存在。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-01\n\ndata MyMaybe a = MyJust a\n               | MyNothing\n               deriving (Show)\n\nsomeBool = MyJust True\nsomeString = MyNothing\n-----------\nPrelude&gt; :load main\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\n*Main&gt; :type MyMaybe\n\n&lt;interactive&gt;:1:1: error: Data constructor not in scope: MyMaybe\n*Main&gt; :type MyJust\nMyJust :: a -&gt; MyMaybe a\n*Main&gt; :type MyNothing\nMyNothing :: MyMaybe a\n*Main&gt; :type someBool\nsomeBool :: MyMaybe Bool\n*Main&gt; myJust True\nTrue\n*Main&gt; someBool\nMyJust True\n*Main&gt; Just (Just (Just 114514))\nJust (Just (Just 114514))\n</code></pre>\n<div class=\"explain\">\n<p><code>data Maybe a</code> 定义了一个类型 <code>Maybe</code>，其依赖于类型变量<code>a</code> 。</p>\n<p><spoiler><s>TODO（被学长拉去开车送他回寝室了 QAQ）</s>。回来了，继续 （来自 Day 4 的栗子）。。。</spoiler></p>\n<p>回忆一下我们之前的 Type Constructor 和 Value Constructor 的概念。在上面的程序里面：</p>\n<p>MyMaybe 是一个 Type Constructor。MyJust 是一个 Value Constructor（按照 ghci 的说法是 Data Constructor）。</p>\n<p>所以 MyMaybe 这个 Type 可以由两种 Value Constructor 生成，一个是名叫 MyJust 的，接受一个 a type，另一个是 MyNothing，不依赖于任何数据类型。</p>\n<blockquote>\n<p>栗子：所以说可以理解为。。一个可以利用类型生成类型的玩意？</p>\n</blockquote>\n</div>\n<blockquote>\n<p>参考：<a href=\"https://stackoverflow.com/questions/18808258/what-does-the-just-syntax-mean-in-haskell\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/18808258/what-does-the-just-syntax-mean-in-haskell</a></p>\n</blockquote>\n<h1 id=\"day-4%3A-%E7%A7%91%E7%A0%94%E8%BF%9B%E5%B1%95%E8%89%B0%E9%9A%BE%E3%81%AE%E6%A0%97%E5%AD%90%E3%81%AFhaskell%E5%8B%89%E5%BC%B7%E3%81%8C%E6%AC%B2%E3%81%97%E3%81%84%E3%81%A7%E3%81%99\" tabindex=\"-1\">Day 4: 科研进展艰难の栗子はHaskell勉強が欲しいです</h1>\n<h2 id=\"still-stuck-at-chapter-3.....-sigh\" tabindex=\"-1\">Still Stuck at Chapter 3..... sigh</h2>\n<h3 id=\"recursive-types\" tabindex=\"-1\">Recursive Types</h3>\n<p>最常见的 <code>List Type</code> 就是 <code>recursive</code> 的：即自身定义了自身。为了更好的理解，下面有一个新的栗子</p>\n<p>（栗子：新的栗子？哪里哪里？咱要成为姐姐了么？）</p>\n<pre><code class=\"language-haskell\">-- 列表的定义\ndata List a = Cons a (List a)\n            | Nil\n            deriving (Show)\n--------------\n*Main&gt; Con 1 (Con 2 (Con 3 Nil))\nCon 1 (Con 2 (Con 3 Nil))\n</code></pre>\n<pre><code class=\"language-haskell\">-- 二叉树的定义\ndata Tree a = Node a (Tree a) (Tree a)\n            | Empty\n              deriving (Show)\n</code></pre>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-02\n\ndata List a = Cons a (List a)\n            | Nil\n             deriving (Show)\n\nfromList (x:xs) = Cons x (fromList xs)\nfromList _ = Nil\n--------\n*Main&gt; :load main\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\n*Main&gt; fromList [1, 2, 3, 4, 5, 6]\nCons 1 (Cons 2 (Cons 3 (Cons 4 (Cons 5 (Cons 6 Nil)))))\n*Main&gt; fromList &quot;abcdef&quot;\nCons 'a' (Cons 'b' (Cons 'c' (Cons 'd' (Cons 'e' (Cons 'f' Nil)))))\n</code></pre>\n<h3 id=\"reporting-errors\" tabindex=\"-1\">Reporting Errors</h3>\n<p>Haskell 提供了一个标准函数用来处理代码中的错误：<code>error :: String -&gt; a</code>。那么问题来了，这个 <code>a</code> 从哪里来的。。我们提供了一个 <code>String</code> 但是竟然能吐出一个 <code>a type</code> ？！</p>\n<pre><code class=\"language-haskell\">*Main&gt; error &quot;2333&quot;\n*** Exception: 2333\nCallStack (from HasCallStack):\n  error, called at &lt;interactive&gt;:31:1 in interactive:Ghci3\n*Main&gt; :type error\nerror :: [Char] -&gt; a\n</code></pre>\n<h4 id=\"a-more-controlled-approach\" tabindex=\"-1\">A More Controlled Approach</h4>\n<p>相较于利用 <code>error</code> 强制停止程序，一个更加友善的方式是返回 <code>Nothing</code> 之类的东西，让调用者去处理。</p>\n<pre><code class=\"language-haskell\">-- tidySecond :: [a] -&gt; Maybe a\ntidySecond :: [a] -&gt; Maybe a\n\ntidySecond (_:x:_) = Just x\ntidySecond _ = Nothing\n</code></pre>\n<h3 id=\"%E3%82%88%E3%81%86%E3%81%93%E3%81%9D-%E5%B1%80%E9%83%A8-variable-%EF%BC%81\" tabindex=\"-1\">ようこそ 局部 Variable ！</h3>\n<p><code>let</code> 关键词可以用来定义新的局部变量。</p>\n<pre><code class=\"language-haskell\">lend amount balance = let reserve = 100\n                          newBalance = balance - amount\n                      in if balance &lt; reserve\n                         then Nothing\n                         else Just newBalance\n</code></pre>\n<div class=\"note\">\n<p>定义一个叫做 <code>lend</code> 的函数，<code>amount, balance</code> 是两个形参。</p>\n<p>注意，由于 haskell 是 Lazy Evaluation，所以 let 只是绑定一个表达式，并不是一个值。</p>\n<p>同时需要注意，空格缩进很重要。（栗子：该死的用缩进控制的语言）</p>\n</div>\n<p>我们可以在 <code>let</code> 语句块里和 <code>in</code> 语句块里使用这个变量。</p>\n<h4 id=\"shadowing\" tabindex=\"-1\">Shadowing</h4>\n<p>我们可以在表达式里面嵌套使用 <code>let</code>。</p>\n<pre><code class=\"language-haskell\">foo = let a = 1\n      in let b = 2\n         in a + b\n\n</code></pre>\n<p>之后内部的 <code>let</code> 可以 <code>shadow</code> <code>outer</code> 变量</p>\n<pre><code class=\"language-haskell\">bar = let x = 1\n      in ((let x = &quot;foo&quot; in x), x)\n      \nquux a = let a = &quot;foo&quot; in a ++ &quot;eek!&quot;\n</code></pre>\n<div class=\"note\">\n<p>利用 <code>-fwarn-name-shadowing</code> 可以让编译器提示 Shadowing 问题</p>\n</div>\n<h3 id=\"the-where-clause\" tabindex=\"-1\">The where Clause</h3>\n<pre><code class=\"language-haskell\">lend2 amount balance =\n    if amount &lt; reserve * 0.5\n    then Just newBalance\n    else Nothing\n    where reserve = 100\n          newBalance = balance - amount\n</code></pre>\n<p>Where Clause 可以增加程序的可读性</p>\n<p>和 <code>let in</code> 相比 <code>where clause</code> 将逻辑判断写在前面，局部变量写在后面。</p>\n<h3 id=\"local-functions%2C-global-variables\" tabindex=\"-1\">Local Functions, Global Variables</h3>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-02\n\n\npluralise word counts = plural counts\n    where plural 0 = &quot;no &quot; ++ word ++ &quot;s&quot;\n          plural 1 = &quot;one &quot; ++ word\n          plural n = show n ++ &quot; &quot; ++ word ++ &quot;s&quot;\n-----------\n*Main&gt; pluralise &quot;day&quot; 3\n&quot;3 days&quot;\n*Main&gt; pluralise &quot;day&quot; 1\n&quot;one day&quot;\n*Main&gt; pluralise &quot;day&quot; 0\n&quot;no days&quot;\n</code></pre>\n<p>上面，我们定义了一个局部函数 <code>plural</code>，由若干等式组成。</p>\n<div class=\"note\">\n<p>这里指的是 <code>where</code> 内定义的函数 <code>plural</code> ，这个函数是用一系列等式描述的。</p>\n</div>\n<div class=\"alert\">\n<p>原书的代码有问题，请参照栗子的代码</p>\n</div>\n<p>局部函数可以利用外部函数的变量，这里使用了外部的变量 <code>word</code> 。</p>\n<h2 id=\"the-offside-rule-and-whitespace-in-an-expression\" tabindex=\"-1\">The Offside Rule and Whitespace in an Expression</h2>\n<p>在 Haskell 中，<code>Whitespace</code> 是有意义的。</p>\n<p>Haskell 使用缩进作为代码块的分析线索。这种利用布局来表示结构的方式有时叫做 <code>offside rule</code>。每一个子结构的最顶初的声明必须有相同的缩进。</p>\n<p><code>let</code> 和 <code>where</code> 语句的规则也相似，编译器会记住<code>let where</code> 后面遇到的第一个 token 的缩进，之后作为后面所有后续项目的缩进标准。如果缩进和上一个项目相同，则认为是新的语句块。</p>\n<pre><code class=\"language-haskell\">bar = let b = 2\n          c = True\n       in let a = b\n           in (a, c)\n           \n------或者如下的方式------\nfoo = let { a = 1; b = 2; c = 3; }\n       in a + b + c\n</code></pre>\n<div class=\"note\">\n<p>不会叭不会叭，0202 年了，还有人用这种奇奇怪怪的缩进写法。</p>\n</div>\n<div class=\"alert\">\n<p>但是遗憾的是，根据 <code>Real World Haskell</code> 这个 explicit structuring 写法可能基本不会在 Haskell 程序中使用。</p>\n</div>\n<h3 id=\"the-case-expression\" tabindex=\"-1\">The case Expression</h3>\n<p>函数定义并不是我们唯一可以使用 pattern matching 的地方，另一个使用的地方是 <code>case constructor</code> 下面这个函数 <code>unwrap</code> 了一个 Maybe value。</p>\n<pre><code class=\"language-haskell\">fromMaybe defval wrapped =\n    case wrapped of\n      Nothing -&gt; defval\n      Just value -&gt; value\n-----------\n*Main&gt; fromMaybe 123 (Just 233)\n233\n</code></pre>\n<p><spoiler>栗子：各种 rust 即视感。。。感觉 rust 已经不纯洁了QAQ，原来早就变成了 Haskell 的形状</spoiler></p>\n<div class=\"note\">\n<p>同样的，我们也能用 <code>_</code> 来表达我们不 care 这个 pattern，作为一个 fallback 匹配。</p>\n</div>\n<h3 id=\"conditional-evaluation-with-guards\" tabindex=\"-1\">Conditional Evaluation with Guards</h3>\n<p>Haskell 提供了一个叫做 <code>guards</code> 的功能来做更有表达性的检查。</p>\n<pre><code class=\"language-haskell\">nodesAreSame (Node a _ _) (Node b _ _) \n       | a == b = Just a\n       | a == b &amp;&amp; a == 10 = Just 10\nnodesAreSame _ _ = Nothing\n</code></pre>\n<p>每个 <code>guards</code> 用 <code>|</code> 来分割，之后跟随着一个 <code>=</code> （或者 <code>-&gt;</code> ，在 case 的 pattern matching 情况下）。只要有一个 <code>guards</code> 的结果为 True，则这个 pattern 就会被选取。</p>\n<pre><code class=\"language-haskell\">lends3 amount balance =\n    | amount &lt;= 0            = Nothing\n    | amount &gt; reserve * 0.5 = Nothing\n    | otherwise              = Just newBalance\n    where reserve = 100\n          newBalance = balance - amount\n</code></pre>\n<p>另一个栗子：</p>\n<pre><code class=\"language-haskell\">myDrop n xs = if n &lt;= 0 || null xs\n              then xs\n              else myDrop (n-1) (tail xs)\n------下面是更好(?)的版本-----\nniceDrop n xs | n &lt;= 0 = xs\nniceDrop _ []          = []\nniceDrop n (_:xs)      = niceDrop (n-1) xs\n</code></pre>\n<h1 id=\"day-5%3A-tenet%E6%98%A0%E7%94%BB%E3%82%92%E8%A6%8B%E3%81%BE%E3%81%97%E3%81%9F%EF%BC%81\" tabindex=\"-1\">Day 5: Tenet映画を見ました！</h1>\n<h2 id=\"chapter-4%3A-functional-programming\" tabindex=\"-1\">Chapter 4: Functional Programming</h2>\n<div class=\"note\">\n<p>大家都喜欢的 FP ！</p>\n<p><spoiler>Dive into the Hell of Functional Programming</spoiler></p>\n</div>\n<p>首先放上去一个栗子！（用来献祭）</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-04\n\nimport System.Environment (getArgs)\n\ninteractWith function inputFile outputFile = do\n    input &lt;- readFile inputFile\n    writeFile outputFile (function input)\n\nmain = mainWith myFunction where\n    mainWith function = do\n        args &lt;- getArgs\n        case args of\n          [input, output] -&gt; interactWith function input output\n          _ -&gt; putStrLn &quot;error: exactly two arguments needed&quot;\n\n    myFunction = id\n</code></pre>\n<div class=\"note\">\n<p>上面的代码引入了一个新的关键字：<code>do</code>。<code>do</code> 用来引入能够对现实世界有影响的代码块，比如读写文件。</p>\n<p><code>&lt;-</code> 在<code>do</code>代码块里面等同于赋值语句。</p>\n</div>\n<p>另一个栗子：</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-04\n\nsplitlines :: string -&gt; [string]\n\nsplitlines [] = []\nsplitlines cs =\n    let (pre, suf) = break islineterminator cs in\n        pre : case suf of\n                ('\\r':'\\n':rest) -&gt; splitlines rest\n                ('\\r':rest)      -&gt; splitlines rest\n                ('\\n':rest)      -&gt; splitlines rest\n                _                -&gt; []\nislineterminator c = c == '\\r' || c == '\\n'\n\n----\nPrelude&gt; :type break\nbreak :: (a -&gt; Bool) -&gt; [a] -&gt; ([a], [a])\nPrelude&gt; break odd [2,4,5,6,7]\n([2,4],[5,6,7])\n</code></pre>\n<div class=\"note\">\n<p><code>break</code> 在 <code>prelude</code> 中定义，用来将列表分割成两部分。根据函数来决定在列表的哪个位置进行分割。</p>\n</div>\n<h3 id=\"infix-functions\" tabindex=\"-1\">Infix Functions</h3>\n<p>通常我们在 Haskell 中定义和使用函数的时候，都是先写函数名，再跟着参数。这种方式叫做<code>prefix</code>（前缀）。</p>\n<p>如果函数有2个及以上的参数的时候，我们可以有一个叫做 <code>infix</code> 的形式（类似于运算符的中缀表达式 1 add 1），放在第一个和第二个参数中间。</p>\n<p>为了定义和使用函数的 <code>infix</code> 形式。我们需要把函数名用 ` 包裹起来。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-04\n\na `plus` b = a + b\n\ndata a `Pair` b = a `Pair` b\n                  deriving (Show)\n\n\nfoo = Pair 1 2\nbar = True `Pair` &quot;quux&quot;\n-------\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\n*Main&gt; foo\n1 `Pair` 2\n*Main&gt; bar\nTrue `Pair` &quot;quux&quot;\n*Main&gt; 1 `plus` 2\n3\n*Main&gt; plus 1 2\n3\n</code></pre>\n<h3 id=\"working-with-lists\" tabindex=\"-1\">Working with Lists</h3>\n<h4 id=\"safely-and-sanely-working-with-crashy-functions\" tabindex=\"-1\">Safely and Sanely Working with Crashy Functions</h4>\n<p>由于 Haskell 的 List 并不存储 Length 信息，因此 <code>length</code> 函数获得长度信息的唯一办法是遍历整个序列。 所以 Haskell way 做 List 判断是使用 <code>null</code> 函数</p>\n<pre><code class=\"language-haskell\">myDumbExample xs = if not (null xs)\n                      then head xs\n                      else 'Z'\n</code></pre>\n<h3 id=\"partial-and-total-functions\" tabindex=\"-1\">Partial and Total Functions</h3>\n<div class=\"define\">\n<p>Functions that have only return values defined for a subset of valid inputs are called <code>partial fucntions</code></p>\n<p>We call functions that return valid results over their entire input domains <code>total functions</code></p>\n</div>\n<h3 id=\"how-to-think-about-loops\" tabindex=\"-1\">How to Think About Loops</h3>\n<div class=\"alert\">\n<p>震惊！和其他传统语言不一样，Haskell <strong>没有</strong> <code>for</code> 或者 <code>while</code> 循环。</p>\n</div>\n<p>下面给出对循环的解决方法。</p>\n<h4 id=\"%E6%98%BE%E5%BC%8F%E9%80%92%E5%BD%92-explicit-recursion\" tabindex=\"-1\">显式递归 Explicit Recursion</h4>\n<p>以下面的 <code>CPP</code> 程序为栗：</p>\n<pre><code class=\"language-c++\">int as_int(char *ss) {\n  int acc = 0;\n  for (acc = 0; isdigit(*str); str++) {\n    acc = acc * 10 + (*str - '0');\n  }\n  return acc;\n}\n</code></pre>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-04\n\nimport Data.Char (digitToInt)\n\nasInt :: String -&gt; Int\nasInt xs = loop 0 xs\n\nloop acc [] = acc      -- terminating case / base case\nloop acc (x:xs) = loop (acc * 10 + digitToInt x) xs  -- inductive case\n\n---- or -----\nloop acc [] = acc\nloop acc (x:xs) =  let acc' = acc * 10 + digitToInt x\n                       in loop acc' xs\n</code></pre>\n<div class=\"note\">\n<p><strong>变量名和单引号</strong></p>\n<p>单引号在 Haskell 里面是合法的变量名字符，发音为 prime。一般认为 <code>foo'</code> 是和 <code>foo</code> 相关的变量（通常是 foo 的新值）。</p>\n<p>你甚至可以用 <code>foo''</code></p>\n</div>\n<div class=\"extra\">\n<p><strong>尾递归</strong></p>\n<p>在 Haskell 中，我们用尾递归代替 Loop。通常来讲尾递归相比循环会占用更多的空间和时间。但是 FP 会利用 TCO（尾递归优化）自动把递归调用转换成常数空间占用的代码。</p>\n</div>\n<h3 id=\"transforming-every-piece-of-input\" tabindex=\"-1\">Transforming Every Piece of Input</h3>\n<h3 id=\"mapping-over-a-list\" tabindex=\"-1\">Mapping over a List</h3>\n<pre><code class=\"language-haskell\">*Main Data.List&gt; a = [1, 2, 3, 4]\n*Main Data.List&gt; upper x = x^2\n*Main Data.List&gt; map upper a\n[1,4,9,16]\n</code></pre>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-04\n\nmyMap :: (a-&gt;b) -&gt; [a] -&gt; [b]\n\nmyMap f (x:xs) = f x : myMap f xs\nmyMap _ _ = []\n--------------------\n*Main Data.List&gt; myMap odd [1,2,3,4]\n[True,False,True,False]\n*Main Data.List&gt; a = [1,2,3,4]\n*Main Data.List&gt; myMap odd a\n[True,False,True,False]\n</code></pre>\n<h3 id=\"selecting-pieces-of-input\" tabindex=\"-1\">Selecting Pieces of Input</h3>\n<p>另一个常见的对序列数据的操作是筛选出某些元素。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-04\n\noddList :: [Int] -&gt; [Int]\n\noddList (x:xs) | odd x     = x : oddList xs\n               | otherwise = oddList xs\noddList _                  = []\n----------------\n*Main Data.List&gt; :load main\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\n*Main Data.List&gt; oddList [1,2,3,4,5]\n[1,3,5]\n*Main Data.List&gt; filter odd [1,2,3,4,5]\n[1,3,5]\n</code></pre>\n<h3 id=\"computing-one-answer-over-a-collection\" tabindex=\"-1\">Computing One Answer over a Collection</h3>\n<p>另一个常见的操作上将整个列表聚合成一个元素。</p>\n<pre><code class=\"language-haskell\">mySum xs = helper 0 xs\n    where helper acc (x:xs) = helper (acc + x) xs\n          helper acc _      = acc\n-------------\n*Main Data.List&gt; :load main\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\n*Main Data.List&gt; mySum [1,2,3,4,5,6]\n21\n</code></pre>\n<h3 id=\"the-left-fold\" tabindex=\"-1\">The Left Fold</h3>\n<pre><code class=\"language-haskell\">*Main Data.List&gt; foldl (+) 0 [1,2,3,4,5,6]\n21\n</code></pre>\n<h2 id=\"anonymous-(lambda)-functions\" tabindex=\"-1\">Anonymous (lambda) Functions</h2>\n<p>Haskell 允许我们写完全匿名的函数，从而免去给辅助函数命名的烦恼。匿名函数也经常叫做 &quot;lambda \\(\\lambda\\)&quot; 函数。使用 <code>\\</code> 来引入 lambda 函数，之后是函数的参数，之后用 <code>-&gt;</code> 来引入函数主体。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-04\n\nimport Data.List (isInfixOf)\n\nisInAny needle haystack = any inSequence haystack\n    where inSequence s = needle `isInfixOf` s\n\n---- lambda version below -----\n\nisInAny2 needle haystack = any (\\s -&gt; needle `isInfixOf` s) haystack\n</code></pre>\n<div class=\"note\">\n<p>lambda 函数被包裹在 <code>()</code> 中来方便 Haskell 编译器确定函数体的范围。</p>\n</div>\n<p>大部分时候匿名函数和普通的函数的行为相同，但是在定义匿名函数的时候 Haskell 加上了一些限制。最重要的一点，在写普通函数的时候我们可以使用多个包含不同 pattern 和 guards 的 Clause。但是 lambda 函数只能有一个 clause。</p>\n<p>单 Clause 限制我们在定义 lambda 时候如何使用 pattern：</p>\n<pre><code class=\"language-haskell\">safeHead (x:_) = Just x\nsafeHead _ = Nothing\n</code></pre>\n<p>但是因为我们不能在定义 lambda 函数的时候使用多个 Clause 因此我们必须写出匹配任意的 pattern：</p>\n<pre><code class=\"language-haskell\">unsafeHead = \\(x:_) -&gt; x\n\n-------\nKuriko&gt; :load main\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\nKuriko&gt; unsafeHead [1,2,3]\n1\nKuriko&gt; unsafeHead []\n*** Exception: main.hs:5:14-24: Non-exhaustive patterns in lambda\n</code></pre>\n<p>悲惨的是这个错误能通过编译器的语法检查，因此只能在 <code>runtime</code> 触发。。所以。。</p>\n<div class=\"alert\">\n<p>当在匿名函数中使用 patterns 的时候，请一定保证你的 patterns <strong>不会</strong>匹配失败。</p>\n</div>\n<h1 id=\"day-6%3A-%E6%94%BE%E5%81%87%E5%95%A6%EF%BD%9E\" tabindex=\"-1\">Day 6: 放假啦～</h1>\n<h2 id=\"partial-function-application-and-currying\" tabindex=\"-1\">Partial Function Application and Currying</h2>\n<div class=\"note\">\n<p>偏函数和柯里化です</p>\n</div>\n<p>还是先看一个栗子：</p>\n<pre><code class=\"language-haskell\">Kuriko&gt; :type dropWhile\ndropWhile :: (a -&gt; Bool) -&gt; [a] -&gt; [a]\n</code></pre>\n<p>注意一下<code>-&gt;</code>，这里的 <code>-&gt;</code> 似乎有两种意思，但实际上所有的 <code>-&gt;</code> 都可以理解为：左边是参数，右边是返回值。</p>\n<p>这一点在 Haskell 中十分重要，所有的函数都只接收一个且仅接收一个参数。所以 <code>dropwhile</code> 可以认为是接受了一个函数，并返回了一个函数。</p>\n<pre><code class=\"language-haskell\">Kuriko&gt; :type isSpace\nisSpace :: Char -&gt; Bool\nKuriko&gt; :type dropWhile isSpace\ndropWhile isSpace :: [Char] -&gt; [Char]\n</code></pre>\n<p>现在，我们给了 <code>dropWhile</code> 一个函数 <code>isSpace</code> 之后，可以看到返回了一个 <code>[a] -&gt; [a]</code>。</p>\n<p>因此我们可以利用这些函数组合出更高阶的函数：</p>\n<pre><code class=\"language-haskell\">Kuriko&gt; map (dropWhile isSpace) [&quot; a&quot;, &quot;f&quot;, &quot;    e&quot;]\n[&quot;a&quot;,&quot;f&quot;,&quot;e&quot;]\n</code></pre>\n<h1 id=\"day-7%3A-%E3%81%8A%E9%82%AA%E9%AD%94%E3%81%97%E3%81%BE%E3%81%99\" tabindex=\"-1\">Day 7: お邪魔します</h1>\n<div class=\"note\">\n<p>最近忙于把论文排版成 \\(\\LaTeX\\)，没什么时间更新 Blog。。。</p>\n</div>\n<p>接上回，<code>dropWhile isSpace</code> 相当于组成了一个新的函数，能够把一个列表的前面的空格元素去掉。</p>\n<p>当我们给一个函数传递少于她要求个数个参数的时候，我们称其为 <code>partial application</code>。以上一个栗子为例：</p>\n<pre><code class=\"language-haskell\">isInAny3 needle haystack = any (isInfixOf needle) haystack\n</code></pre>\n<p>这里的 <code>isInfixOf needle</code> 是一个 <code>partial function application</code>，我们使用了 <code>isInfixOf</code> 这个函数，并且固定了她的第一个参数。</p>\n<p><code>partial function application</code> 叫做 <code>currying</code>，根据 Haskell Curry 而命名。</p>\n<h3 id=\"sections\" tabindex=\"-1\">Sections</h3>\n<p>Haskell 提供了方便的方法让我们用 <code>infix</code> 的形式写偏函数。如果我们用括号包裹了一个操作，我们可以在括号内的左或右提供她的操作数，从而得到偏函数。这种得到偏函数的方法叫做 <code>section</code></p>\n<pre><code class=\"language-haskell\">Prelude&gt; op = (1+)\nPrelude&gt; op 2\n3\nPrelude&gt; map (*3) [24, 36]\n[72,108]\nPrelude&gt; map (3*) [24, 36]\n[72,108]\n</code></pre>\n<h3 id=\"as-patterns\" tabindex=\"-1\">As-patterns</h3>\n<pre><code class=\"language-haskell\">Prelude Data.List&gt; :type tails\ntails :: [a] -&gt; [[a]]\nPrelude Data.List&gt; tails &quot;kuriko&quot;\n[&quot;kuriko&quot;,&quot;uriko&quot;,&quot;riko&quot;,&quot;iko&quot;,&quot;ko&quot;,&quot;o&quot;,&quot;&quot;]\nPrelude Data.List&gt; tails []\n[[]]\n</code></pre>\n<p>现在如果我们想获得一个不会返回空的 <code>tails</code> 函数呢？下面我们将会实现自己版本的 <code>tails</code></p>\n<p>这里我们引入一个新的记号: <code>@</code> 符号</p>\n<pre><code class=\"language-haskell\">suffixes :: [a] -&gt; [[a]]\n\nsuffixes xs@(_:xs') = xs : suffixes xs'\nsuffixes _ = []\n</code></pre>\n<p>模式 <code>xs@(_:xs')</code> 叫做 <code>as-pattern</code>。意思是：「bind the variable <code>xs</code> to the value that matches the right side of the <code>@</code> symbol」.</p>\n<div class=\"note\">\n<p>即符合 pattern 的那玩意被赋值给了 <code>xs</code> 这个变量。</p>\n</div>\n<p>使用 AsPattern 的好处除了可读性问题之外，还能减少 copy，如果我们用 (x:xs) 代替的话，会在运行时触发一次新的构造。而使用 AsPattern 的话，xs 实际上会被复用。</p>\n<h3 id=\"code-reuse-through-composition\" tabindex=\"-1\">Code Reuse Through Composition</h3>\n<p>在 Haskell 中，Prelude 提供了一个函数 <code>(.)</code> 用于 <code>compose</code>，</p>\n<pre><code class=\"language-haskell\">compose f g x = f (g x)\nsuffixes2 = compose init tails\nsuffixes3 = init . tails\n----------\n*Main Data.List&gt; :type (.)\n(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c\n</code></pre>\n<p>我们可以连锁使用 <code>.</code> 来创造出新的函数。</p>\n<pre><code class=\"language-haskell\">Kuriko &gt; capCount = length . filter (isUpper . head) . words\nKuriko &gt; capCount &quot;Hello, There Mom!&quot;\n3\n</code></pre>\n<h2 id=\"chapter-5%3A-writing-a-library%3A-working-with-json-data\" tabindex=\"-1\">Chapter 5: Writing a Library: Working with JSON Data</h2>\n<h3 id=\"respresenting-json-data-in-haskell\" tabindex=\"-1\">Respresenting JSON Data in Haskell</h3>\n<pre><code class=\"language-haskell\">data JValue = JString String\n            | JNumber Double\n            | JBool Bool\n            | JNull\n            | JObject [(String, JValue)]\n            | JArray [JValue]\n              deriving (Eq, Ord, Show)\n              \ngetString (JString s) = Just s\ngetString _ = Nothing\n\n-- .....\n\nisNull v = v == JNull\n</code></pre>\n<h3 id=\"the-anatomy-of-a-haskell-module\" tabindex=\"-1\">The Anatomy of a Haskell Module</h3>\n<p>一个 Haskell 的源文件包含了单个 <code>module</code> 的定义。一个 <code>module</code> 允许我们决定哪些名字可以在模块外部被访问。</p>\n<div class=\"alert\">\n<p>注意 <code>module</code> 定义关键词必须在所有其他的定义之前。并且 module 名必须是首字母大写（而且不能是 Main）。并且我们的源文件名名字的 <code>base name</code> （The component before the suffix）必须和 module name 一致。</p>\n</div>\n<pre><code class=\"language-haskell\">module SimpleJson\n    (\n        JValue(..),\n        getString,\n        isNull\n    ) where\n\ndata JValue = JString String\n            | JNumber Double\n            | JBool Bool\n            | JNull\n            | JObject [(String, JValue)]\n            | JArray [JValue]\n              deriving (Eq, Ord, Show)\n\ngetString (JString s) = Just s\ngetString _ = Nothing\n\nisNull v = v == JNull\n</code></pre>\n<p>where 代表这 module 的 body 部分开始。</p>\n<p><code>(..)</code> 代表我们将会导出 <code>type</code> 以及其所有的 <code>constructors</code></p>\n<div class=\"explain\">\n<p>虽然看起来我们能导出一个 type 的名字（即其 <code>type constructor</code>）而不是其 <code>value constructor</code> 很奇怪。但是能这么做其实是很重要的：她允许我们对其使用者隐藏类型的细节，使得这个类型 <code>abstract</code> 。如果我们不能看到这个 <code>type</code> 的 <code> value constructor</code> 那么我们就不能对这个 <code>type</code> 进行 pattern match，同时我们也不能根据这个 Type 创建新的 value. 接下来的章节我们会讨论什么时候我们会希望 Type 是 abstract 的。</p>\n</div>\n<p>如果我们去掉 <code>()</code> 和内部的东西，我们就会将 module 里面所有的东西都导出。</p>\n<p>或者如果我们 <code>()</code> 内是空的，那么该 module 里面任何东西都不会被导出。</p>\n<pre><code class=\"language-haskell\">module ExportEverything where\n--------------\nmodule ExportNothing () where\n</code></pre>\n<h3 id=\"compiling-haskell-source\" tabindex=\"-1\">Compiling Haskell Source</h3>\n<p><code>ghc</code> 可以用于编译 haskell 源文件名到 <code>native code</code></p>\n<div class=\"alert\">\n<p>现在的 ghc 会自动根据 import 来查找对应的 <code>.h</code> 文件进行导入（类似于 #include 这种语意）因此不需要编译成 <code>.o</code> 再进行链接。</p>\n<p>另外至少需要导出一个 main 来个外面的世界交互。。</p>\n<pre><code class=\"language-haskell\">➜  haskell ghc Main.hs SimpleJSON.o\n[2 of 2] Compiling Main             ( Main.hs, Main.o )\n\nMain.hs:1:1: error:\n    The IO action ‘main’ is not exported by module ‘Main’\n  |\n1 | -- file: main.hs\n  | ^\n\n</code></pre>\n</div>\n<pre><code class=\"language-haskell\">module Main (main) where\n\nimport SimpleJSON\n\nmain = print (JObject [(&quot;foo&quot;, JNumber 1), (&quot;bar&quot;, JBool False)])\n-------------\n➜  haskell ghc Main.hs  -o simple\nLinking simple ...\n➜  haskell ./simple\nJObject [(&quot;foo&quot;,JNumber 1.0),(&quot;bar&quot;,JBool False)]\n</code></pre>\n<h3 id=\"type-inference-is-a-double-edged-sword\" tabindex=\"-1\">Type Inference Is a Double-Edged Sword</h3>\n<pre><code class=\"language-haskell\">import Data.Char\n\n-- upcaseFirst :: String -&gt; String\n-- upcaseFirst (c:cs) = toUpper c : cs\nupcaseFirst (c:cs) = toUpper c -- supposed that we forgot `: cs`\n</code></pre>\n<p>如果我们忘记了 <code>: cs</code> 同时没有显式的写出 upcaseFirst 的函数签名，那么编译器仍然能够通过这个函数，不过签名自动推导成了 <code>[Char] -&gt; Char</code>。这将会导致之后在使用的时候才爆出问题。如果我们能够一开始就写出函数签名，那么编译器会自动检测到签名不符而报错。</p>\n<pre><code class=\"language-haskell\">Prelude&gt; :reload\n[1 of 1] Compiling Main             ( main.hs, interpreted )\n\nmain.hs:8:22: error:\n    • Couldn't match type ‘Char’ with ‘[Char]’\n      Expected type: String\n        Actual type: Char\n    • In the expression: toUpper c\n      In an equation for ‘upcaseFirst’: upcaseFirst (c : cs) = toUpper c\n  |\n8 | upcaseFirst (c:cs) = toUpper c -- forgot &quot;:cs&quot; here\n  |                      ^^^^^^^^^\n</code></pre>\n<div class=\"info\">\n<p>通常来讲，代码的第一个 <code>definition</code> 应该加上签名。</p>\n</div>\n<h3 id=\"a-more-general-look-at-rendering\" tabindex=\"-1\">A More General Look at Rendering</h3>\n<p>// TODO</p>\n<h3 id=\"pretty-printing-a-string\" tabindex=\"-1\">Pretty Printing a String</h3>\n<pre><code class=\"language-haskell\">string :: String -&gt; Doc\nstring = enclose '&quot;' '&quot;' . hcat . map oneChar\n</code></pre>\n<div class=\"info\">\n<p><strong>Point-free style</strong></p>\n<p>这种将定义写成其他函数的组合形式叫做 <code>point-free sytle</code> ，这里的 point 并不是指 <code>.</code></p>\n<p>Point 大致上指的是 'synonymous (in Hasekll)' with value, 所以这里的 'point-free' 表达式意思是不会提到要作用的值。（大意是表达式里面只有函数的组合）</p>\n<p>所以上面的改写成 pointy 版本是</p>\n<pre><code class=\"language-haskell\">pointyString :: String -&gt; Doc\npointyString s = enclose '&quot;' '&quot;' (hcat (map oneChar s))\n</code></pre>\n</div>\n<h1 id=\"day-%E3%83%8F%E3%83%81%EF%BC%9A%E7%96%B2%E3%82%8C%E3%81%9F\" tabindex=\"-1\">Day ハチ：疲れた</h1>\n<h2 id=\"chapter-6%3A-using-typeclasses\" tabindex=\"-1\">Chapter 6: Using Typeclasses</h2>\n<p>Typeclasses 是 Haskell 里面最重要的特性之一，他允许我们定义泛化的接口从而在广泛的类型上提供通用的特性。在讨论 typeclasses 是什么之前，我们先解释一下我们为什么需要这个特性。</p>\n<h3 id=\"the-need-for-typeclasses\" tabindex=\"-1\">The Need for Typeclasses</h3>\n<p>假设某一天 Haskell 的设计者们拒绝在 Haskell 中实现 <code>==</code> 运算符（明显，他们终于写 Haskell 写疯了）。那么卑微的各位 Haskell 开发者们只好自行实现相应的 <code>equality test</code> 了。</p>\n<pre><code class=\"language-haskell\">data Color = Red | Green | Blue\n\ncolorEq :: Color -&gt; Color -&gt; Bool\n\ncolorEq Red Red = True\ncolorEq Green Green = True\ncolorEq Blue Blue = True\ncolorEq _ _ = False\n</code></pre>\n<p>下面假设我们需要对 <code>String</code> 做 Eq 判断，由于 <code>String</code> 实际上是 <code>[Char]</code> 所以我们应该逐个判断：</p>\n<pre><code class=\"language-haskell\">stringEq :: [Char] -&gt; [Char] -&gt; Bool\nstringEq [] [] = True\nstringEq (x:xs) (y:ys) = x == y &amp;&amp; stringEq xs ys\nstringEq _ _ = False\n</code></pre>\n<p>现在问题来了，对于不同的类型 <code>Color</code>, <code>String</code> 我们需要对每种 Type 都定义对应的比较函数。对应的，当我们做比较的时候，我们甚至需要判断 type 来调用对应的比较函数。而原本的 == 则可以作用在所有的可比较的 type 上。</p>\n<p>此时，当当当，<code>Typeclasses</code> 来拯救大家啦</p>\n<p><code>Typeclasses</code> 定义了一系列函数，这些函数能在不同的 Type 上有不同的实现。</p>\n<div class=\"note\">\n<p>看起来 Typeclasses 有点像 OOP 里面的某些概念，但是实际上是完全不同的。</p>\n</div>\n<p>下面我们用 Typeclasses 来解决一下上一节提出的问题：</p>\n<pre><code class=\"language-haskell\">class BasicEq a where\n\tisEqual :: a -&gt; a -&gt; Bool\n-------------\n*Main&gt; :type isEqual\nisEqual :: BasicEq a =&gt; a -&gt; a -&gt; Bool\n</code></pre>\n<p>For all types <strong>a</strong>, so long as <strong>a</strong> is an instance of <strong>BaiscEq</strong>, <strong>isEqual</strong> takes two parameters of type <strong>a</strong> and returns a <strong>Bool</strong>.</p>\n<pre><code class=\"language-haskell\">instance BasicEq Bool where\n    isEqual True True = True\n    isEqual False False = True\n    isEqual _ _ = False\n</code></pre>\n<p>底下的是提供了默认实现。用户如果想实现这个 <code>Class</code> 则必须至少实现两个中的一个。</p>\n<pre><code class=\"language-haskell\">class BasicEq3 a where\n    isEqual3 :: a -&gt; a -&gt; Bool\n    isEqual3 x y = not (isNotEqual3 x y)\n\n    isNotEqual3 :: a -&gt; a -&gt; Bool\n    isNotEqual3 x y = not (isEqual3 x y)\n</code></pre>\n<h3 id=\"declaring-typeclass-instances\" tabindex=\"-1\">Declaring Typeclass Instances</h3>\n<h3 id=\"important-built-in-typeclasses\" tabindex=\"-1\">Important Built-in Typeclasses</h3>\n<h4 id=\"show\" tabindex=\"-1\">Show</h4>\n<p>Show 用来将 value 转变为 Strings。</p>\n<pre><code class=\"language-haskell\">instance Show Color where\n    show Red = &quot;Red&quot;\n    show _ = &quot;Not Red&quot;\n</code></pre>\n<h4 id=\"read\" tabindex=\"-1\">Read</h4>\n<p><code>Read</code> 的作用和 <code>Show</code> 相反。她接受一个 <code>String</code> 解析并返回任何一个 <code>Read</code> 允许的类型。</p>\n<pre><code class=\"language-haskell\">main = do\n    putStrLn &quot;Please enter a double:&quot;\n    inpStr &lt;- getLine\n    let inpDouble = (read inpStr)::Double\n    putStrLn (&quot;Twice&quot; ++ show inpDouble ++ &quot; is &quot; ++ show (inpDouble *2))\n</code></pre>\n<div class=\"note\">\n<p>这里的 <code>::Double</code> 是类型声明的那个 <code>::</code></p>\n<p><code>isEqual :: BasicEq a =&gt; a -&gt; a -&gt; Bool</code></p>\n</div>\n","slug":"学习笔记/Haskell/Real-World-Haskell-学习笔记","published":true,"date":"2020-08-28T11:54:54.000Z","updated":"2022-04-02T17:45:11.000Z","path":"学习笔记/Haskell/Real-World-Haskell-学习笔记/","api_path":"api/articles/学习笔记/Haskell/Real-World-Haskell-学习笔记.json","keywords":null,"config":{"max_toc_level":2},"tags":[{"name":"学习笔记","path":"api/tags/学习笔记.json"},{"name":"Haskell","path":"api/tags/Haskell.json"}]},{"title":"唐盾：0-N4日语精讲","subtitle":"第四十四課：玄関のところにだれかいるようです","author":"Kuriko Moe (栗子Chan)","excerpt":"<p>第四十四课：门厅哪里好像有人</p>\n<p><strong>内容</strong>： ～ようです |～みたい、～らしい</p>\n<p><strong>教程地址</strong>：<a href=\"https://www.bilibili.com/cheese/play/ep1338\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/cheese/play/ep1338</a></p>\n","render_content":"<p>第四十四课：门厅哪里好像有人</p>\n<p><strong>内容</strong>： ～ようです |～みたい、～らしい</p>\n<p><strong>教程地址</strong>：<a href=\"https://www.bilibili.com/cheese/play/ep1338\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/cheese/play/ep1338</a></p>\n<!-- more -->\n<h1 id=\"%E5%8D%98%E8%AA%9E\" tabindex=\"-1\">単語</h1>\n<h2 id=\"%E5%90%8D%E8%A9%9E\" tabindex=\"-1\">名詞</h2>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>平仮名</th>\n<th>中国語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>社員旅行</td>\n<td>しゃいんりょこう</td>\n<td>员工旅行</td>\n<td>社員旅行に行きます</td>\n</tr>\n<tr>\n<td>新入社員</td>\n<td>しんにゅうしゃいん</td>\n<td>新来的职员</td>\n<td>後輩（こうはい）<br />先輩（せんぱい）</td>\n</tr>\n<tr>\n<td>会議場</td>\n<td>かいぎじょう</td>\n<td>会场</td>\n<td>会議室（かいぎしつ）</td>\n</tr>\n<tr>\n<td>国際会議</td>\n<td>こくさいかいぎ</td>\n<td>国际会议</td>\n<td>国際会議を行う（おこなう）<br />举行国际会议</td>\n</tr>\n<tr>\n<td>ビアガーデン</td>\n<td></td>\n<td>庭院式的啤酒店</td>\n<td></td>\n</tr>\n<tr>\n<td>大型スーパー</td>\n<td>おおがたすーぱー</td>\n<td>大型超市</td>\n<td><ruby>小型<rt>こがた</rt></ruby>スーパー</td>\n</tr>\n<tr>\n<td>湖</td>\n<td>みずうみ</td>\n<td>湖</td>\n<td></td>\n</tr>\n<tr>\n<td>パトカー</td>\n<td></td>\n<td>警车，巡逻车</td>\n<td>パトカーがたくさんある</td>\n</tr>\n<tr>\n<td>サイレン</td>\n<td></td>\n<td>警笛</td>\n<td>サイレンが鳴る（なる）</td>\n</tr>\n<tr>\n<td>アニメ</td>\n<td></td>\n<td>动画</td>\n<td>日本のアニメが好きです</td>\n</tr>\n<tr>\n<td>パワー</td>\n<td></td>\n<td>能力，力量</td>\n<td>パワーがある</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>パワーが持つ（もつ）</td>\n</tr>\n<tr>\n<td>心</td>\n<td>こころ</td>\n<td>心，内心</td>\n<td>暖かい心（あたたかいこころ）</td>\n</tr>\n<tr>\n<td>態度</td>\n<td>たいど</td>\n<td>态度</td>\n<td>態度がよくない</td>\n</tr>\n<tr>\n<td>性格</td>\n<td>せいかく</td>\n<td>性格</td>\n<td>明るい性格，あかるい</td>\n</tr>\n<tr>\n<td>評判</td>\n<td>ひょうばん</td>\n<td>评价，评论</td>\n<td>評判がいい，評判が高い</td>\n</tr>\n<tr>\n<td>行列</td>\n<td>ぎょうれつ</td>\n<td>行列，队伍</td>\n<td>行列が長い</td>\n</tr>\n<tr>\n<td>容器</td>\n<td>ようき</td>\n<td>容器</td>\n<td>容器が大きい，容器が小さい</td>\n</tr>\n<tr>\n<td>内容</td>\n<td>ないよう</td>\n<td>内容</td>\n<td>内容は素晴らしいです</td>\n</tr>\n<tr>\n<td>売れ行き</td>\n<td>うれゆき</td>\n<td>销路，销售（情况）</td>\n<td>売れ行きがいい・よい</td>\n</tr>\n<tr>\n<td>乗り物</td>\n<td>のりもの</td>\n<td>交通工具</td>\n<td>乗り物に乗る</td>\n</tr>\n<tr>\n<td>汗</td>\n<td>あせ</td>\n<td>汗</td>\n<td>汗をかく，出汗<br />汗をかきました</td>\n</tr>\n<tr>\n<td>倍</td>\n<td>ばい</td>\n<td>成倍，加倍</td>\n<td><ruby>賞金<rt>しょうきん</rt></ruby>を倍にする</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>やられたら，やリ返す，倍返しだ</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td><img src=\"https://kurikomoe-1300672427.cos.ap-beijing.myqcloud.com/img20220319220446.png\" alt=\"三倍奉还\" /></td>\n</tr>\n<tr>\n<td>縦</td>\n<td>たて</td>\n<td>纵，竖</td>\n<td>縦に書く</td>\n</tr>\n<tr>\n<td>中国全土</td>\n<td>ちゅうごくぜんど</td>\n<td>中国全境</td>\n<td>日本中，にほんじゅう</td>\n</tr>\n<tr>\n<td>長期予報</td>\n<td>ちょうきよほう</td>\n<td>长期预报</td>\n<td>天気予報，てんきよほう</td>\n</tr>\n<tr>\n<td>笑い</td>\n<td>わらい</td>\n<td>笑容</td>\n<td>笑う（動詞），笑います<br />去掉ます的连用形部分可以当名词</td>\n</tr>\n<tr>\n<td>暑さ</td>\n<td>あつさ</td>\n<td>暑热，暑气</td>\n<td>暑さを感じる</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>暑いー＞暑さ</td>\n</tr>\n<tr>\n<td>美しさ</td>\n<td>うつくしさ</td>\n<td>美好，美丽程度</td>\n<td>美しい，美しさ。<br />桜の美しさ</td>\n</tr>\n<tr>\n<td>面白さ</td>\n<td>おもしろさ</td>\n<td>趣味，有趣程度</td>\n<td>この映画の面白さ，这部电影的有趣之处</td>\n</tr>\n<tr>\n<td>大きさ</td>\n<td>おおきさ</td>\n<td>大小（体积）</td>\n<td>大きさがちょうどいい</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>ちょうど != ちょっと</td>\n</tr>\n<tr>\n<td>高さ</td>\n<td>たかさ</td>\n<td>高度</td>\n<td>高さが同じです</td>\n</tr>\n<tr>\n<td>深さ</td>\n<td>ふかさ</td>\n<td>深度</td>\n<td>海の深さ</td>\n</tr>\n<tr>\n<td>長さ</td>\n<td>ながさ</td>\n<td>长度</td>\n<td>作文の長さ，作文的长度<br />髪の長さ</td>\n</tr>\n<tr>\n<td>広さ</td>\n<td>ひろさ</td>\n<td>面积</td>\n<td>教室の広さ</td>\n</tr>\n<tr>\n<td>太さ</td>\n<td>ふとさ</td>\n<td>粗（度）</td>\n<td>この棒の太さは３センチあります</td>\n</tr>\n<tr>\n<td>重さ</td>\n<td>おもさ</td>\n<td>重量</td>\n<td>荷物の重さを<ruby>測<rt>はか</rt></ruby>る</td>\n</tr>\n<tr>\n<td>厚さ</td>\n<td>あつさ</td>\n<td>厚度</td>\n<td>辞書の厚さ</td>\n</tr>\n<tr>\n<td>速さ</td>\n<td>はやさ</td>\n<td>速度</td>\n<td>新幹線の速さ</td>\n</tr>\n<tr>\n<td>便利さ</td>\n<td>べんりさ</td>\n<td>方便程度</td>\n<td>町の便利さ，城市的方便程度</td>\n</tr>\n<tr>\n<td>複雑さ</td>\n<td>ふくざつさ</td>\n<td>复杂程度</td>\n<td>問題の複雑さ</td>\n</tr>\n<tr>\n<td>美味しさ</td>\n<td>おいしさ</td>\n<td>美味，好吃程度</td>\n<td>料理の美味しさ</td>\n</tr>\n<tr>\n<td>重要さ</td>\n<td>じゅうようさ</td>\n<td>重要性，重要程度</td>\n<td>環境保護の重要さ</td>\n</tr>\n<tr>\n<td>甘さ</td>\n<td>あまさ</td>\n<td>甜度</td>\n<td>スイカの甘さ</td>\n</tr>\n</tbody>\n</table></div>\n<h2 id=\"%E5%8B%95%E8%A9%9E%EF%BC%91\" tabindex=\"-1\">動詞１</h2>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>平仮名</th>\n<th>中国語</th>\n<th>原型/て/た/意志</th>\n<th>命令/假定/可能</th>\n<th>ない/被动<br />使役/使役被动</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>広がります</td>\n<td>ひろがります</td>\n<td>蔓延，拓宽</td>\n<td>広がる</td>\n<td>広がれ</td>\n<td>広がらない</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>事業が広がる</td>\n<td>広がって</td>\n<td>広がれば</td>\n<td>広がらせる</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>広がった</td>\n<td>広がれる</td>\n<td>広がらされる</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>広がろう</td>\n<td></td>\n<td>広がられる</td>\n</tr>\n<tr>\n<td>戻ります</td>\n<td>もどります</td>\n<td>返回，回到</td>\n<td>戻る</td>\n<td>戻れ</td>\n<td>戻らない</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>本題に戻る</td>\n<td>戻って</td>\n<td>戻れば</td>\n<td>戻らせる</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>会社に戻る</td>\n<td>戻った</td>\n<td>戻れる</td>\n<td>戻らされる</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>戻ろう</td>\n<td></td>\n<td>戻られる</td>\n</tr>\n<tr>\n<td>驚きます</td>\n<td>おどろきます</td>\n<td>惊讶，吃惊</td>\n<td>驚く</td>\n<td>驚け</td>\n<td>驚かない</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>彼の博学に驚いた、为他的博学而惊讶</td>\n<td>驚いて</td>\n<td>驚けば</td>\n<td>驚かれる</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>驚いた</td>\n<td>驚ける</td>\n<td>驚かせる</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>驚こう</td>\n<td></td>\n<td>驚かされる</td>\n</tr>\n</tbody>\n</table></div>\n<h2 id=\"%E5%8B%95%E8%A9%9E%EF%BC%92%EF%BC%86%EF%BC%93\" tabindex=\"-1\">動詞２＆３</h2>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>平仮名</th>\n<th>中国語</th>\n<th>原型/て/た/意志</th>\n<th>命令/假定/可能</th>\n<th>ない/被动<br />使役/使役被动</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>しゃれます</td>\n<td></td>\n<td>别致，风趣，打扮的漂亮</td>\n<td>しゃれる</td>\n<td>しゃれろ</td>\n<td>しゃれない</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>いつもしゃれています</td>\n<td>しゃれて</td>\n<td>しゃれれば</td>\n<td>しゃれられる</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>しゃれた</td>\n<td>しゃれれる</td>\n<td>しゃれさせる</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>しゃれよう</td>\n<td></td>\n<td>しゃれさせられる</td>\n</tr>\n</tbody>\n</table></div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>平仮名</th>\n<th>中国語</th>\n<th>原型/て/た/意志</th>\n<th>命令/假定/可能</th>\n<th>ない/被动/使役/使役被动</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>実感します</td>\n<td>じっかんします</td>\n<td>切实感受，真切感受</td>\n<td>実感する</td>\n<td>実感しろ</td>\n<td>実感しない</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>痛切に実感する，真切的感受到痛苦</td>\n<td>実感して</td>\n<td>実感すれば</td>\n<td>実感される</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>実感した</td>\n<td>実感できる</td>\n<td>実感させる</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>実感しよう</td>\n<td></td>\n<td>実感させられる</td>\n</tr>\n</tbody>\n</table></div>\n<h2 id=\"%E5%BD%A2%E5%AE%B9%E8%A9%9E%E3%80%81%E5%BD%A2%E5%AE%B9%E5%8B%95%E8%A9%9E%E3%80%81%E3%81%9D%E3%81%AE%E4%BB%96\" tabindex=\"-1\">形容詞、形容動詞、その他</h2>\n<div class=\"note\">\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>平仮名</th>\n<th>中国語</th>\n<th>肯定/否定</th>\n<th>过去肯定/过去否定</th>\n<th>て</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>深い</td>\n<td>ふかい</td>\n<td>深</td>\n<td>深い</td>\n<td>深かった</td>\n<td>深くて</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>関係が深い</td>\n<td>深くない</td>\n<td>深くなかった深くて</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>深くなります</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table></div>\n</div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>平仮名</th>\n<th>中国語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>深い</td>\n<td>ふかい</td>\n<td>深</td>\n<td>関係が深い</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>深い、深くない、深かった、深くなかった深くて</td>\n</tr>\n<tr>\n<td>恥ずかしい</td>\n<td>はずかしい</td>\n<td>害羞，难为情</td>\n<td></td>\n</tr>\n<tr>\n<td>珍しい</td>\n<td>めずらしい</td>\n<td>珍奇，新奇</td>\n<td>冬の西瓜は珍しい</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>豪華</td>\n<td>ごうか</td>\n<td>豪华，奢华</td>\n<td>豪華なホテル</td>\n</tr>\n<tr>\n<td>好調</td>\n<td>こうちょう</td>\n<td>顺利，情况良好</td>\n<td>好調な売れ行き、销路很好</td>\n</tr>\n<tr>\n<td>控えめ</td>\n<td>ひかえめ</td>\n<td>份量少，节制，控制，拘谨</td>\n<td>控えめな人、有节制的人</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>控えめにする、控えめにします</td>\n</tr>\n<tr>\n<td>好評</td>\n<td>こうひょう</td>\n<td>好评，称赞</td>\n<td><ruby>好評<rt>こうひょう</rt></ruby><ruby>発売<rt>はつばい</rt></ruby><ruby>中<rt>ちゅう</rt></ruby>, 好評をもらう/得る</td>\n</tr>\n<tr>\n<td>大事</td>\n<td>だいじ</td>\n<td>重要，宝贵</td>\n<td>お大事に</td>\n</tr>\n<tr>\n<td>かなり</td>\n<td></td>\n<td>颇，相当</td>\n<td>かなり遠いところ，相当远的地方</td>\n</tr>\n<tr>\n<td>けっこう</td>\n<td></td>\n<td>很，相当</td>\n<td>けっこうです，もうけっこうです</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>佐々木</td>\n<td>ささき</td>\n<td>佐佐木</td>\n<td></td>\n</tr>\n<tr>\n<td>琵琶湖</td>\n<td>びわこ</td>\n<td>琵琶湖</td>\n<td></td>\n</tr>\n<tr>\n<td>のぞみ</td>\n<td></td>\n<td>希望号</td>\n<td>望む，望みます，望み</td>\n</tr>\n<tr>\n<td>おかげさまで</td>\n<td></td>\n<td>托您的福</td>\n<td>おかげさまでげんきです</td>\n</tr>\n<tr>\n<td>何と言っても</td>\n<td>なんといっても</td>\n<td>不管怎么说</td>\n<td>なんといっても寿司を食べます</td>\n</tr>\n<tr>\n<td>～キロ・キログラム</td>\n<td></td>\n<td>公里/千克，公斤</td>\n<td></td>\n</tr>\n<tr>\n<td>センチ</td>\n<td></td>\n<td>公分，厘米</td>\n<td></td>\n</tr>\n</tbody>\n</table></div>\n<h1 id=\"%E6%96%87%E6%B3%95\" tabindex=\"-1\">文法</h1>\n<ol>\n<li>小句（简体形）ようです\n名＋の＋ようです</li>\n<li>小句（简体型）みたいです</li>\n<li>小句（简体型）らしい</li>\n</ol>\n<h2 id=\"%E5%B0%8F%E5%8F%A5%EF%BC%88%E7%AE%80%E4%BD%93%EF%BC%89%E3%82%88%E3%81%86%E3%81%A7%E3%81%99%EF%BC%8C%E5%90%8D%EF%BC%8B%E3%81%AE%EF%BC%8B%E3%82%88%E3%81%86%E3%81%A7%E3%81%99\" tabindex=\"-1\">小句（简体）ようです，名＋の＋ようです</h2>\n<div class=\"explain\">\n<p>表示根据说话人感知的某种情况进行推测，主观推测。</p>\n</div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>今日は雨が降るようです</td>\n<td>今天好像要下雨</td>\n</tr>\n<tr>\n<td>鈴木さんは元気がないようです</td>\n<td>铃木桑好像不太好</td>\n</tr>\n<tr>\n<td>あの人は先生のようです</td>\n<td>那个人好像是老师</td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"note\">\n<p>翻訳：电脑好像出故障了。</p>\n<p>パソコンは故障したようです</p>\n</div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>玄関のところにだれかいるようです</td>\n<td>门口似乎有人</td>\n</tr>\n<tr>\n<td>エンジンが故障したようです</td>\n<td>好像是发动机坏了</td>\n</tr>\n<tr>\n<td>店の前には行列ができています</td>\n<td>店前排起了队</td>\n</tr>\n<tr>\n<td>あの店の料理は美味しいようです</td>\n<td>看起来菜的味道不错</td>\n</tr>\n<tr>\n<td>値段はほかの店の倍です。ここの料理はかなり<strong>豪華な</strong>ようです</td>\n<td>ほかの店，其他的店</td>\n</tr>\n<tr>\n<td></td>\n<td>かなり，相当的</td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"note\">\n<p>动词/形容词（简体）+ようです</p>\n<p>形容動詞＋な＋ようです</p>\n<p>名詞＋の＋ようです</p>\n</div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>遠くから何か飛んで<strong>きます</strong></td>\n<td>遠く，遠いの名词．<br />飛んできます，てくる．</td>\n</tr>\n<tr>\n<td>飛行機のようです</td>\n<td></td>\n</tr>\n<tr>\n<td>そのようです</td>\n<td></td>\n</tr>\n</tbody>\n</table></div>\n<h2 id=\"%E5%B0%8F%E5%8F%A5%EF%BC%88%E7%AE%80%E4%BD%93%E5%9E%8B%EF%BC%89%E3%81%BF%E3%81%9F%E3%81%84%E3%81%A7%E3%81%99\" tabindex=\"-1\">小句（简体型）みたいです</h2>\n<div class=\"explain\">\n<p>表示主观推测。</p>\n<p>動詞・形容詞（简体）+みたいです</p>\n<p>形容動詞・名詞＋みたいです</p>\n<p>和之前的栗子几乎没有区别，口语里面みたい用的比较多。</p>\n</div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>また台風がくるみたいです</td>\n<td>好像台风又要来了</td>\n</tr>\n<tr>\n<td>あの店は美味しいみたいです</td>\n<td></td>\n</tr>\n<tr>\n<td>この教室は静かみたいです</td>\n<td>この教室は静かなようです</td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"note\">\n<p>翻译：丹尼尔好像不在教室</p>\n<p>ダニエルさんは教室にいないみたいです</p>\n<p>ある，あらない</p>\n</div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>小野さんは森さんをよく見ていますね</td>\n<td>小野女士老是看森先生</td>\n</tr>\n<tr>\n<td>小野さんは森さんが好きみたいです</td>\n<td>她好像喜欢森先生</td>\n</tr>\n<tr>\n<td>雨の音が聞こえません</td>\n<td></td>\n</tr>\n<tr>\n<td>雨が止んだみたいです</td>\n<td>好像雨停了</td>\n</tr>\n<tr>\n<td>外の人はみんなコートを着ています</td>\n<td>行人都穿着大衣</td>\n</tr>\n<tr>\n<td>外は寒いみたいです</td>\n<td></td>\n</tr>\n<tr>\n<td>雲が広がっています</td>\n<td></td>\n</tr>\n<tr>\n<td>明日は雨みたいです，雨のようです</td>\n<td>昼がる：蔓延，拓宽</td>\n</tr>\n</tbody>\n</table></div>\n<h2 id=\"%E5%B0%8F%E5%8F%A5%EF%BC%88%E7%AE%80%E4%BD%93%EF%BC%89%E3%82%89%E3%81%97%E3%81%84%E3%81%A7%E3%81%99\" tabindex=\"-1\">小句（简体）らしいです</h2>\n<div class=\"explain\">\n<p>客观推测，传闻，表示根据观察到的情况进行推测或婉转的叙述听来的消息</p>\n</div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>今度の社員旅行は韓国へ行くらしいです</td>\n<td>下次的全社旅行好像是去韩国</td>\n</tr>\n<tr>\n<td></td>\n<td>行くらしいです</td>\n</tr>\n<tr>\n<td>李さんは頭が痛いいらしいです</td>\n<td>小李好像头痛</td>\n</tr>\n<tr>\n<td>林さんはお酒が好きらしいですよ</td>\n<td></td>\n</tr>\n<tr>\n<td>電気が消えています，李さんは出かけたらしいです</td>\n<td></td>\n</tr>\n<tr>\n<td>パトカーのサイレンが聞こえます．近所で事故があったらしいです</td>\n<td>听到警车声，附近好像出什么事了</td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"explain\">\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>王さんは今日来ないみたいです・ようです</td>\n<td>今天好像不来了</td>\n</tr>\n<tr>\n<td>王さんは今日来ないらしいです</td>\n<td>（从哪里听闻的消息，比较有把握）</td>\n</tr>\n</tbody>\n</table></div>\n</div>\n<h2 id=\"%E5%8A%A8%E8%AF%8D%2F%E4%B8%80%E7%B1%BB%E5%BD%A2%2F%E4%BA%8C%E7%B1%BB%E5%BD%A2%2B%E9%81%8E%E3%81%99%E3%81%8E%E3%81%BE%E3%81%99\" tabindex=\"-1\">动词/一类形/二类形+<ruby>過<rt>す</rt></ruby>ぎます</h2>\n<div class=\"explain\">\n<p>表示过于，太～</p>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th><ruby>種類<rt>しゅるい</rt></ruby></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>形容詞</td>\n<td>暑い</td>\n<td>暑過ぎます</td>\n</tr>\n<tr>\n<td>形容動詞</td>\n<td>静かだ</td>\n<td>静か過ぎます</td>\n</tr>\n<tr>\n<td>動詞</td>\n<td>食べます</td>\n<td>食べ過ぎます</td>\n</tr>\n<tr>\n<td></td>\n<td>働きます</td>\n<td>働き過ぎます</td>\n</tr>\n</tbody>\n</table></div>\n<p><spoiler>くりこさんは可愛過ぎます！</spoiler></p>\n</div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>日本の物価は高過ぎます</td>\n<td>日本的物价太高了。</td>\n</tr>\n<tr>\n<td>この辺は静か過ぎます</td>\n<td>这块儿太安静乐</td>\n</tr>\n<tr>\n<td>日本人は働き過ぎます</td>\n<td></td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"note\">\n<p>翻译：说的太过了</p>\n<p>言い過ぎますね！<spoiler>(撒娇)</spoiler></p>\n</div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>昼ご飯を食べ過ぎました</td>\n<td>午饭吃多了</td>\n</tr>\n<tr>\n<td>このスープは熱すぎませんか</td>\n<td></td>\n</tr>\n<tr>\n<td>この説明は複雑過ぎます</td>\n<td>这说明太复杂了</td>\n</tr>\n</tbody>\n</table></div>\n<h2 id=\"%E4%B8%80%E7%B1%BB%E5%BD%A2%E5%AE%B9%E8%AF%8D%2B%E3%81%95\" tabindex=\"-1\">一类形容词+さ</h2>\n<div class=\"explain\">\n<p>表示某种状态的名词</p>\n<p>变形：い／だ　→　み／さ</p>\n<p>さ：表示程度或具体的内容</p>\n<p>み：多用于表示抽象的内容</p>\n<p>深い，深さ，深み</p>\n<p>海の深さは５００メートルです，海深500米，可测量，很具体</p>\n<p>この文章は深みがあります，这个文章很有深度，很抽象，很深度。</p>\n</div>\n<div class=\"alert\">\n<p>特殊：いい　→　よさ</p>\n</div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>この暑さはいつまで続くんでしょう</td>\n<td>这种炎热要持续到什么时候呀</td>\n</tr>\n<tr>\n<td>富士山の美しさが心に残っています</td>\n<td></td>\n</tr>\n<tr>\n<td>仕事の面白さがやっと分かりました</td>\n<td>终于体会到工作的趣味了。</td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"warning\">\n<p>形容动词理论上也可以，但是用的很少。</p>\n<p>便利さ，複雑さ，<strong>可以视作固定用法</strong></p>\n<p>错误用法：<s>きれいさ，暇さ</s></p>\n</div>\n<h1 id=\"%E5%9F%BA%E6%9C%AC%E8%AF%BE%E6%96%87\" tabindex=\"-1\">基本课文</h1>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th></th>\n<th>日本語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>あ</td>\n<td>葉子さんは留学試験に合格したようですよ</td>\n<td></td>\n</tr>\n<tr>\n<td>い</td>\n<td>それはよかったですね</td>\n<td></td>\n</tr>\n<tr>\n<td>あ</td>\n<td>毎日暑いですね、この暑さはいつまで続くんでしょう</td>\n<td></td>\n</tr>\n<tr>\n<td>い</td>\n<td>天気予報によると、まだまだ続くみたいですよ</td>\n<td>据天气预报说，好像要持续相当一段时间</td>\n</tr>\n<tr>\n<td>あ</td>\n<td>新しい遊園地は、とても人気があるみたいですね</td>\n<td></td>\n</tr>\n<tr>\n<td>い</td>\n<td>ええ、馬さんたちも来週行くらしいです</td>\n<td></td>\n</tr>\n<tr>\n<td>あ</td>\n<td>昨夜行ったビアガーデンはなかなかよかったですね</td>\n<td>昨天晚上去的那家庭院式啤酒店真不错</td>\n</tr>\n<tr>\n<td>い</td>\n<td>ええ、でも、ちょっと飲みすぎました</td>\n<td></td>\n</tr>\n</tbody>\n</table></div>\n<h1 id=\"%E5%BA%94%E7%94%A8%E8%AF%BE%E6%96%87---%E5%A3%B2%E3%82%8C%E8%A1%8C%E3%81%8D\" tabindex=\"-1\">应用课文 - 売れ行き</h1>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th></th>\n<th>日本語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>馬</td>\n<td>森さん、「ドンリー」、売れ行きが好調のようですね</td>\n<td>森，「动力」好像很畅销啊。</td>\n</tr>\n<tr>\n<td>森</td>\n<td>ええ、おかげさまで。とりあえず、北京と上海で売れ出したんですが</td>\n<td>是啊，托大家的福。首先在北京和上海上市</td>\n</tr>\n<tr>\n<td></td>\n<td>結構評判がいいみたいなんですよ</td>\n<td>评价好像很不错。</td>\n</tr>\n<tr>\n<td>馬</td>\n<td>どの辺が受けたんでしょうか</td>\n<td>哪方面得到了认可</td>\n</tr>\n<tr>\n<td>森</td>\n<td>何といても美味しさです、容器のデザインも好評らしいです</td>\n<td></td>\n</tr>\n<tr>\n<td>だい</td>\n<td>デザインがしゃれていて、人気があるみたいですね</td>\n<td>设计很别致，似乎很有人气</td>\n</tr>\n<tr>\n<td>り</td>\n<td>そうなんです、それに、ネーミングも受けたようです</td>\n<td></td>\n</tr>\n<tr>\n<td>だい</td>\n<td>よかったですね</td>\n<td></td>\n</tr>\n<tr>\n<td>り</td>\n<td>ええ、ネーミングとデザインの重要さを実感しましたね</td>\n<td>是啊，我们切实感受到了名称和设计的重要性了。</td>\n</tr>\n<tr>\n<td>森</td>\n<td>評判がいいので、今度は、中国全土で売り出すようで</td>\n<td></td>\n</tr>\n<tr>\n<td>だい</td>\n<td>売れ行きがどうなるか、楽しみですね</td>\n<td>销量会变成什么样呢？乐观期待呢</td>\n</tr>\n<tr>\n<td>馬</td>\n<td>売れすぎて、笑いが  止まらなく  なる  かもしれませんよ</td>\n<td>也许畅销到大家会笑得合不拢嘴呢。</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>变得停不下来</td>\n</tr>\n<tr>\n<td>森</td>\n<td>そうだといんですが</td>\n<td>真能那样就好了</td>\n</tr>\n<tr>\n<td>り</td>\n<td>CSコンすでは、もう次の商品の開発を始めているらしいですよ</td>\n<td></td>\n</tr>\n<tr>\n<td>ば</td>\n<td>すごいパワーですね</td>\n<td></td>\n</tr>\n<tr>\n<td>だい</td>\n<td>甘さが控えめで、確かに美味しいですね</td>\n<td>甜度适中，的确很好喝。</td>\n</tr>\n<tr>\n<td>り</td>\n<td>それに、健康にもいいらしいですよ</td>\n<td>另外，看来对身体也有好处呢。</td>\n</tr>\n</tbody>\n</table></div>\n<hr />\n<blockquote>\n<p>大変に気分がいい</p>\n</blockquote>\n","slug":"学习笔记/日本語/n4n5/lesson44","published":true,"date":"2022-03-17T16:00:00.000Z","updated":"2022-04-01T16:00:00.000Z","path":"学习笔记/日本語/n4n5/lesson44/","api_path":"api/articles/学习笔记/日本語/n4n5/lesson44.json","keywords":null,"tags":[{"name":"学习笔记","path":"api/tags/学习笔记.json"},{"name":"日本語","path":"api/tags/日本語.json"}]},{"title":"くりこの強化学習ノート","author":"Kuriko Moe (栗子Chan)","excerpt":"<p>这里记载了くりこ的强化学习笔记（真的是复习笔记）</p>\n","render_content":"<p>这里记载了くりこ的强化学习笔记（真的是复习笔记）</p>\n<!-- more -->\n<h1 id=\"key-concepts\" tabindex=\"-1\">Key Concepts</h1>\n<blockquote>\n<p>参考：<a href=\"https://spinningup.openai.com/en/latest/spinningup/rl_intro.html\" target=\"_blank\" rel=\"noopener\">https://spinningup.openai.com/en/latest/spinningup/rl_intro.html</a></p>\n</blockquote>\n<ol>\n<li>\n<p>states and observation: 通常记作 state: \\(s\\),  observation: \\(o\\)</p>\n</li>\n<li>\n<p>action space</p>\n</li>\n<li>\n<p>policies\n确定性策略：\\(a_t = \\mu (s_t)\\)\n随机策略：\\(a_t \\sim \\pi(\\cdot | s_t)\\)\n当策略依赖于参数时，记作：\\(a_t = \\mu_\\theta(s_t), a_t \\sim \\pi_\\theta(\\cdot | s_t)\\)</p>\n</li>\n<li>\n<p>确定性(deterministic)策略：某个状态 \\(s\\) 的策略应当是固定的，其概率应该始终为1，不会发生改变</p>\n</li>\n<li>\n<p>随机(stochastic)策略：从状态集 \\(S\\) 到动作集 \\(A\\) 的条件概率分布，即 \\(\\pi_S(A|S)\\) 动作是从分布中 sample 得到的</p>\n<blockquote>\n<p>参考：<a href=\"https://zhuanlan.zhihu.com/p/136020868\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/136020868</a></p>\n</blockquote>\n<p>随机策略里面两个比较重要的计算：</p>\n<ol>\n<li>sampling actions from the policy</li>\n<li>and computing log likelihoods of particualr actions: \\(log\\pi_\\theta(a|s)\\)</li>\n</ol>\n</li>\n<li>\n<p>Trajectories: a sequence of states and actions in the world, noted as \\(\\tau\\), \\(\\tau = (s_0, a_0, s_1, a_1, \\dots)\\)</p>\n<p>初始状态一般是从 start-state distribution 中采样得到： \\(s_0 \\sim p_0(\\cdot)\\)</p>\n<p>状态转移(State transitions): \\(s_{t+1} = f(s_t, a_t)\\) 或者 \\(s_{t+1} \\sim P(\\cdot | s_t, a_t)\\)</p>\n<blockquote>\n<p>Trajectories are also frequently called episodes or rollouts</p>\n</blockquote>\n</li>\n<li>\n<p>Reward and Return \\(r_t = R(s_t, a_t, s_{t+1})\\)\n引入折扣因子(discount factor) \\(\\gamma \\in (0, 1)\\), \\(R(\\tau) = \\sum_{t=0}^{\\infty}{\\gamma^t r_t}\\)。</p>\n</li>\n</ol>\n<h2 id=\"rl-problem\" tabindex=\"-1\">RL Problem</h2>\n<blockquote>\n<p>the goal in RL is to select</p>\n<p>a policy which maximizes expected return when the agent acts according to it.l</p>\n</blockquote>\n<p>在随机策略下，一个 \\(\\tau\\)-steps 的 trajectory 的概率是</p>\n<p>\\[\n\\begin{align*}\nP(\\tau | \\pi) &amp;= \\rho_0(s_0) \\Pi_{t=0}^{T-1} P(s_{t+1} | s_t, a_t) \\pi(a_t | s_t) \\\\\\\\\nJ(\\pi) &amp;= \\int_\\tau P(\\tau | \\pi) R(\\tau) = E_{\\tau \\sim \\pi} [R(\\tau) \\\\\\\\\n\\pi^* &amp;=  \\arg \\max_\\pi J(\\pi)\n\\end{align*}\n\\]</p>\n<h3 id=\"value-functions%EF%BC%88%E5%80%BC%E5%87%BD%E6%95%B0%EF%BC%89\" tabindex=\"-1\">Value Functions（值函数）</h3>\n<h3 id=\"bellman-equation\" tabindex=\"-1\">Bellman Equation</h3>\n<blockquote>\n<p>The value of your starting point is the reward you expect to get from being there, plus the value of wherever you land next.</p>\n</blockquote>\n","slug":"学习笔记/科研/rl","published":true,"date":"2021-03-02T03:18:52.000Z","updated":"2021-03-02T07:51:53.000Z","path":"学习笔记/科研/rl/","api_path":"api/articles/学习笔记/科研/rl.json","keywords":null,"tags":[{"name":"学习笔记","path":"api/tags/学习笔记.json"},{"name":"深度学习","path":"api/tags/深度学习.json"}]},{"title":"唐盾：0-N4日语精讲","subtitle":"第二十七課：子供の時、大きな地震がありました","author":"Kuriko Moe (栗子Chan)","excerpt":"<p>第二十七课：小时候，发生过大地震</p>\n<p><strong>内容</strong> ：〜時｜〜ながら｜〜でさい/动作伴随</p>\n<p><strong>教程地址</strong>：<a href=\"https://www.bilibili.com/cheese/play/ep1056\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/cheese/play/ep1056</a></p>\n","render_content":"<p>第二十七课：小时候，发生过大地震</p>\n<p><strong>内容</strong> ：〜時｜〜ながら｜〜でさい/动作伴随</p>\n<p><strong>教程地址</strong>：<a href=\"https://www.bilibili.com/cheese/play/ep1056\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/cheese/play/ep1056</a></p>\n<!-- more -->\n<h1 id=\"%E5%8D%98%E8%AA%9E\" tabindex=\"-1\">単語</h1>\n<h2 id=\"%E5%90%8D%E8%A9%9E\" tabindex=\"-1\">名詞</h2>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>平仮名</th>\n<th>中国語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>経済</td>\n<td>けいざい</td>\n<td>经济</td>\n<td>経済学（けいざいがく）</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>あたしの専門は経済学です</td>\n</tr>\n<tr>\n<td>国際関係学</td>\n<td>こくさいかんけいがく</td>\n<td>国际关系学</td>\n<td>国際（こくさい）関係（かんけい）</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td><ruby>人間<rt>にんげん</rt>関係<rt>かんけい</rt></ruby></td>\n</tr>\n<tr>\n<td>大勢</td>\n<td>おおぜい</td>\n<td>许多，众多</td>\n<td>おおぜいの人</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>大勢：只用于指人多<br />たくさん：不限定形容对象（人/事/物）</td>\n</tr>\n<tr>\n<td>高校</td>\n<td>こうこう</td>\n<td>高中</td>\n<td>高校生せい<br />中学校（ちゅうがっこう）</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>小学校：しょうがっこう</td>\n<td><ruby>私立<rt>しりつ</rt>常盤台<rt>ときわだい</rt>中学校</ruby><br /><img src=\"https://kurikomoe-1300672427.image.myqcloud.com/images/%E5%B8%B8%E7%9B%A4%E5%8F%B0%E4%B8%AD%E5%AD%A6%E6%A0%A1.png\" alt=\"常盤台中学校\" /></td>\n</tr>\n<tr>\n<td>日記</td>\n<td>にっき</td>\n<td>日记</td>\n<td>日記を書く：动作<br />にっきをつける：习惯</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>日記をつけている</td>\n</tr>\n<tr>\n<td>教師</td>\n<td>きょうし</td>\n<td>教师</td>\n<td>日本語教師、先生</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>职业叫教師。称呼用先生</td>\n</tr>\n<tr>\n<td>お年寄り</td>\n<td>おとしより</td>\n<td>老年人</td>\n<td>老人：ろうじん</td>\n</tr>\n<tr>\n<td>ラジオ体操</td>\n<td>ラジオたいそう</td>\n<td>广播体操</td>\n<td>radio：ラジオ</td>\n</tr>\n<tr>\n<td>社交ダンス</td>\n<td>社交舞</td>\n<td>交际舞</td>\n<td></td>\n</tr>\n<tr>\n<td>卓球</td>\n<td>たっきゅう</td>\n<td>乒乓球</td>\n<td>ピンポン：乒乓球。ピンポンが得意</td>\n</tr>\n<tr>\n<td>バスケットボール</td>\n<td></td>\n<td>篮球</td>\n<td>一般省略为バスケット</td>\n</tr>\n<tr>\n<td>スポーツセンター</td>\n<td></td>\n<td>体育中心</td>\n<td></td>\n</tr>\n<tr>\n<td>入園料</td>\n<td>にゅうえんりょう</td>\n<td>入园费，门票</td>\n<td></td>\n</tr>\n<tr>\n<td>有料</td>\n<td>ゆうりょう</td>\n<td>收费</td>\n<td>無料：むりょう。但是实际场合服务员一般用：サービス</td>\n</tr>\n<tr>\n<td>賞</td>\n<td>しょう</td>\n<td>奖</td>\n<td>優等賞：ゆうとうしょう<br />残念賞：ざんねんしょう（安慰奖）</td>\n</tr>\n<tr>\n<td>曲</td>\n<td>きょく</td>\n<td>乐曲，歌曲</td>\n<td>曲を作ります<br />曲を作るのがすきです</td>\n</tr>\n<tr>\n<td>詩</td>\n<td>し</td>\n<td>诗歌</td>\n<td>詩を読む、詩を作る</td>\n</tr>\n<tr>\n<td>信号</td>\n<td>しんごう</td>\n<td>信号，红绿灯</td>\n<td></td>\n</tr>\n<tr>\n<td>はさみ</td>\n<td></td>\n<td>剪刀</td>\n<td></td>\n</tr>\n<tr>\n<td>部品</td>\n<td>ぶひん</td>\n<td>零部件</td>\n<td>部品工場（こうじょう）</td>\n</tr>\n<tr>\n<td>アルバイト</td>\n<td></td>\n<td>打工，副业，工读</td>\n<td></td>\n</tr>\n<tr>\n<td>スピーチ</td>\n<td></td>\n<td>演讲</td>\n<td>スピーチコンテスト</td>\n</tr>\n<tr>\n<td>グラフ</td>\n<td></td>\n<td>图表</td>\n<td></td>\n</tr>\n<tr>\n<td>企画</td>\n<td>きかく</td>\n<td>策划，企划</td>\n<td>企画を立てる（制定企划）</td>\n</tr>\n<tr>\n<td>説明</td>\n<td>せつめ</td>\n<td>说明</td>\n<td>〜を説明する</td>\n</tr>\n<tr>\n<td>ご飯</td>\n<td>ごはん</td>\n<td>饭</td>\n<td>朝ご飯</td>\n</tr>\n<tr>\n<td>砂糖</td>\n<td>さとう</td>\n<td>砂糖</td>\n<td>和 佐藤 重音不同。</td>\n</tr>\n<tr>\n<td>海外旅行</td>\n<td>かいがいりょこう</td>\n<td>出国旅行</td>\n<td></td>\n</tr>\n<tr>\n<td>こと</td>\n<td></td>\n<td>事情</td>\n<td>自分のこと自分でする。自己的事情自己做</td>\n</tr>\n<tr>\n<td>おじいさん</td>\n<td></td>\n<td>爷爷，老大爷</td>\n<td>おじさん：叔叔</td>\n</tr>\n<tr>\n<td>おばあさん</td>\n<td></td>\n<td>奶奶，老奶奶</td>\n<td>おばさん：阿姨</td>\n</tr>\n<tr>\n<td>姉</td>\n<td>あね</td>\n<td>姐姐</td>\n<td>あたしのあね（介绍用语）<br />お姉さん（称呼用语）<br />お姉ちゃん</td>\n</tr>\n</tbody>\n</table></div>\n<h2 id=\"%E5%8B%95%E8%A9%9E\" tabindex=\"-1\">動詞</h2>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>平仮名</th>\n<th>中国語</th>\n<th>原型</th>\n<th>て</th>\n<th>ない</th>\n<th>た</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>通います</td>\n<td>かよいます</td>\n<td>上学，来往</td>\n<td>通う</td>\n<td>通って</td>\n<td>通わない</td>\n<td>通った</td>\n</tr>\n<tr>\n<td></td>\n<td>会社に通います</td>\n<td>学校に通います</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>集まります</td>\n<td>あつまります</td>\n<td>聚，集和</td>\n<td>集まる</td>\n<td>集まって</td>\n<td>集まらない</td>\n<td>集まった</td>\n</tr>\n<tr>\n<td>踊ります</td>\n<td>おどり　ます</td>\n<td>跳舞</td>\n<td>踊る</td>\n<td>踊って</td>\n<td>踊らない</td>\n<td>踊った</td>\n</tr>\n<tr>\n<td></td>\n<td>ダンス</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>要ります</td>\n<td>いります</td>\n<td>要</td>\n<td>要る</td>\n<td>要って</td>\n<td>要らない</td>\n<td>要った</td>\n</tr>\n<tr>\n<td></td>\n<td>お金が要る！</td>\n<td>時間が要る</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>困ります</td>\n<td>こまります</td>\n<td>为难，难办</td>\n<td>困る</td>\n<td>困って</td>\n<td>困らない</td>\n<td>困った</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>困っています</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>叩きます</td>\n<td>たたきます</td>\n<td>拍，敲，打</td>\n<td>叩く</td>\n<td>叩いて</td>\n<td>叩かない</td>\n<td>叩いた</td>\n</tr>\n<tr>\n<td></td>\n<td>ドアを叩く</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table></div>\n<h2 id=\"%E5%BD%A2%E5%AE%B9%E5%8B%95%E8%A9%9E\" tabindex=\"-1\">形容動詞</h2>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>平仮名</th>\n<th>中国語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>入れます</td>\n<td>いれます</td>\n<td>放入，放进</td>\n<td>入る、入れて、入れた、入れない</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>コーヒーに砂糖を入れる</td>\n</tr>\n<tr>\n<td>看病します</td>\n<td>かんびょうします</td>\n<td>护理</td>\n<td></td>\n</tr>\n<tr>\n<td>喧嘩します</td>\n<td>けんかします</td>\n<td>吵架，打架</td>\n<td></td>\n</tr>\n<tr>\n<td>利用します</td>\n<td>りようします</td>\n<td>利用</td>\n<td>図書館を利用します<br />公園を利用します<br />一般表达利用公共设施</td>\n</tr>\n<tr>\n<td>相談します</td>\n<td>そうだんします</td>\n<td>商谈</td>\n<td>友達と相談します<br />家族と相談します</td>\n</tr>\n</tbody>\n</table></div>\n<h2 id=\"%E5%BD%A2%E5%AE%B9%E8%A9%9E\" tabindex=\"-1\">形容詞</h2>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>平仮名</th>\n<th>中国語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ほかに</td>\n<td></td>\n<td>另外</td>\n<td>除了~之外，名詞＋のほかに。<br />日本のほかに（除了日本之外）<br />除此之外（このほかに）<br />ほかにありますか（还有其他的么？）</td>\n</tr>\n<tr>\n<td>しばらく</td>\n<td></td>\n<td>许久，好久，片刻</td>\n<td>久しぶりですね（好久不见）</td>\n</tr>\n<tr>\n<td>この前</td>\n<td>このまえ</td>\n<td>前几天，之前，最近</td>\n<td></td>\n</tr>\n<tr>\n<td>そう言えば</td>\n<td>そういえば</td>\n<td>说起来，这么说来</td>\n<td>言えば：言える的假定型。。（之后会讲）</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>そうすれば：如果那么做～的话</td>\n</tr>\n<tr>\n<td>気がつきます</td>\n<td>きがつきます</td>\n<td>察觉</td>\n<td>原型：つく<br />ます：気がつきます<br />気づいた（口语中），気づいたの</td>\n</tr>\n<tr>\n<td>〜行き\\〜びん</td>\n<td></td>\n<td></td>\n<td>東京行きの：开往东京的<br />大阪行きの飛行機</td>\n</tr>\n</tbody>\n</table></div>\n<h1 id=\"%E6%96%87%E6%B3%95\" tabindex=\"-1\">文法</h1>\n<h2 id=\"%E5%8A%A8%E8%AF%8D%E5%B0%8F%E5%8F%A5%EF%BC%88%E7%AE%80%E4%BD%93%EF%BC%89%2B%E6%99%82%EF%BC%9A%E3%80%9C%E6%97%B6\" tabindex=\"-1\">动词小句（简体）+時：〜时</h2>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th><ruby>類別<rt>るいべつ</rt></ruby></th>\n<th>日本語</th>\n<th>平仮名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>名詞</td>\n<td>授業の時</td>\n<td>じゅぎょうのとき</td>\n</tr>\n<tr>\n<td>形容詞</td>\n<td>忙しい時</td>\n<td>いそがしいとき</td>\n</tr>\n<tr>\n<td>形容動詞</td>\n<td>暇な時</td>\n<td>ひまなとき</td>\n</tr>\n<tr>\n<td>動詞</td>\n<td>旅行する時</td>\n<td>りょこうするとき</td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"explain\">\n<p>名词＋の＋時</p>\n<p>形容词：形容词简体+時</p>\n<p>形容動詞＋な＋時</p>\n<p>動詞＋時、（原型，た型，ない型都可以）</p>\n</div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th></th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>食事の時日本人は箸を使います</td>\n<td>小句是名词时：名词+の+時</td>\n</tr>\n<tr>\n<td>天気がいい時公園を散歩します</td>\n<td>小句是形容词时：一类形容词 简体+時</td>\n</tr>\n<tr>\n<td>暇な時コーヒーを飲みに行きます</td>\n<td>小句是形容动词时：二类形容词+な+時</td>\n</tr>\n<tr>\n<td>日本に旅行した時写真をとりました</td>\n<td>小句是动词时：动词基本型/した型+時</td>\n</tr>\n</tbody>\n</table></div>\n<h3 id=\"translation\" tabindex=\"-1\">Translation</h3>\n<p>父亲看报时戴眼镜</p>\n<p>父は新聞を読む時、眼鏡をかけます</p>\n<div class=\"note\">\n<p>这个不是简单的 xxxx時，可以理解为时间状语从句的日语版：xxx時、xxx</p>\n</div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>子供の時、大きな地震がありました</td>\n<td>小时候，发生过大地震</td>\n</tr>\n<tr>\n<td>日本に<strong>行く</strong>時、たくさんお土産を<strong>買いました</strong></td>\n<td>去日本的<strong>之前</strong>买了不少特产<br />还没去，买是过去时</td>\n</tr>\n<tr>\n<td>日本に<strong>行った</strong>時、たくさんお土産を<strong>買いました</strong></td>\n<td>去日本之后，买了不少礼物</td>\n</tr>\n<tr>\n<td>忙しい時、家族みんなで仕事をします</td>\n<td>忙时，全家一起干活。</td>\n</tr>\n<tr>\n<td>暇な時、あたしは街で買い物をします</td>\n<td>有空时我上街买东西</td>\n</tr>\n<tr>\n<td>この前、友達が病気の時に、あたしが看病しました</td>\n<td>前些天朋友生病是我护理了她。</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>这里的に特指上一次，而不是每一次生病</strong></td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"alert\">\n<p><s>友達が病気の時に、いつもあたしがかんびょうしました</s></p>\n<p>这句前后矛盾，一个是特指某次，一个是いつも总是</p>\n</div>\n<h2 id=\"%E5%8A%A8%E8%AF%8D%E8%BF%9E%E7%94%A8%E5%BD%A2%2B%E3%81%AA%E3%81%8C%E3%82%89\" tabindex=\"-1\">动词连用形+ながら</h2>\n<p>表示同一个主体同时进行两个动作，后面的动作是主要动作。</p>\n<p>一边。。。一边。。。</p>\n<p>書きます -&gt; 書き</p>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>nihongo</th>\n<th>cyuusyaku</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ぎたーを弾きながら、歌っています</td>\n<td>边弹吉他边唱歌</td>\n</tr>\n<tr>\n<td>音楽を聞きながら、小説を読んでいます</td>\n<td>边听音乐边看小说</td>\n</tr>\n</tbody>\n</table></div>\n<h3 id=\"%E7%BF%BB%E8%AF%91%EF%BC%9A%E8%BE%B9%E8%B5%B0%E8%BE%B9%E8%81%8A\" tabindex=\"-1\">翻译：边走边聊</h3>\n<p>歩きながら、話しています</p>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>李さんはテレビを見ながら、食事をしています</td>\n<td>小李一边看电视一边吃饭</td>\n</tr>\n<tr>\n<td>そのことを考えながら、歩いていました</td>\n<td>在考虑着事，一边走着</td>\n</tr>\n</tbody>\n</table></div>\n<h2 id=\"%E5%B0%8F%E5%8F%A5%EF%BC%88%E7%AE%80%E4%BD%93%EF%BC%89%E3%81%A7%E3%81%97%E3%82%87%E3%81%86\" tabindex=\"-1\">小句（简体）でしょう</h2>\n<p>表示征求同意，读升调</p>\n<ol>\n<li>名词＋でしょう</li>\n<li>形容詞＋でしょう</li>\n<li></li>\n</ol>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>にほんご</th>\n<th>ちゅうしゃく</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>李さんは、明日パーティーに行くでしょう</td>\n<td></td>\n</tr>\n<tr>\n<td>李さんは優しくて、親切でしょう</td>\n<td></td>\n</tr>\n<tr>\n<td>このお菓子まずいね</td>\n<td>ーえっ！まずい、おいしいでしょう</td>\n</tr>\n<tr>\n<td>お母さん、あたしの日記、見たでしょう。</td>\n<td></td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"note\">\n<p>形容詞関連情報：<a href=\"https://mrraybox.blogspot.com/2016/03/blog-post_11.html\" target=\"_blank\" rel=\"noopener\">https://mrraybox.blogspot.com/2016/03/blog-post_11.html</a></p>\n</div>\n<h2 id=\"%E5%8B%95%E8%A9%9E%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99\" tabindex=\"-1\">動詞ています</h2>\n<p>除了可以表示动作正在进行和动作的结果、状态还可以表示反复或习惯性的动作。</p>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>nihongo</th>\n<th>cyuusyaku</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ようこさんはアルバイトをしながら学校に通っています</td>\n<td>叶子边打工边上学「反复」</td>\n</tr>\n<tr>\n<td>北京行きの飛行機は一時間<strong>に</strong>一便飛んでいます</td>\n<td>往北京的飞机每小时飞一次「反复」</td>\n</tr>\n<tr>\n<td>あたしは毎日散歩します</td>\n<td>咱每天散步「习惯」</td>\n</tr>\n</tbody>\n</table></div>\n<p>表示时间起点时使用「〜でいます」</p>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>にほんご</th>\n<th>ちゅうしゃく</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>あたしは先月から毎朝太極拳をしています</td>\n<td>我从上个月起每早打太极拳</td>\n</tr>\n<tr>\n<td></td>\n<td>这里因为有动作发生的开始时间，所以必须用　います</td>\n</tr>\n<tr>\n<td></td>\n<td>〜ます表示从现在开始到将来</td>\n</tr>\n<tr>\n<td>あたしはこうこうの教師をしています</td>\n<td>我在做高中教师</td>\n</tr>\n</tbody>\n</table></div>\n<h2 id=\"%E5%90%8D%E8%AF%8D%2B%E3%81%A7\" tabindex=\"-1\">名词+で</h2>\n<p>助词で加在名词后面还可以表示原因、理由</p>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>nihongo</th>\n<th>cyuusyaku</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>仕事で、洋さんと会っていたんですよ</td>\n<td></td>\n</tr>\n<tr>\n<td>田中さんは佐藤さんと結婚しました</td>\n<td></td>\n</tr>\n<tr>\n<td>田中さんと佐藤さんとが結婚しました</td>\n<td></td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"note\">\n<p>する：　做\nした：　做了，過去式\nしている：　正在做，現在進行式\nしていた：　過去做了，過去進行式，偏重狀態的說明\nしていない（してない）：　現在沒在做\nしていなかった：　過去沒在做\nしたことがある：　過去曾經做過，偏重事實的說明</p>\n</div>\n<h1 id=\"%E5%9F%BA%E6%9C%AC%E8%AF%BE%E6%96%87\" tabindex=\"-1\">基本课文</h1>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th></th>\n<th>日本語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>あ</td>\n<td>学生の時、何を勉強しました</td>\n<td>学生时代你学到了什么？</td>\n</tr>\n<tr>\n<td>い</td>\n<td>日本の経済について勉強しました</td>\n<td>について：有关。旅行について</td>\n</tr>\n<tr>\n<td>あ</td>\n<td>馬さん、暇な時、この書類を整理してください</td>\n<td></td>\n</tr>\n<tr>\n<td>い</td>\n<td>はい、わかりました</td>\n<td></td>\n</tr>\n<tr>\n<td>あ</td>\n<td>陽子さんはアルバイトをしながら学校に通っているんですよ</td>\n<td>动词原型+んです</td>\n</tr>\n<tr>\n<td>い</td>\n<td>そうですか、なかなかたいへんですね</td>\n<td></td>\n</tr>\n<tr>\n<td>あ</td>\n<td>森さん、昨日、駅前の喫茶店にいたでしょう</td>\n<td>いるー＞いた。いたでしょう、动词原型+でしょう</td>\n</tr>\n<tr>\n<td>い</td>\n<td>はい、仕事で、陽さんと会っていんです</td>\n<td>恩，因为工作，和洋先生见面。</td>\n</tr>\n</tbody>\n</table></div>\n<h1 id=\"%E5%BA%94%E7%94%A8%E8%AF%BE%E6%96%87---%E6%9C%9D%E3%81%AE%E5%85%AC%E5%9C%92\" tabindex=\"-1\">应用课文 - 朝の公園</h1>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th></th>\n<th>日本語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>もり</td>\n<td>今朝、公園を散歩している時、大勢の人が集まっているのを見ました。</td>\n<td>今天早上在公园散步时，看见许多人聚在一起。</td>\n</tr>\n<tr>\n<td>り</td>\n<td>ああ、お年寄り が 多かったで しょう？</td>\n<td>啊，老年人很多吧。</td>\n</tr>\n<tr>\n<td>もり</td>\n<td>ええ。太極拳やラジオ体操をしていました</td>\n<td>恩，他们在打太极做体操</td>\n</tr>\n<tr>\n<td>り</td>\n<td>朝の運動ですよ。社交ダンスをしている人　たち　もいたでしょう</td>\n<td>人たち、も、いる。人们也有</td>\n</tr>\n<tr>\n<td>もり</td>\n<td>ええ、いました。ほかに、踊りながら歌を歌っている人もいましたよ</td>\n<td>恩，还有人边跳边唱呢。</td>\n</tr>\n<tr>\n<td>もり</td>\n<td>公園に入る時、入園料を払いましたが、どの公園も有料ですか</td>\n<td></td>\n</tr>\n<tr>\n<td>り</td>\n<td>ええ、有料の公園が多いですね</td>\n<td></td>\n</tr>\n<tr>\n<td>もり</td>\n<td>じゃあ、あさの運動をしているお年寄りたちも入園料を払うんですか</td>\n<td></td>\n</tr>\n<tr>\n<td>り</td>\n<td>そうですよ。でも、毎日利用する人は割引があるんです</td>\n<td>是啊，但是每天去公园的人有优惠</td>\n</tr>\n<tr>\n<td>たい</td>\n<td>そう言えば、小さい時、よく祖母と一緒に公園へ行きました</td>\n<td></td>\n</tr>\n<tr>\n<td>もり</td>\n<td>へえ、一緒に運動をしたんですか</td>\n<td></td>\n</tr>\n<tr>\n<td>たい</td>\n<td>いいえ、あたしは遊びながら祖母が太極拳をするのを見ていました</td>\n<td></td>\n</tr>\n<tr>\n<td>り</td>\n<td>休みの時、あたしも公園でジョギングをしています</td>\n<td></td>\n</tr>\n<tr>\n<td>たい</td>\n<td>朝や夕方の涼しい時にスポーツをするのは気持ちがいいですよね</td>\n<td></td>\n</tr>\n</tbody>\n</table></div>\n<hr />\n<blockquote>\n<p>お疲れ様でした</p>\n</blockquote>\n","slug":"学习笔记/日本語/n4n5/lesson27","published":true,"date":"2021-02-21T08:02:58.000Z","updated":"2021-02-22T13:01:11.000Z","path":"学习笔记/日本語/n4n5/lesson27/","api_path":"api/articles/学习笔记/日本語/n4n5/lesson27.json","keywords":null,"tags":[{"name":"学习笔记","path":"api/tags/学习笔记.json"},{"name":"日本語","path":"api/tags/日本語.json"}]},{"title":"唐盾：0-N4日语精讲","subtitle":"第二十六課（だいにじゅうろっか）：自転車に二人で乗るのは危ないです","author":"Kuriko Moe (栗子Chan)","excerpt":"<p>第二十六课：自行车带人很危险</p>\n<p><strong>内容</strong> のは/のを/のが 句型 | 推测句型</p>\n<p><strong>教程地址</strong>：<a href=\"https://www.bilibili.com/cheese/play/ep1042\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/cheese/play/ep1042</a></p>\n","render_content":"<p>第二十六课：自行车带人很危险</p>\n<p><strong>内容</strong> のは/のを/のが 句型 | 推测句型</p>\n<p><strong>教程地址</strong>：<a href=\"https://www.bilibili.com/cheese/play/ep1042\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/cheese/play/ep1042</a></p>\n<!-- more -->\n<h1 id=\"%E5%8D%98%E8%AA%9E\" tabindex=\"-1\">単語</h1>\n<h2 id=\"%E5%90%8D%E8%A9%9E\" tabindex=\"-1\">名詞</h2>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>平仮名</th>\n<th>中国語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>大雨</td>\n<td>おおあめ</td>\n<td>大雨</td>\n<td><ruby>大雪<rt>おおゆき</rt></ruby></td>\n</tr>\n<tr>\n<td>桜</td>\n<td>さくら</td>\n<td>樱花</td>\n<td><ruby>菊<rt>きく</rt></ruby><br />桜祭り、さくらまつり<br />田舎の桜も美しい<br />夜桜（よざくら）这里面的桜浊化为ざくら</td>\n</tr>\n<tr>\n<td>風</td>\n<td>かぜ</td>\n<td>风</td>\n<td>風邪（かぜ）<br />風が吹（ふ）く,風が吹いてます</td>\n</tr>\n<tr>\n<td>月</td>\n<td>つき</td>\n<td>月亮</td>\n<td>月見（つきみ）<br />月見をする<br />一月（いちがつ）<br />一个月（一ケ月，いっかげつ）</td>\n</tr>\n<tr>\n<td>表</td>\n<td>ひょう</td>\n<td>表</td>\n<td>パソコンで表作る（で使用的工具，手段）</td>\n</tr>\n<tr>\n<td>握手</td>\n<td>あくしゅ</td>\n<td>握手</td>\n<td>拍手（はくしゅ）<br />握手をします</td>\n</tr>\n<tr>\n<td>習慣</td>\n<td>しゅうかん</td>\n<td>习惯</td>\n<td>習慣になります、なる，成为习惯<br />これは日本の習慣です</td>\n</tr>\n<tr>\n<td>お辞儀</td>\n<td>おじぎ</td>\n<td>鞠躬</td>\n<td>お客様にお辞儀をする</td>\n</tr>\n<tr>\n<td>あいさつ</td>\n<td></td>\n<td>寒暄</td>\n<td>あいさつする<br />人に挨拶します</td>\n</tr>\n<tr>\n<td>手</td>\n<td>て</td>\n<td>手</td>\n<td>両手（りょうて）：双手。<ruby>手作り<rt>てつくり</rt></ruby></td>\n</tr>\n<tr>\n<td>お客さん</td>\n<td>おきゃくさん</td>\n<td>顾客，客人</td>\n<td>お客様，お客さん</td>\n</tr>\n<tr>\n<td>普通</td>\n<td>ふつう</td>\n<td>一般，普通</td>\n<td>普通の人<br />特別（とくべつ）</td>\n</tr>\n<tr>\n<td>次</td>\n<td>つぎ</td>\n<td>这回，下面，下回</td>\n<td>次の問題</td>\n</tr>\n<tr>\n<td>スーパー</td>\n<td></td>\n<td>超市</td>\n<td>スーパーマーケット<br />コンビニ<br />セブンーいれ（711）<br />ファミリーマート（全家）<br />ローソン(罗森)</td>\n</tr>\n<tr>\n<td>料金</td>\n<td>りょうきん</td>\n<td>费用</td>\n<td>費用（ひよう）<br />授業料（じゅぎょうりょう）：学费<br />有料（ゆうりょう）、無料（むりょう）</td>\n</tr>\n<tr>\n<td>会費</td>\n<td>かいひ</td>\n<td>会费</td>\n<td>会費を払う（はらう）　付会费</td>\n</tr>\n<tr>\n<td>バーゲン</td>\n<td></td>\n<td>降价<s>触手</s>出售</td>\n<td>バーゲン会場（かいじょう）</td>\n</tr>\n<tr>\n<td>クレジットカード</td>\n<td></td>\n<td>信用卡</td>\n<td>カード<br />アリペイ、ウィーチャッと</td>\n</tr>\n<tr>\n<td>色鉛筆</td>\n<td>いろえんぴつ</td>\n<td>彩色铅笔</td>\n<td>色鉛筆で、用彩色铅笔</td>\n</tr>\n<tr>\n<td>豊作</td>\n<td>ほうさく</td>\n<td>丰收</td>\n<td></td>\n</tr>\n<tr>\n<td>仲</td>\n<td>なか(2)</td>\n<td>关系，友情，友谊</td>\n<td>仲間：好朋友<br />仲良し：好伙伴</td>\n</tr>\n<tr>\n<td>忘れ物</td>\n<td>わすれもの</td>\n<td>忘记的东西，遗忘的东西</td>\n<td>物忘れ：健忘、ものわすれ</td>\n</tr>\n</tbody>\n</table></div>\n<h2 id=\"%E5%8B%95%E8%A9%9E\" tabindex=\"-1\">動詞</h2>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>平仮名</th>\n<th>中国語</th>\n<th>原型</th>\n<th>て</th>\n<th>ない</th>\n<th>た</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>防ぎます</td>\n<td>ふせぎます</td>\n<td>防御，防备，防守「动1」</td>\n<td>防ぐ</td>\n<td>防いで</td>\n<td>防がない</td>\n<td>防いだ</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>台風を防ぎます，防范台风</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table></div>\n<h3 id=\"%E5%8B%951\" tabindex=\"-1\">動1</h3>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>平仮名</th>\n<th>中国語</th>\n<th>原型</th>\n<th>て</th>\n<th>ない</th>\n<th>た</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>防ぎます</td>\n<td>ふせぎます</td>\n<td>防御，防备，防守</td>\n<td>防ぐ</td>\n<td>防いで</td>\n<td>防がない</td>\n<td>防いだ</td>\n</tr>\n</tbody>\n</table></div>\n<blockquote>\n<p>台風を防ぎます</p>\n</blockquote>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>平仮名</th>\n<th>中国語</th>\n<th>原型</th>\n<th>て</th>\n<th>ない</th>\n<th>た</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>回ります</td>\n<td>まわります</td>\n<td>走访，转，绕弯</td>\n<td>回る</td>\n<td>回って</td>\n<td>回らない</td>\n<td>回った</td>\n</tr>\n<tr>\n<td>走ります</td>\n<td>はしります</td>\n<td>跑，奔跑</td>\n<td>走る</td>\n<td>走って</td>\n<td>走らない</td>\n<td>走った</td>\n</tr>\n</tbody>\n</table></div>\n<blockquote>\n<p>歩く、歩います、歩いて、歩かない、歩いた。 这个才是走，日语的走是跑。。。</p>\n<p>道を走っています、表示移动的场所→を</p>\n</blockquote>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>平仮名</th>\n<th>中国語</th>\n<th>原型</th>\n<th>て</th>\n<th>ない</th>\n<th>た</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>吹きます</td>\n<td>ふきます</td>\n<td>吹（刮风）</td>\n<td>吹く</td>\n<td>吹いて</td>\n<td>吹かない</td>\n<td>吹いた</td>\n</tr>\n</tbody>\n</table></div>\n<blockquote>\n<p>風が吹きます</p>\n</blockquote>\n<h3 id=\"%E5%8B%952-%EF%BC%86-%E5%8B%953\" tabindex=\"-1\">動2　＆　動3</h3>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>平仮名</th>\n<th>中国語</th>\n<th>原型</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>挙げます</td>\n<td>あげます</td>\n<td>举，举起</td>\n<td>擧げる</td>\n<td>手を擧げる</td>\n</tr>\n<tr>\n<td>足ります</td>\n<td>たります</td>\n<td>足，足够</td>\n<td>足りる</td>\n<td>時間が足ります。お金が足りる</td>\n</tr>\n<tr>\n<td>スケッチします</td>\n<td></td>\n<td>素描</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>発言します</td>\n<td>はつげんします</td>\n<td>发言</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>優勝しまう</td>\n<td>ゆうしょうします</td>\n<td>得冠军</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>合格します</td>\n<td>ごうかくします</td>\n<td>及格，合格</td>\n<td></td>\n<td>試験に合格しました</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>日本語能力試験に合格しました</td>\n</tr>\n<tr>\n<td>約束します</td>\n<td>やくそくします</td>\n<td>约定</td>\n<td></td>\n<td>友達と約束します</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table></div>\n<h2 id=\"%E5%BD%A2%E5%AE%B9%E8%A9%9E%E3%83%BB%E5%BD%A2%E5%AE%B9%E5%8B%95%E8%A9%9E\" tabindex=\"-1\">形容詞・形容動詞</h2>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>平仮名</th>\n<th>中国語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>もしかしたら</td>\n<td></td>\n<td>也许「副词」</td>\n<td>简化：もしも・もし</td>\n</tr>\n<tr>\n<td>つい</td>\n<td></td>\n<td>不知不觉地，无意中</td>\n<td>つい笑い出す</td>\n</tr>\n<tr>\n<td>すぐに</td>\n<td></td>\n<td>马上</td>\n<td>もうすぐ</td>\n</tr>\n<tr>\n<td>ほとんど</td>\n<td></td>\n<td>几乎</td>\n<td>お酒はほとんど飲みません</td>\n</tr>\n<tr>\n<td>それで</td>\n<td></td>\n<td>因此</td>\n<td>日本の車は安いです、それで、人気があります</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>加藤</td>\n<td>かとう</td>\n<td>加藤</td>\n<td><img src=\"https://kurikomoe-1300672427.image.myqcloud.com/images/%E3%81%8B%E3%81%A8%E3%81%86%E3%82%81%E3%81%8F%E3%82%99%E3%81%BF.jpeg\" alt=\"かとうめぐみ\" /></td>\n</tr>\n<tr>\n<td>あいさつまわり</td>\n<td></td>\n<td>寒暄拜访</td>\n<td></td>\n</tr>\n<tr>\n<td>いけない</td>\n<td></td>\n<td>不行</td>\n<td>口语：だめ</td>\n</tr>\n</tbody>\n</table></div>\n<h1 id=\"%E6%96%87%E6%B3%95\" tabindex=\"-1\">文法</h1>\n<h2 id=\"%E5%8A%A8%E8%AF%8D%E5%B0%8F%E5%8F%A5-%2B-%E3%81%AE-%2B-%E3%81%AF%E3%80%9C%E3%81%A7%E3%81%99\" tabindex=\"-1\">动词小句 + の + は〜です</h2>\n<div class=\"note\">\n<p>动词小句+の，使其名词化，表示做某动作的意思。</p>\n<p>のは 可以把前面的句子名词化，使其能够作为主题，从而可以用 は</p>\n</div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>日本に留学するのは私の目的（もくてき）です</td>\n<td>去日本留学是私的目的</td>\n</tr>\n<tr>\n<td>自分（じぶん）で料理を作るのは面白いです</td>\n<td>自己做饭很有趣</td>\n</tr>\n<tr>\n<td>彼と生活（せいかつ）するのは幸せです</td>\n<td>和他一起生活很幸福<br />彼と，生活する，の，は，幸せです</td>\n</tr>\n</tbody>\n</table></div>\n<h3 id=\"%E7%BF%BB%E8%A8%B3\" tabindex=\"-1\">翻訳</h3>\n<p>要掌握一门外语不容易。</p>\n<p>外国語（がいこくご）を覚える（おぼえる）のは難しいです</p>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>自転車に二人で乗るのは危ないです</td>\n<td>骑车带人很危险</td>\n</tr>\n<tr>\n<td>パソコンで表を作るのは楽しいです</td>\n<td>用电脑制表是很愉快的</td>\n</tr>\n</tbody>\n</table></div>\n<h2 id=\"%E5%8A%A8%E8%AF%8D%E5%B0%8F%E5%8F%A5%2B%E3%81%AE%2B%E3%81%8C%E3%80%9C%E3%81%A7%E3%81%99\" tabindex=\"-1\">动词小句+の+が〜です</h2>\n<div class=\"note\">\n<p>动词句名词化用于好恶，水平高低时，要用助词が。</p>\n</div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>鈴木さんは絵を書くのが好きです</td>\n<td>铃木喜欢画画</td>\n</tr>\n<tr>\n<td>私は魚（さかな）を食べるのが嫌いです</td>\n<td>我不喜欢吃鱼</td>\n</tr>\n<tr>\n<td>山田さんは写真を撮るのが上手です</td>\n<td>山田先生擅长拍照</td>\n</tr>\n<tr>\n<td>李さんは絵を書くのが好きですね<br />はい、色鉛筆でスケッチするのが大好きです</td>\n<td>是的，我特别喜欢用彩色铅笔素描。</td>\n</tr>\n<tr>\n<td>私は自転車に乗るのが下手です</td>\n<td>自己擅长的谦虚说法：<ruby>得意<rt>とくい</rt></ruby></td>\n</tr>\n<tr>\n<td>絵を書くのは好きですか</td>\n<td>画画你喜欢么？这里是作为提问的话题。</td>\n</tr>\n<tr>\n<td>いいえ、絵を書くのは嫌いです</td>\n<td></td>\n</tr>\n</tbody>\n</table></div>\n<h3 id=\"%E7%BF%BB%E8%A8%B3-1\" tabindex=\"-1\">翻訳</h3>\n<p>我不太会做饭</p>\n<p>ご飯を作るのが下手です。</p>\n<h2 id=\"%E5%8A%A8%E8%AF%8D%E5%B0%8F%E5%8F%A5-%2B-%E3%81%AE-%2B-%E3%82%92-%2B-%E5%8A%A8\" tabindex=\"-1\">动词小句 + の + を + 动</h2>\n<div class=\"note\">\n<p>动词小句 + の 的名词化形式，还可以作为宾语。</p>\n<p>手紙を出すのを忘れました</p>\n<p>感觉类似于英语中的从句，只不过是放在了前面。</p>\n<p>手紙を出す　这个玩意 作为  忘る 的宾语。</p>\n<p>但是问题是。。中英文都是 我，忘记了，xxx。日语是反过来 我 xxx 忘记了。。。。</p>\n</div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>手紙を出すのを忘れました</td>\n<td>忘记寄信了</td>\n</tr>\n<tr>\n<td>森さん<strong>が</strong>発言するのを聞きました</td>\n<td>听了森先生的发言</td>\n</tr>\n<tr>\n<td></td>\n<td>如果这里是は，就变成了森先生听到了某人的发言（根据上下文判断）<br />森さんんは「発言するのを」聞きました</td>\n</tr>\n<tr>\n<td>手紙を出すのを忘れました<br /></td>\n<td>手紙を出すことを忘れました</td>\n</tr>\n<tr>\n<td>林さんは掃除するのをやめました</td>\n<td>林先生不做扫除了</td>\n</tr>\n<tr>\n<td>李さんは小野さんが料理を作るのを手伝います</td>\n<td>小李在帮小野女士做菜</td>\n</tr>\n<tr>\n<td>李さんは部長に報告するのを忘れました</td>\n<td>小野忘了向部长汇报</td>\n</tr>\n<tr>\n<td></td>\n<td>李さんは部長に報告すことを忘れました</td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"alert\">\n<p>句尾的动词是「知らせます」、「伝えます」、「話ます」等表示语言行为的动词时，要用「こと」\n这里表达的是你传达的是「一件事」</p>\n</div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>李さんは森さんが休むことを伝（つた）えました</td>\n<td>小李转告了森先生请假的事情</td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"alert\">\n<p>句尾动词是「見ます」、「聞きます」、等表示感知的动词或</p>\n<p>「手伝います」、「やめます」、「防ぎます」等直接作用于动作对象的动词，</p>\n<p><strong>使用の</strong>而不能用こと</p>\n</div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>李さんは森さんが車か<ruby>降<rt>お</rt></ruby>りるのを見た</td>\n<td>小李看见森先生从车上下来了</td>\n</tr>\n<tr>\n<td>李さんは森さんが荷物を運ぶのを手伝いました</td>\n<td>小李帮森先生运行李</td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"note\">\n<p>简单起见，可以认为只有语言行为需要用 こと、其他的一律用 の 就好了。</p>\n</div>\n<h3 id=\"%E7%BF%BB%E8%A8%B3-2\" tabindex=\"-1\">翻訳</h3>\n<p>忘记跟部长报告了</p>\n<p>部長に報告するのを忘れた</p>\n<h2 id=\"%E5%8A%A8%E8%AF%8D%E5%B0%8F%E5%8F%A5%EF%BC%88%E7%AE%80%E4%BD%93%EF%BC%89%E3%81%A7%E3%81%97%E3%82%87%E3%81%86%E3%80%8C%E6%8E%A8%E6%B5%8B%E3%80%8D\" tabindex=\"-1\">动词小句（简体）でしょう「推测」</h2>\n<p>表示说话人对自己和听话人都不能断定的事情进行推测</p>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>明日から天気が<ruby>良く<rt>よく</rt></ruby>なるでしょう</td>\n<td>明天天气会好转吧</td>\n</tr>\n<tr>\n<td>森さんは知らないでしょう</td>\n<td></td>\n</tr>\n<tr>\n<td>この本の値段はわかりませんが、たぶん高いいでしょう</td>\n<td>不知道这本书的价钱，可能挺贵的吧</td>\n</tr>\n<tr>\n<td>このはたぶん先生の忘れ物でしょう</td>\n<td>这大概是老师忘得东西吧</td>\n</tr>\n</tbody>\n</table></div>\n<p>唐盾：0-N4日语精讲_哔哩哔哩 (゜-゜)つロ 干杯_-bilibili:::note</p>\n<p>当想表示状态发生了自然变化时，会使用“～なる”的说法</p>\n<p><strong>1类形容词</strong>词尾い变成く＋なる</p>\n<p><strong>2类形容词</strong>＋に＋なる</p>\n<p>:::</p>\n<h3 id=\"translation\" tabindex=\"-1\">Translation</h3>\n<p>因为今天是圣诞节，商场估计很热闹叭</p>\n<p>今日はクリスマスですから、デパートは賑やかでしょう</p>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>明日の朝は大雨になるでしょう</td>\n<td>明天早晨会下大雨叭</td>\n</tr>\n<tr>\n<td>森さんは知らないでしょう</td>\n<td>森先生不知道叭</td>\n</tr>\n<tr>\n<td>この本の値段はわかりませんが、たぶん高いでしょう</td>\n<td>咱不知道这本书的价格啦，大概很贵叭</td>\n</tr>\n<tr>\n<td>桜の季節ですから、きょうとはたぶん賑やかでしょう</td>\n<td>现在正式观赏樱花的季节，京都大概很热闹叭。</td>\n</tr>\n<tr>\n<td>今年はたぶんほうさくだろう</td>\n<td>今年大概是一个丰收年叭</td>\n</tr>\n<tr>\n<td>これはたぶん誰の忘れ物だろう</td>\n<td>这大概是谁忘记的东西叭</td>\n</tr>\n<tr>\n<td>会議はもう終わっただろう</td>\n<td>終わるー＞終わった</td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"note\">\n<p>でしょう　＝＝　だろう</p>\n<p>でしょう更加礼貌一些</p>\n</div>\n<h2 id=\"%E5%B0%8F%E5%8F%A5%EF%BC%88%E7%AE%80%E4%BD%93%EF%BC%89%E3%81%8B%E3%82%82%E3%81%97%E3%82%8C%E3%81%BE%E3%81%9B%E3%82%93%2F%E3%81%8B%E3%82%82%E3%81%97%E3%82%8C%E3%81%AA%E3%81%84\" tabindex=\"-1\">小句（简体）かもしれません/かもしれない</h2>\n<p>表示有可能发生某事，其可能性一般为 50%</p>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>来週日本に出張するかもしれません</td>\n<td>下周有可能去日本出差</td>\n</tr>\n<tr>\n<td>この小説は面白いかもしれません</td>\n<td>这个小说可能挺有趣的</td>\n</tr>\n<tr>\n<td>そこはきれいかもしれません</td>\n<td>那里也许挺漂亮干净的</td>\n</tr>\n<tr>\n<td>あのひとは日本人かもしれません</td>\n<td>那个人也许是日本人</td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"note\">\n<p>translation: 那两个人也许会结婚</p>\n<p>あの二人は結婚するかもしれません</p>\n</div>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>日本語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>森さんは今日会社を休むかもしれません</td>\n<td>森先生今天也许不来公司上班</td>\n</tr>\n<tr>\n<td>あの二人は仲がいいですね</td>\n<td>那两个人关系很好呀</td>\n</tr>\n<tr>\n<td>あのひとは結婚するかもしれません</td>\n<td>也许他们会结婚叭。</td>\n</tr>\n<tr>\n<td>クレジットカードを落としたかもしれません</td>\n<td>也许我把信用卡弄丢了　落とすー＞おとします</td>\n</tr>\n<tr>\n<td>来週は暇かもしれません</td>\n<td>下星期也许有空</td>\n</tr>\n<tr>\n<td>明日は雪かもしれません</td>\n<td>明天也许下雪</td>\n</tr>\n<tr>\n<td>明日は雨降るかもしれませんが、ふらないかもしれませんが</td>\n<td>明天也许下雨，也许不下</td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"note\">\n<h2 id=\"%E6%80%BB%E7%BB%93\" tabindex=\"-1\">总结</h2>\n<p><img src=\"https://kurikomoe-1300672427.image.myqcloud.com/images/20210221150432.png\" alt=\"20210221150432\" /></p>\n</div>\n<h1 id=\"%E5%9F%BA%E6%9C%AC%E8%AF%BE%E6%96%87\" tabindex=\"-1\">基本课文</h1>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th></th>\n<th>日本語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>あ</td>\n<td>李さんは絵を書くのが好きですね</td>\n<td>动词小句「絵を書く」のが</td>\n</tr>\n<tr>\n<td>い</td>\n<td>ええ、大好きです。で　も、あまりじょうずではありませんよ</td>\n<td>あまり＋ません</td>\n</tr>\n<tr>\n<td>あ</td>\n<td>吉田さんが転勤したのを知っていますか</td>\n<td>吉田先生调动工作了，你知道么？</td>\n</tr>\n<tr>\n<td>い</td>\n<td>えつ、本当ですか。知りませんでした</td>\n<td>or 知らなかった</td>\n</tr>\n<tr>\n<td>あ</td>\n<td>会議はなんじに終わりますか？</td>\n<td></td>\n</tr>\n<tr>\n<td>い</td>\n<td>２時には終わるでしょう</td>\n<td></td>\n</tr>\n<tr>\n<td>あ</td>\n<td>馬さんはまだ来ませんね</td>\n<td></td>\n</tr>\n<tr>\n<td>い</td>\n<td>もしかしたら、今日は来ないかもしれませんよ</td>\n<td></td>\n</tr>\n</tbody>\n</table></div>\n<h1 id=\"%E5%BA%94%E7%94%A8%E8%AF%BE%E6%96%87---%E6%8F%A1%E6%89%8B%E3%81%A8%E3%81%8A%E8%BE%9E%E5%84%80\" tabindex=\"-1\">应用课文 - 握手とお辞儀</h1>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th></th>\n<th>日本語</th>\n<th>注釈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>陽</td>\n<td>はじめまして、陽です</td>\n<td></td>\n</tr>\n<tr>\n<td>森</td>\n<td>はじめまして、森です。よろしくお願いします</td>\n<td></td>\n</tr>\n<tr>\n<td>陽</td>\n<td>日本には握手の習慣がないんですね</td>\n<td>んです、ん表强调</td>\n</tr>\n<tr>\n<td>森</td>\n<td>ええ、そうなんです。それで、つい握手するのを忘れます</td>\n<td>因为陽用了强调，所以森回答得时候也用了强调。</td>\n</tr>\n<tr>\n<td></td>\n<td>中国にはあくしゅするのが普通なんですか</td>\n<td>普通な</td>\n</tr>\n<tr>\n<td>陽</td>\n<td>ええ、そうですよ。日本にはお辞儀のほかのあいさつはないですか</td>\n<td><a href=\"https://ja.wikipedia.org/wiki/%E6%8C%A8%E6%8B%B6\" target=\"_blank\" rel=\"noopener\"><ruby>挨拶 <rt>あいさつ</rt></ruby></a>：问候</td>\n</tr>\n<tr>\n<td>森</td>\n<td>そうですね。手を挙げなり、握手したりするひともいますが</td>\n<td>したり 举例子<br />握手的人也有<br />握手しなりする　人　も　いますが</td>\n</tr>\n<tr>\n<td></td>\n<td>ほとんど　お辞儀ですね</td>\n<td>ほとんど：几乎</td>\n</tr>\n<tr>\n<td>戴</td>\n<td>陳さん。もりさんの午後の予定は挨拶まわりですね</td>\n<td>老陈，森下午的安排是拜访对吧</td>\n</tr>\n<tr>\n<td>陳</td>\n<td>ええ、今１時半ですから、これから ４社ぐらい 回ることが できるでしょう</td>\n<td>从现在起能转4家公司叭</td>\n</tr>\n<tr>\n<td>たい</td>\n<td>そうですね、五社いくことができるかもしれませんよ。森さん、つぎは握手するのを忘れないでくださいね</td>\n<td></td>\n</tr>\n</tbody>\n</table></div>\n<hr />\n<blockquote>\n<p>お疲れ様でした</p>\n</blockquote>\n","slug":"学习笔记/日本語/n4n5/lesson26","published":true,"date":"2020-09-27T11:17:11.000Z","updated":"2021-02-21T08:00:10.000Z","path":"学习笔记/日本語/n4n5/lesson26/","api_path":"api/articles/学习笔记/日本語/n4n5/lesson26.json","keywords":null,"tags":[{"name":"学习笔记","path":"api/tags/学习笔记.json"},{"name":"日本語","path":"api/tags/日本語.json"}]},{"title":"程序员面试金典-读书笔记","subtitle":"Chapter 7+8","author":"Kuriko Moe (栗子Chan)","excerpt":"<blockquote>\n<p>不要问 Ch1-6 去哪儿了。。不是被咱吃了OvO</p>\n</blockquote>\n<p>这里是从 Ch7 开始的读书笔记。</p>\n","render_content":"<blockquote>\n<p>不要问 Ch1-6 去哪儿了。。不是被咱吃了OvO</p>\n</blockquote>\n<p>这里是从 Ch7 开始的读书笔记。</p>\n<!-- more -->\n<div class=\"info\">\n<p><strong>就本书的面试题以及亦可能遇到的其他题目，请参照以下几个步骤</strong>:</p>\n<ol>\n<li>\n<p><strong>尽量独立解题</strong>。本书后面有一些提示可供参考，但是尽量不要依赖提示解决问题。\n许多题目确实很难，但是没关系，不要怕！此外，解题时还要考虑空间和时间复杂度。</p>\n</li>\n<li>\n<p><strong>在纸上写代码</strong>（这里咱就直接用无语法高亮的 ViM 写了，相应的题目在Leetcode-cn 上直接浏览器作答）。\n在电脑上编程可以享受到 语法高亮、代码 Lint，快速调试等种种好处，在纸上写代码则不然。\n通过在纸上多多实践来适应这种情况，并对在纸上编写、编辑代码的缓慢习以为常。</p>\n</li>\n<li>\n<p><strong>在纸上测试代码</strong>。就是在纸上写下一般用例、基本用例和错误用例等。面试就需要这么做\n因此需要提前做好准备。</p>\n</li>\n<li>\n<p><strong>将代码照原样的输入计算机</strong>。你也许会犯一大堆错误。请整理一份<strong>清单</strong>，罗列自己\n犯过的所有错误，这样在真正面试时才能牢记在心。</p>\n</li>\n</ol>\n<blockquote>\n<p>此外，尽量多做模拟面试。你可以和朋友轮流给对方做模拟面试。虽然你的朋友不见得 受到过什么专业训练，但至少能带你过一边代码或者算法面试题。你也会在当面试的体验中，获益良多。</p>\n</blockquote>\n</div>\n<h1 id=\"chapter-7\" tabindex=\"-1\">Chapter 7</h1>\n<h2 id=\"%E5%BF%85%E5%A4%87%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\" tabindex=\"-1\">必备的基础知识</h2>\n<h3 id=\"%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%A6%82%E5%BF%B5\" tabindex=\"-1\">核心数据结构、算法以及概念</h3>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>数据结构</th>\n<th>算法</th>\n<th>概念</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>链表✔️</td>\n<td>广度优先搜索✔️</td>\n<td>位操作（需要巩固 Hex &lt;-&gt; Dec  &lt;-&gt; Bin 转换)</td>\n</tr>\n<tr>\n<td>树、单词查找树、图✔️</td>\n<td>深度优先搜索 ✔️</td>\n<td>内存（堆和栈）✔️</td>\n</tr>\n<tr>\n<td>栈和队列✔️</td>\n<td>二分查找 ✔️</td>\n<td>递归✔️</td>\n</tr>\n<tr>\n<td>堆 ✔️</td>\n<td>归并排序（需要亲自写一份）✔️</td>\n<td>动态规划（需要更多的题目）</td>\n</tr>\n<tr>\n<td>向量/数组列表 ✔️</td>\n<td>快排（需要亲自写一份）✔️</td>\n<td>大 \\(\\mathcal{O}\\) 时间以及空间✔️</td>\n</tr>\n<tr>\n<td>散列表 ✔️</td>\n</tr>\n</tbody>\n</table></div>\n<p>✔️ Leetcode 排序测试题目：<a href=\"https://leetcode-cn.com/problems/sort-an-array/\" target=\"_blank\" rel=\"noopener\">适用于快排和归并排序</a></p>\n<h4 id=\"in-place-%E5%BF%AB%E6%8E%92%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83\" tabindex=\"-1\">In-Place 快排算法核心</h4>\n<p>为了减少空间复杂度，快速排序在选取出参考元素之后，可以进行原地数组操作：</p>\n<pre><code class=\"language-rust\">unsafe fn swap&lt;T: Copy + Debug&gt;(a: *mut T, b: *mut T) {\n  let tmp = b.as_ref().unwrap().clone();\n  *b = *a;\n  *a = tmp;\n}\n\n// 将队列参考元素（这里是最左端元素，可以改为随机化选取）与队列末端交换，\n// 使得最左端为缓冲区\nswap(&amp;mut _pNum[r] as *mut i32, &amp;mut _pNum[p_mid] as *mut i32);\n\nfor i in l..r {\n  // 如果元素比参考值小，则放置到左端区域\n   if _pNum[i] &lt; mid {\n     // 交换元素\n     swap(&amp;mut _pNum[p_mid] as *mut i32, &amp;mut _pNum[i] as *mut i32);\n     // 左端缓冲区扩大\n     p_mid += 1;\n   }\n}\n\n// 将参考元素移回到缓冲区头部（缓冲区头部**一定**不满足「小于」参考元素的要求）\nswap(&amp;mut _pNum[r] as *mut i32, &amp;mut _pNum[p_mid] as *mut i32);\n\nSolution::quick_sort(l, p_mid);\nSolution::quick_sort(p_mid + 1, r);\n</code></pre>\n<p>参考资料：<a href=\"https://zh.wikipedia.org/zh-cn/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\" target=\"_blank\" rel=\"noopener\">Wikipedia</a></p>\n<p>// TODO: 添加源代码的 Github Repo 引用</p>\n<h3 id=\"%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83\" tabindex=\"-1\">归并排序算法核心</h3>\n<div class=\"info\">\n<p>归并排序很难做到 In-Place 实现最小化内存占用。。。</p>\n<p>In-Place 算法需要更大的时间复杂度（需要位移元素）</p>\n</div>\n<pre><code class=\"language-rust\">use std::fmt::Debug;\n\nstatic mut P_NUM: *mut Vec&lt;i32&gt; = std::ptr::null_mut();\n\nimpl Solution {\n  unsafe fn swap&lt;T: Copy + Debug&gt;(a: *mut T, b: *mut T) {\n    let tmp = b.as_ref().unwrap().clone();\n    *b = *a;\n    *a = tmp;\n  }\n\n  unsafe fn merge_sort(l: usize, r: usize) {\n    let pNum = P_NUM.as_mut().unwrap();\n\n    if l == r {\n      return;\n    } else if l + 1 == r &amp;&amp; pNum[l] &gt; pNum[r] {\n      Solution::swap(&amp;mut pNum[l], &amp;mut pNum[r]);\n      return;\n    }\n\n    let mid = (l + r) / 2;\n\n    Solution::merge_sort(l, mid);\n    Solution::merge_sort(mid + 1, r);\n\n    // do the merge\n    let (mut i, mut j) = (l, mid + 1);\n\n    let mut tmp = Vec::new();\n\n    while i &lt;= mid &amp;&amp; j &lt;= r {\n      if pNum[i] &lt; pNum[j] {\n        tmp.push(pNum[i]);\n        i += 1;\n      } else {\n        tmp.push(pNum[j]);\n        j += 1;\n      }\n    }\n\n    let (start, end) = if i &gt; mid { (j, r) } else { (i, mid) };\n\n    for k in start..=end {\n      tmp.push(pNum[k]);\n    }\n\n    for i in 0..tmp.len() {\n      pNum[l + i] = tmp[i];\n    }\n  }\n\n  pub fn sort_array(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    let mut ret = nums;\n    unsafe {\n      P_NUM = &amp;mut ret;\n      Solution::merge_sort(0, ret.len() - 1);\n      ret\n    }\n  }\n}\n</code></pre>\n<div class=\"warning\">\n<p>版本：rustc 1.44.0-nightly (b2e36e6c2 2020-04-22)</p>\n<p>对于 static mut 全局变量，并行测试的时候存在随机错误问题。需要使用 --test-threads=1</p>\n<pre class='command-line' data-user='kuriko' data-host='kuriko.moe'>\n<code class='language-bash'>\ncargo test -- --nocapture --test-threads=1\n</code>\n</pre>\n</div>\n<h4 id=\"2-%E7%9A%84%E5%B9%82%E6%AC%A1%EF%BC%88hex-%3C-%3E-dec-%3C-%3E-bin%EF%BC%89\" tabindex=\"-1\">2 的幂次（Hex &lt;-&gt; Dec &lt;-&gt; Bin）</h4>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>Hex</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>A</th>\n<th>B</th>\n<th>C</th>\n<th>D</th>\n<th>E</th>\n<th>F</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Dec</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n<td>5</td>\n<td>6</td>\n<td>7</td>\n<td>8</td>\n<td>9</td>\n<td>10</td>\n<td>11</td>\n<td>12</td>\n<td>13</td>\n<td>14</td>\n<td>15</td>\n</tr>\n<tr>\n<td>Bin</td>\n<td>0</td>\n<td>1</td>\n<td>10</td>\n<td>11</td>\n<td>100</td>\n<td>101</td>\n<td>110</td>\n<td>111</td>\n<td>1000</td>\n<td>1001</td>\n<td>1010</td>\n<td>1011</td>\n<td>1100</td>\n<td>1101</td>\n<td>1110</td>\n<td>1111</td>\n</tr>\n</tbody>\n</table></div>\n<h2 id=\"%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4\" tabindex=\"-1\">解题步骤</h2>\n<p>下面这个流程图是如何逐步解决一个问题：\n<img src=\"https://kurikomoe-1300672427.image.myqcloud.com/images/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/ch7/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%B5%81%E7%A8%8B%E5%9B%BE.png\" alt=\"问题解决流程图\" /></p>\n<h3 id=\"%E9%9D%A2%E8%AF%95%E6%9C%9F%E5%BE%85\" tabindex=\"-1\">面试期待</h3>\n<h4 id=\"%E8%AE%A4%E7%9C%9F%E5%90%AC\" tabindex=\"-1\">认真听</h4>\n<p>注意面试官的问题中蕴含的信息，例如：</p>\n<ul>\n<li>有两个<strong>排序</strong>的数组</li>\n<li>设计一个在<strong>服务器</strong>上经常运行的算法：重复运行不同于只运行一次的算法。也许意味着你可以缓存数据，或者你可以顺理成章的对数据进行预处理。</li>\n</ul>\n<p>相关信息写在白板上对你会有很大的帮助。</p>\n<h4 id=\"%E7%94%BB%E4%B8%AA%E4%BE%8B%E5%9B%BE\" tabindex=\"-1\">画个例图</h4>\n<p>即画出一个有点特殊的例子作为思考的入手，避免例如有序数组，平衡二叉树之类的附加了特殊情况的样例作为思考的入手，这样容易被特殊情况带偏思考。</p>\n<h4 id=\"%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E8%9B%AE%E5%8A%9B%E6%B3%95\" tabindex=\"-1\">给出一个蛮力法</h4>\n<div class=\"warning\">\n<p>一些求职者不想给出蛮力法，是因为他们认为此方法不仅显而易见而且糟糕透顶。但是事实是：即使对你来说轻而易举，也未必对所有求职者来说都是这样。你不会想让面试官认为，即使是想出一个最简单的算法对你来说也是绞尽脑汁。</p>\n<div class=\"info\">\n<p>实际上，根据数据统计，[TODO] 问题的通过率竟然很低。</p>\n</div>\n</div>\n<h4 id=\"%E4%BC%98%E5%8C%96\" tabindex=\"-1\">优化</h4>\n<h4 id=\"%E6%A2%B3%E7%90%86\" tabindex=\"-1\">梳理</h4>\n<h4 id=\"%E5%AE%9E%E7%8E%B0\" tabindex=\"-1\">实现</h4>\n<p>（对于白板编程）写代码时要从白板的左上角开始。代码尽量水平方向写（不要写成一条斜线）</p>\n<p>切记，你只能写一小段代码来证明自己是一个优秀的开发人员。因此，每行代码都至关重要，一定要写的漂亮。</p>\n<div class=\"info\">\n<p>例如：</p>\n<ul>\n<li>模块化的代码。着展现了良好的代码风格，也会使你的解题更为顺畅：<pre><code class=\"language-rust\">let data = vec![vec![1, 2, 3], vec![3, 4, 5]]; // 不推荐\n\n// 推荐，省略数据输入，用模块来替代，防止代码过于细节\nlet data: Vec&lt;Vec&lt;i32&gt;&gt; = initInputData({height, width}); \n</code></pre>\n如果有需要，可以之后再写出来 <code>initInputData</code> 的具体实现。</li>\n<li>错误检查。有些面试官很看重这个，但有些对比不是很在意。一个好的办法是用 <code>TODO</code> 来省略可能需要的异常检查。</li>\n<li>使用恰到好处的类、结构体：如果需要再函数中返回一个列表等数据结构，可以直接用一个数据结构替代（名字要起好），大可以假设存在这样的数据结构。如果后面有富裕的时间，再补充细节就行了。</li>\n<li>好的变量名。只在循环索引的时候使用简单变量名。</li>\n</ul>\n</div>\n<h4 id=\"%E6%B5%8B%E8%AF%95\" tabindex=\"-1\">测试</h4>\n<p>发现了 bug（很有可能）就要修复，但注意不要贸然修改。仔细斟酌，找出问题的所在，找到最佳的修改方法再动手。</p>\n<div class=\"info\">\n<p>过于真实 QAQ，比如本 <code>blog</code> 上线的时候，咱经常在线上浏览的时候发现了 bug，就很匆忙在本地改完，跑一下编译测试就交上去了，但是很快在线上就会发现修改会引发其他问题。。。</p>\n</div>\n<h2 id=\"%E4%BC%98%E5%8C%96%E5%92%8C%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%EF%BC%9A%E5%AF%BB%E6%89%BE-bud\" tabindex=\"-1\">优化和解题技巧1：寻找 BUD</h2>\n<div class=\"note\">\n<p>BUD:</p>\n<ul>\n<li>瓶颈（Bottleneck）</li>\n<li>无用功（Unnecessary work）</li>\n<li>重复性工作（Duplicated word）</li>\n</ul>\n</div>\n<h2 id=\"%E4%BC%98%E5%8C%96%E5%92%8C%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A72%3A-%E4%BA%B2%E5%8A%9B%E4%BA%B2%E4%B8%BA\" tabindex=\"-1\">优化和解题技巧2: 亲力亲为</h2>\n<p>有时候单纯的思考算法反而不如先自己动手，在一个小的例子上尝试一下，人脑能很奇妙的给出一个直觉上的Solution。</p>\n<p>重点留意你凭直觉或不经意间做出的任何<code>优化</code>。例如你可能在解题的时候跳过所有以<code>d</code>开头的滑动窗口，因为<code>d</code>不在参考字符串<code>abbc</code>中。</p>\n<h2 id=\"%E4%BC%98%E5%8C%96%E5%92%8C%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A73%3A-%E5%8C%96%E7%B9%81%E4%B8%BA%E7%AE%80\" tabindex=\"-1\">优化和解题技巧3: 化繁为简</h2>\n<h2 id=\"%E4%BC%98%E5%8C%96%E5%92%8C%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A74%3A-%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1\" tabindex=\"-1\">优化和解题技巧4: 由浅入深</h2>\n<p>将一个大的问题分解为一个个小步骤的组合。</p>\n<div class=\"info\">\n<p>例如对于 n = 4 的元素 \\({a, b, c, d}\\)的全排列，可以先考虑</p>\n<p>n = 1,  \\(P(\\\\{a\\\\}) = \\{\\\\{ a \\}\\\\}\\)</p>\n<p>n = 2, \\(P(\\\\{a,b\\\\}) = \\{\\\\{a, b\\\\}, \\\\{b, a\\}\\\\}\\)</p>\n<p>n = 3, \\(P(\\\\{a, b, c\\\\}) = \\\\{\\\\{a, b, c\\\\}, \\\\{a, c, b\\\\}, \\\\{c, a, b\\\\}, \\\\{c, b, a\\\\}, \\cdots \\\\}\\)</p>\n<p>对于 \\(n\\ge3\\) 可以认为在 \\(n-1\\)的组合中插入新元素得到，因此可以得到一个递归的算法。</p>\n</div>\n<h2 id=\"%E4%BC%98%E5%8C%96%E5%92%8C%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A75%3A-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%B4%E8%84%91%E9%A3%8E%E6%9A%B4%E6%B3%95\" tabindex=\"-1\">优化和解题技巧5: 数据结构头脑风暴法</h2>\n<h2 id=\"%E5%8F%AF%E6%83%B3%E8%B1%A1%E7%9A%84%E6%9E%81%E9%99%90%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4\" tabindex=\"-1\">可想象的极限运行时间</h2>\n<p>可想象的极限运行时间（<strong>BCR</strong>），按字面意思理解就是，关于某个问题的解决，你可以想象出的运行时间的极限。你可以轻而易举的证明，BCR 是无法超越的</p>\n<div class=\"note\">\n<p>类似于运行时间上限，\\(O\\) 时间复杂度。</p>\n</div>\n<h3 id=\"%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E\" tabindex=\"-1\">举例说明</h3>\n<p>考虑以下问题：</p>\n<div class=\"question\">\n<p>找到两个排序数组中<strong>相同元素的个数</strong>，这两个数组长度相同，且每个数组中元素都不同。</p>\n<ul>\n<li>A: 13 27 <u>35</u> <u>40</u> 49 <u>55</u> 59</li>\n<li>B: 17 <u>35</u> 39 <u>40</u> <u>55</u> 58 60</li>\n</ul>\n</div>\n<p>这个问题的 BCR 为 \\(O(N)\\)，因为我们知道没个元素都必须访问一次，一共是 \\(2N\\)  个元素。暴力法复杂度为\\(O(N^2)\\)，因此：</p>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th>Complexity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Brute Force:</td>\n<td>\\(O(N^2)\\)</td>\n</tr>\n<tr>\n<td>Optimal Algorithm:</td>\n<td>\\(?\\)</td>\n</tr>\n<tr>\n<td>BCR:</td>\n<td>\\(O(N)\\)</td>\n</tr>\n</tbody>\n</table></div>\n<p>如果当前的算法的运行时间是\\(O(N^2)\\)，那么可以的优化方向是\\(O(N)\\)或\\(O(NlogN)\\)</p>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th>Complexity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Brute Force:</td>\n<td>\\(O(N^2)\\)</td>\n</tr>\n<tr>\n<td>Improved Algorithm:</td>\n<td>\\(O(NlogN)\\)，基于二分查找</td>\n</tr>\n<tr>\n<td>Optimal Algorithm:</td>\n<td>\\(?\\)</td>\n</tr>\n<tr>\n<td>BCR:</td>\n<td>\\(O(N)\\)</td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"info\">\n<p>BCR 说明，解出这个算法的最快运行时间为\\(O(N)\\)，因此我们可以认为任何复杂度在 \\(O(N)\\) 的工作都是“免费的”。从这个意义上来说，对运行时间并无影响。</p>\n</div>\n<p>如何优化运行空间呢？</p>\n<p>对于二分查找，每次并不需要从开始处查找，只要从上一次的停止的位置开始即可。从 BUD 上来考虑，这个搜索的过程是整个算法的瓶颈。</p>\n<h2 id=\"%E5%A5%BD%E4%BB%A3%E7%A0%81%E7%9A%84%E6%A0%87%E5%87%86\" tabindex=\"-1\">好代码的标准</h2>\n<ul>\n<li>正确</li>\n<li>高效</li>\n<li>简洁</li>\n<li>可读性</li>\n<li>可维护性</li>\n</ul>\n<h1 id=\"chapter-9%3A-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE\" tabindex=\"-1\">Chapter 9: 面试题目</h1>\n<h1 id=\"%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2\" tabindex=\"-1\">数组与字符串</h1>\n<h3 id=\"%E6%95%A3%E5%88%97%E8%A1%A8\" tabindex=\"-1\">散列表</h3>\n<div class=\"warning\">\n<p>具体概念略，这个应该都懂吧。。。</p>\n</div>\n<h2 id=\"%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97\" tabindex=\"-1\">散列表的取模运算</h2>\n<p>在高中 OI 的时候，有一个说法是使用素数作为模会减少 Hash 冲突。</p>\n<p>对于一般的随机数，其实并无区别，但是大部分的测例或者现实情况是，数据是有某种规律的，这时候使用素数可以有效防止对面的规律正好存在公因数。</p>\n<blockquote>\n<p>参考资料：<a href=\"https://www.zhihu.com/question/20806796\" target=\"_blank\" rel=\"noopener\">Hash时取模一定要模质数吗？</a></p>\n</blockquote>\n<div class=\"extra\">\n<p>有兴趣的可以记下来这个表：<a href=\"https://planetmath.org/goodhashtableprimes\" target=\"_blank\" rel=\"noopener\">good hash table primes</a>。逃。。。。</p>\n</div>\n<h2 id=\"%E9%93%BE%E8%A1%A8\" tabindex=\"-1\">链表</h2>\n<h3 id=\"%E5%BF%AB%E8%A1%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7\" tabindex=\"-1\">快行指针技巧</h3>\n<p>在处理链表问题的时候，“快行指针”（或称第二个指针）是一种很创建的技巧。“快行指针”指的是同时用两个指针来迭代访问链表，只不过一个比另一个超前一些。“快”指针往往先行几步，或者和“慢”指针相差固定的步数。</p>\n<div class=\"question\">\n<p>假定存在链表 \\(a_1\\rightarrow a_2 \\rightarrow \\dots a_n \\rightarrow b_1 \\rightarrow b_2 \\rightarrow \\dots \\rightarrow b_n\\) 。</p>\n<p>请用  \\(O(N)\\) 的时间，\\(O(1)\\) 的存储，变换为 \\(a_1 \\rightarrow b_a  \\rightarrow a_2  \\rightarrow b_2  \\rightarrow \\dots a_n  \\rightarrow b_n\\)。</p>\n</div>\n<div class=\"info\">\n<p>吐槽 P2.5: 每次写 Rust，都有种。。啊，放过咱吧。让咱用 raw pointer 到处乱指吧 QAQ</p>\n</div>\n<h2 id=\"%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%89%8D%E6%8F%90%E6%98%AF%E4%BD%A0%E8%A6%81%E6%89%BE%E5%88%B0%E5%AF%B9%E8%B1%A1%EF%BC%89\" tabindex=\"-1\">面向对象设计<spoiler>（前提是你要找到对象）</spoiler></h2>\n<p>面向对象设计问题要求求职者设计出类和方法，以实现技术问题或描述真实生活中的对象。这类问题会让或者至少会让面试官了解你的编程风格。</p>\n<p>这些问题并不那么着重于设计模式，而是意在考察你是否懂得如何打造优雅、容易维护的面向对象代码。<strong>若在这类问题上表现不佳，面试可能会亮起红灯。</strong></p>\n<h3 id=\"%E5%A6%82%E4%BD%95%E8%A7%A3%E7%AD%94\" tabindex=\"-1\">如何解答</h3>\n<p>以下解题思路对于解决很多问题大有裨益。</p>\n<h4 id=\"%E6%AD%A5%E9%AA%A41%EF%BC%9A%E5%A4%84%E7%90%86%E4%B8%8D%E6%98%8E%E7%A1%AE%E7%9A%84%E5%9C%B0%E6%96%B9\" tabindex=\"-1\">步骤1：处理不明确的地方</h4>\n<p>碰到面向对象设计问题是，你应该先问清楚<strong>谁</strong>是使用者以及他们将<strong>如何</strong>使用。对于某些问题，你甚至还要问清楚“<strong>6W</strong>”，即 who, what, where, when why how.</p>\n<div class=\"example\">\n<p><strong>请描述一个咖啡机的面向对象设计：</strong></p>\n<p>需要考虑：这台咖啡机可能是一款工业型机器，设计用来放在大餐厅里，每小时要服务几百位顾客，还能制造10种不同口味的咖啡。或者可能只是给老年人设计的简易咖啡机。只要能制作简单的黑咖啡就行。这些额外的用例将会大大影响你的设计。</p>\n</div>\n<h3 id=\"%E6%AD%A5%E9%AA%A42%EF%BC%9A%E5%AE%9A%E4%B9%89%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1\" tabindex=\"-1\">步骤2：定义核心对象</h3>\n<p>了解我「们要设计的东西后，接下来就该思考系统的核心对象了</p>\n<div class=\"info\">\n<p>核心对象可能有：Table, Guest, Party, Order, Meal, Employee, Server, Host</p>\n</div>\n<h3 id=\"%E6%AD%A5%E9%AA%A43%3A%E5%88%86%E6%9E%90%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB\" tabindex=\"-1\">步骤3:分析对象关系</h3>\n<p>定义出核心对象之后，接下来要分析这些对象之间的关系。其中，哪些对象是其他对象的数据成员 ？哪个对象继承自别的对象？对象之间是多对多的关系，还是一对多的关系？</p>\n<div class=\"warning\">\n<p>分析对象关系务必谨慎，因为我们经常会做出错误的假设。比如：</p>\n<p>哪怕一张餐桌也可能设计多个宴席（<em>在热门餐厅，“拼桌”很常见</em>）。进行设计时，你应该跟面试官探讨以下如何让你的设计做到一物多用。</p>\n</div>\n<h3 id=\"%E6%AD%A5%E9%AA%A44%3A-%E7%A0%94%E7%A9%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B7%A5%E4%BD%9C\" tabindex=\"-1\">步骤4: 研究对象的工作</h3>\n<p>到这一步，你的面向对象设计应该初具出行了。接下来，该想想对象可执行的关键动作以及对象之间的关系。你可能会发现自己遗漏了某些对象，这是就需要补全并更新设计。</p>\n<h2 id=\"%E9%80%92%E5%BD%92%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92\" tabindex=\"-1\">递归与动态规划</h2>\n<div class=\"info\">\n<p>当你听到的问题的：设计一个算法计算第 n 个。。。、列出前 n 个。。。、实现一个算法，计算所有。。。等，那么基本上这就是递归问题了。</p>\n</div>\n<h3 id=\"%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%8F%8A%E8%AE%B0%E5%BF%86%E6%B3%95\" tabindex=\"-1\">动态规划及记忆法</h3>\n<div class=\"alert\">\n<p>通常来说，动态规划就是使用递归算法发现重叠子问题（也就是重复的调用）。然后你可以缓存结果以备不时之需。</p>\n<p><spoiler>真的是说的简单。。做起来好难 QAQ </spoiler></p>\n</div>\n<div class=\"quote\">\n<p>つづく</p>\n</div>\n","slug":"学习笔记/程序员面试金典/ch7","published":true,"date":"2020-04-25T07:13:50.000Z","updated":"2020-05-26T06:26:49.000Z","path":"学习笔记/程序员面试金典/ch7/","api_path":"api/articles/学习笔记/程序员面试金典/ch7.json","keywords":null,"tags":[{"name":"读书笔记","path":"api/tags/读书笔记.json"},{"name":"flag","path":"api/tags/flag.json"},{"name":"程序员面试金典","path":"api/tags/程序员面试金典.json"}]},{"title":"ASUS ac86u 折腾手册","author":"Kuriko Moe (栗子Chan)","excerpt":"<p>记录一下自己是如何折腾 <code>ac86u</code> 的...</p>\n<div class=\"warning\">\n<p>然后 ac86u 在给家里配完路由器网关翻墙之后，果断被沉迷 y2b 的父上没收充公了。</p>\n</div>\n","render_content":"<p>记录一下自己是如何折腾 <code>ac86u</code> 的...</p>\n<div class=\"warning\">\n<p>然后 ac86u 在给家里配完路由器网关翻墙之后，果断被沉迷 y2b 的父上没收充公了。</p>\n</div>\n<!-- more -->\n<h2 id=\"ac86u-%E8%AE%BE%E7%BD%AE%E8%B0%83%E4%BC%98\" tabindex=\"-1\">ac86u 设置调优</h2>\n<div class=\"info\">\n<p>手册建立在已经开机，完成基本设置的情况下。</p>\n</div>\n<p>买 ac86u 主要看中了她的 cpu 处理能力以及 Merlin 系统的稳定性上。目前 ac86u 主要有两种系统，共 4 类：</p>\n<ul>\n<li>原厂系统，出厂自带\n<ul>\n<li>原厂 Koolshare 修改系统，主要是在原厂系统的基础上添加了软件中心</li>\n</ul>\n</li>\n<li>Meriln（梅林）系统，第三方根据原厂系统的代码修改而来\n<ul>\n<li>Merlin Koolshare 修改系统，主要是在 Merlin 系统的基础上添加了软件中心</li>\n</ul>\n</li>\n</ul>\n<p>从更新速度和更新频率上来讲：</p>\n<p>原厂系统 &gt; Merlin，koolshare 的修改版分别落后对应版本一段时间。</p>\n<div class=\"warning\">\n<p>由于只用过 Merlin 和 Merlin KS 修改版，因此不对原厂系统作评价。</p>\n</div>\n<h3 id=\"wi-fi-%E4%BC%98%E5%8C%96\" tabindex=\"-1\">Wi-Fi 优化</h3>\n<h4 id=\"2.4-ghz\" tabindex=\"-1\">2.4 GHz</h4>\n<p>刚开始打算让 2.4GHz 走低速广覆盖，IoT 友好方向设置，后来想了一下，本来选取「澳大利亚」之后，2.4GHz 的功率足以覆盖全屋了，没必要特意设置的更加偏向于广覆盖。</p>\n<p>于是干脆就继续往高速率去设置了。</p>\n<p><img src=\"https://kurikomoe-1300672427.image.myqcloud.com/images/ac86u/2.4Ghz.png\" alt=\"2.4GHz 设置图\" /></p>\n<h4 id=\"5ghz\" tabindex=\"-1\">5GHz</h4>\n<p>5GHz Wi-Fi 是无线传输的主力，因此打算把低速设备，例如：IoT，都踢到 2.4GHz 频段上面去。5GHz 采用最大化传输速度的设定：</p>\n<p><img src=\"https://kurikomoe-1300672427.image.myqcloud.com/images/ac86u/5ghz.png\" alt=\"5GHz 设置图\" /></p>\n<h4 id=\"%E9%92%88%E5%AF%B9-nintendo-switch-%E7%9A%84%E4%BC%98%E5%8C%96\" tabindex=\"-1\">针对 <code>Nintendo Switch</code> 的优化</h4>\n<p>由于 NS 的 5GHz Wi-Fi <a href=\"https://www.gcores.com/articles/25847\" target=\"_blank\" rel=\"noopener\">只支持少数几个信道</a>，在大陆的话，需要是 149 以下（不含）的频段，因此需要关闭路由器的自动 5GHz 频道，手动选取 Channel。</p>\n<p>扫描了一遍家附近的的 5GHz 覆盖，发现。。。。毕竟是郊区。真没几个 5GHz 的 Wi-Fi，那就随便用 Channel 48 算了。。。</p>\n<h4 id=\"%E3%80%8C%E9%AB%98%E7%BA%A7%E8%AE%BE%E7%BD%AE-%3E%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C-%3E%E4%B8%93%E4%B8%9A%E8%AE%BE%E7%BD%AE%E3%80%8D\" tabindex=\"-1\">「高级设置-&gt;无线网络-&gt;专业设置」</h4>\n<h5 id=\"%E5%8A%9F%E7%8E%87%E8%AE%BE%E7%BD%AE\" tabindex=\"-1\">功率设置</h5>\n<p>「高级设置-&gt;无线网络-&gt;专业设置」的最低下有区域设置，设置成美国或者澳大利亚能有 3 倍的功率提升。能有效提高 5GHz 的穿墙能力</p>\n<blockquote>\n<p>不过需要注意的是，这只提高了路由器发射端功率，对于设备的返程信号，仍然功率不足。</p>\n</blockquote>\n<h5 id=\"%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98\" tabindex=\"-1\">参数调优</h5>\n<p><strong>关闭</strong>漫游助手，在路由器调到高功率地区之后，路由器检测的客户端信号很低也不是影响发送数据。</p>\n<p><strong>关闭</strong>蓝牙共存（<strong>视情况</strong>)：家里的蓝牙设备不多，不需要 2.4GHz 让路。</p>\n<p><strong>启用</strong>无线传输公平性（<strong>视情况</strong>）：<a href=\"https://www.iplaysoft.com/fix-wifi-offline-issue.html\" target=\"_blank\" rel=\"noopener\">无线传输公平性的定义</a>，至少咱希望快速设备能尽可能的跑满带宽，不需要让路给慢速的 IoT 设备。</p>\n<h3 id=\"qos-%E8%AE%BE%E7%BD%AE\" tabindex=\"-1\">QoS 设置</h3>\n<div class=\"info\">\n<p>小知识：\nQoS 的设置的底层调用的是  <code>tc</code> 命令，可以用 <code>tc qdisc list</code> 来看具体设置了什么。</p>\n</div>\n<p>QoS 设置里面的注意点：</p>\n<ul>\n<li>国内的 <code>WAN packet overhead</code> 为 <code>PPPoE LLC/Snap</code>，<a href=\"http://koolshare.cn/thread-66442-1-1.html\" target=\"_blank\" rel=\"noopener\">资料来源</a></li>\n<li>上传带宽和下载带宽可以稍微多填一点，自动设置实际上是根据网络负载动态调解的，取历史最大网速作为 QoS 限制网速。</li>\n</ul>\n<p><img src=\"https://kurikomoe-1300672427.image.myqcloud.com/images/ac86u/qos.png\" alt=\"QoS 设置\" /></p>\n<div class=\"warning\">\n<p>QoS 设置与 iptables 设置似乎并不冲突。<strong>存疑</strong></p>\n</div>\n<h2 id=\"%E7%A7%91%E5%AD%A6%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE\" tabindex=\"-1\">科学相关设置</h2>\n<div class=\"alert\">\n<p>如果没有很好的 <code>Linux</code> 操作经验，建议直接使用 Koolshare 版系统的插件来实现某些科学需求，</p>\n</div>\n<div class=\"warning\">\n<p>以下操作需要有：<code>Linux 操作</code>，<code>iptables</code>，<code>ssh</code>，<code>git</code>，<code>bash &amp; script</code>等的前置知识。</p>\n</div>\n<h3 id=\"koolshare-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%8F%92%E4%BB%B6\" tabindex=\"-1\">Koolshare 科学上网插件</h3>\n<p>插件已经从<code>插件中心</code> 下架了，需要的可以去 Github Repo 自取</p>\n<p><a href=\"https://github.com/hq450/fancyss\" target=\"_blank\" rel=\"noopener\">传送门 hq450/fancyss</a></p>\n<h3 id=\"clash-%E5%8E%9F%E7%94%9F\" tabindex=\"-1\">Clash 原生</h3>\n<p>Clash 项目原生可执行文件：</p>\n<ul>\n<li>release <a href=\"https://github.com/Dreamacro/clash/releases\" target=\"_blank\" rel=\"noopener\">传送门</a></li>\n<li>tun 测试版 <a href=\"https://github.com/Dreamacro/clash/releases/tag/TUN\" target=\"_blank\" rel=\"noopener\">传送门</a></li>\n</ul>\n<div class=\"quote\">\n<p>つづく</p>\n</div>\n","slug":"ac86u-折腾手册","published":true,"date":"2020-04-23T02:07:21.000Z","updated":"2020-05-13T09:58:55.000Z","path":"ac86u-折腾手册/","api_path":"api/articles/ac86u-折腾手册.json","keywords":null,"tags":[{"name":"路由器","path":"api/tags/路由器.json"},{"name":"教程","path":"api/tags/教程.json"}]},{"title":"HyperJuice: World's First & Smallest 100W GaN USB-C Charger 评测","author":"Kuriko Moe (栗子Chan)","excerpt":"<p>作为「出门不做好万全准备会死星人」<spoiler>吐槽：您也是「ready perfectly の慎重勇者」？</spoiler> ，出门总是要带上。。。</p>\n<ul>\n<li>2w mAh PD 移动电源 + 1w mAh 移动电源（optional）</li>\n<li>65w PD 充电器  + 2口以上充电器（optional）</li>\n<li>超长 c2c PD 线 x1，USB-A to typec + microUSB +lighnting， C2L PD 线 x 1</li>\n</ul>\n<p>今天逛<code>v2ex</code>的时候，搜到了有人在问有没有 <code>100w GaN 充电器</code> ，发现有人推荐 <code>HyperJuice</code> 。决定下单搞一个，写个评测。</p>\n<p><spoiler> 然而刚在 <code>kickstarter</code> 上面下单，预计 6 月份能到就不错了。</spoiler></p>\n","render_content":"<p>作为「出门不做好万全准备会死星人」<spoiler>吐槽：您也是「ready perfectly の慎重勇者」？</spoiler> ，出门总是要带上。。。</p>\n<ul>\n<li>2w mAh PD 移动电源 + 1w mAh 移动电源（optional）</li>\n<li>65w PD 充电器  + 2口以上充电器（optional）</li>\n<li>超长 c2c PD 线 x1，USB-A to typec + microUSB +lighnting， C2L PD 线 x 1</li>\n</ul>\n<p>今天逛<code>v2ex</code>的时候，搜到了有人在问有没有 <code>100w GaN 充电器</code> ，发现有人推荐 <code>HyperJuice</code> 。决定下单搞一个，写个评测。</p>\n<p><spoiler> 然而刚在 <code>kickstarter</code> 上面下单，预计 6 月份能到就不错了。</spoiler></p>\n<!-- more -->\n<h1 id=\"%E4%BA%8B%E5%89%8D%E8%B0%83%E6%9F%A5\" tabindex=\"-1\">事前调查</h1>\n<blockquote>\n<p>然而还是掩盖不了咱冲动消费的事实</p>\n</blockquote>\n<p><img src=\"https://kurikomoe-1300672427.image.myqcloud.com/images/review/IMG_2932.png\" alt=\"IMG_2932\" /></p>\n<div class=\"quote\">\n<p>つづく</p>\n</div>\n","slug":"review/HyperJuice-World-s-First-Smallest-100W-GaN-USB-C-Charger-评测","published":true,"date":"2020-05-07T05:45:58.000Z","updated":"2020-05-13T09:58:39.000Z","path":"review/HyperJuice-World-s-First-Smallest-100W-GaN-USB-C-Charger-评测/","api_path":"api/articles/review/HyperJuice-World-s-First-Smallest-100W-GaN-USB-C-Charger-评测.json","keywords":null,"tags":[{"name":"评测","path":"api/tags/评测.json"},{"name":"GaN充电头","path":"api/tags/GaN充电头.json"}]}]}