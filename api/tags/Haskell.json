{"name":"Haskell","postlist":[{"title":"Real World Haskell 学习笔记","subtitle":"进度：FPを勉強していました","author":"Kuriko Moe (栗子Chan)","excerpt":"<p>人人都想学的 FP ！既然没有对象，那不妨试试函数式编程叭！</p>\n<p>内容提示：本篇 Blog 将会持续更新，记录本栗子从 0 到 1 的「Real World Haskell」学习</p>\n","render_content":"<p>人人都想学的 FP ！既然没有对象，那不妨试试函数式编程叭！</p>\n<p>内容提示：本篇 Blog 将会持续更新，记录本栗子从 0 到 1 的「Real World Haskell」学习</p>\n<!-- more -->\n<h1 id=\"day-1%EF%BC%8Cinstallation\" tabindex=\"-1\">Day 1，Installation</h1>\n<h2 id=\"%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E\" tabindex=\"-1\">环境说明</h2>\n<div class=\"warning\">\n<p>本部分可能需要根据 Haskell 的发展进行更新。 ---- by 栗子 2020/08/28</p>\n</div>\n<p>栗子使用的是 2018 款 MBP，i5 处理器，因此学习笔记基于<code>macOS</code>，但也不排除<code>Linux</code>环境下的一些操作。</p>\n<p>面对一个新语言，最重要的是学会如何安装。相较于 Rust 的一行代码解决 rustup + cargo 的美好安装体验，Haskel 的安装要稍微复杂一点。按照<a href=\"https://www.haskell.org/platform/mac.html\" target=\"_blank\" rel=\"noopener\">官网</a>上的说明，分为两个步骤，ghcup 和 stack。</p>\n<div class=\"info\">\n<p>The recommended way to install the components of the mac platform is using <a href=\"https://www.haskell.org/ghcup/\" target=\"_blank\" rel=\"noopener\">ghcup</a> to install ghc and cabal-install, and following the instructions at <a href=\"https://www.haskellstack.org\" target=\"_blank\" rel=\"noopener\">haskellstack.org</a> to install stack.</p>\n<p><strong>ghcup</strong> is an installer for the general purpose language Haskell</p>\n<p><strong>Stack</strong> is a cross-platform program for developing Haskell projects. It is aimed at Haskellers both new and experienced.</p>\n</div>\n<p>实际上，在安装第一步，小小的咱就冒出了一个大大的疑问。<code>ghcup</code> 和 <code>stack</code> 都是什么鬼。。按照 StackOverflow 上的描述，两者应该是 <code>rustup</code> 和 <code>cargo</code> 的关系。<a href=\"https://stackoverflow.com/questions/59030132/how-do-i-install-haskell-stack-on-mac\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<p>然而问题是，<code>ghcup</code> 在安装的时候，顺便送了你一个<code>cabal</code>，这玩意。。似乎也能用于管理项目。。。<a href=\"https://stackoverflow.com/questions/30913145/what-is-the-difference-between-cabal-and-stack\" target=\"_blank\" rel=\"noopener\">What is the difference between Cabal and Stack?</a></p>\n<p>不过无所谓了，现在推荐使用的还是<code>stack</code>。</p>\n<p>具体的安装方式的话，还是请参照对应的官网上的安装方法，防止咱的 Blog 内容过时带来意外的后果。</p>\n<p><code>ghcup</code> 安装传送门：<a href=\"https://www.haskell.org/ghcup/\" target=\"_blank\" rel=\"noopener\">https://www.haskell.org/ghcup/</a></p>\n<p><code>stack</code> 安装传送门：<a href=\"https://docs.haskellstack.org/en/stable/README/\" target=\"_blank\" rel=\"noopener\">https://docs.haskellstack.org/en/stable/README/</a></p>\n<h2 id=\"chapter-1%3A-getting-started\" tabindex=\"-1\">Chapter 1: Getting Started</h2>\n<p>论如何让<code>kuriko</code>成为你的<code>prompt</code>：</p>\n<pre><code class=\"language-haskell\">ghci&gt; :set prompt &quot;kuriko&gt; &quot;\nkuriko&gt; ...\n</code></pre>\n<h3 id=\"simple-arithmetic\" tabindex=\"-1\">Simple Arithmetic</h3>\n<p><code>Haskell</code> 支持中缀表达式的表示方式<code>(+) 2 2</code>。</p>\n<p><code>Haskell</code> 的单目运算符<code>-</code> 在表示负数的时候，需要加上括号<code>2 + (-3)</code>、<code>2*(-3)</code>之类的。。</p>\n<h3 id=\"boolean-logic-and-others\" tabindex=\"-1\">Boolean Logic and others</h3>\n<p>和类C的语言不同，<code>Haskell</code> 里面的 True 和 False 与数值等类型数据不能隐式转换。因此以下的表达式会触发异常：</p>\n<pre><code class=\"language-haskell\">kuriko&gt; True &amp;&amp; 1\n\n&lt;interactive&gt;:47:9: error:\n    • No instance for (Num Bool) arising from the literal ‘1’\n    • In the second argument of ‘(&amp;&amp;)’, namely ‘1’\n      In the expression: True &amp;&amp; 1\n      In an equation for ‘it’: it = True &amp;&amp; 1\n</code></pre>\n<div class=\"warning\">\n<p>和 <code>C/CPP</code> 里面有很大的不同，<code>Haskell</code> 中的“不等于”（is not equal to）使用的运算符为<code>/=</code>（来自于数学的  \\(\\not=\\) 符号）</p>\n<p>另一个不同点在于，<code>Haskel</code> 使用 <code>not</code> 作为逻辑取反，而 <code>C/CPP</code> 通常使用 <code>!</code> 运算符</p>\n<p>另外，<code>^</code> 在<code>Haskell</code>里面代表的是<code>次方</code></p>\n<pre><code class=\"language-haskell\">kuriko&gt; 2^10\n1024\n\nkuriko&gt; :info (^)\n(^) :: (Num a, Integral b) =&gt; a -&gt; b -&gt; a       -- Defined in ‘GHC.Real’\ninfixr 8 ^\n</code></pre>\n</div>\n<h3 id=\"list\" tabindex=\"-1\">List</h3>\n<p><code>List[1, 2, 3]</code> 中的元素必须是相同类型。同时<strong>不同于</strong> Python 等动态语言（甚至不同于 C++11），列表的最后不能是 <code>,</code>。</p>\n<pre><code class=\"language-haskell\">kuriko&gt; [1, 2, 3, &quot;hello&quot;]\n\n&lt;interactive&gt;:51:2: error:\n    • No instance for (Num [Char]) arising from the literal ‘1’\n    • In the expression: 1\n      In the expression: [1, 2, 3, &quot;hello&quot;]\n      In an equation for ‘it’: it = [1, 2, 3, ....]\n      \nkuriko&gt; [1, 2, 3,]\n\n&lt;interactive&gt;:52:10: error: parse error on input ‘]’\n</code></pre>\n<h4 id=\"enumeration-%E7%89%B9%E6%80%A7\" tabindex=\"-1\">Enumeration 特性</h4>\n<p>类似于<code>rust</code>中的 <code>0..233</code> （话说。。怕不是 <code>rust</code> 抄的），<code>Haskell</code> 中支持在<code>List</code>中利用 <code>..</code> 做枚举。</p>\n<pre><code class=\"language-haskell\">kuriko&gt; [1..10]\n[1,2,3,4,5,6,7,8,9,10]\nkuriko&gt; [10..1]\n[]\nkuriko&gt; [10,9..1]\n[10,9,8,7,6,5,4,3,2,1]\nkuriko&gt; ['a'..'z']\n&quot;abcdefghijklmnopqrstuvwxyz&quot;\nkuriko&gt; ['z', 'x'..'a']\n&quot;zxvtrpnljhfdb&quot;\n</code></pre>\n<div class=\"info\">\n<p>List 中前两个元素可以用来指定枚举的步长： <code>[0, 2..233]</code></p>\n</div>\n<h4 id=\"list-%E6%93%8D%E4%BD%9C\" tabindex=\"-1\">List 操作</h4>\n<p><code>(++)</code>操作符用于连接两个 List，<code>(:)</code> 操作符用于将元素合入 List 中</p>\n<div class=\"warning\">\n<p>根据定义：</p>\n<pre><code class=\"language-haskell\">kuriko&gt; :info :\ndata [] a = ... | a : [a]       -- Defined in ‘GHC.Types’\ninfixr 5 :\n</code></pre>\n<p><code>(:)</code> 必须是元素在前，列表在后。如果想在尾端插入元素，可以：</p>\n<pre><code class=\"language-haskell\">kuriko&gt; [1,2] ++ 3 : []\n[1,2,3]\n</code></pre>\n</div>\n<h3 id=\"string-and-characters\" tabindex=\"-1\">String and Characters</h3>\n<p><code>putStrLn</code> 是输出字符串用的。而<code>String</code>本质上是 List of Characters。</p>\n<pre><code class=\"language-haskell\">kuriko&gt; &quot;abcde&quot;\n&quot;abcde&quot;\nkuriko&gt; ['a', 'b', 'c', 'd', 'e']\n&quot;abcde&quot;\n</code></pre>\n<p>因此有如下很有趣的操作：</p>\n<pre><code class=\"language-haskell\">kuriko&gt; &quot;&quot; == []\nTrue\nkuriko&gt; 'a' : &quot;bc&quot;\n&quot;abc&quot;\nkuriko&gt; &quot;ab&quot; ++ &quot;cd&quot;\n&quot;abcd&quot;\n</code></pre>\n<div class=\"extra\">\n<p><spoiler>啊，伟大的 Javascript == 真值图呀。</spoiler></p>\n<p><img src=\"https://kurikomoe-1300672427.image.myqcloud.com/images/haskell/relational_in_js.png\" alt=\"relational_in_js\" /></p>\n</div>\n<h2 id=\"hello%2C-haskell-world!\" tabindex=\"-1\">Hello, Haskell World!</h2>\n<pre><code class=\"language-haskell\">--- file: helloworld.hs\n--- author: kuriko\n--- date: 2020/08/28\n\nmain = interact wordCount\n  where wordCount input = show (length (lines input)) ++ &quot;\\n&quot;\n</code></pre>\n<pre><code class=\"language-bash\">$ runghc helloworld.hk &lt; test.txt\n</code></pre>\n<h1 id=\"day-2%3A-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C...%E6%91%B8%E9%B1%BC\" tabindex=\"-1\">Day 2: 基本概念和...摸鱼</h1>\n<h2 id=\"chapter-2%3A-types-and-functions\" tabindex=\"-1\">Chapter 2: Types and Functions</h2>\n<p>在 Haskell 中，类型是：强类型(Strong)，静态(Static)和可以自动推断(Inferred)的。</p>\n<ul>\n<li>强类型 (Strong) 意味着 Haskell 的类型系统会拒绝类似于将 String 赋值给 Int 这种无意义的操作。换句话说，Haskell 编译器只接受 <em>well typed</em>，对于 <em>ill typed</em> 会触发 <em>type error</em>。\n强类型的第二个特性是 Haskell 的编译器不会自动对变量进行强转 (casting or conversion)。例如 C 会对 int -&gt; float 进行隐式转换，但是 Haskell 要求必须显式声明。\n因此，C 中常见的黑魔法操作：将一块 bytes buffer 强制认为是某种复杂的数据结构从而避免数据的拷贝操作。这种做法在 Haskell 中则需要进行部分拷贝。</li>\n<li>静态类型  (Static Types) 意味着编译器在编译时、程序运行前能够知道所有值的类型和表达式。</li>\n<li>类型推断 (Type Inference) 意味着许多地方的类型声明可以由编译器自行推断出来。</li>\n</ul>\n<h3 id=\"%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B\" tabindex=\"-1\">基础类型</h3>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>类型</th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Char</td>\n<td>Unicode 字符</td>\n<td></td>\n</tr>\n<tr>\n<td>Bool</td>\n<td>True &amp; False</td>\n<td></td>\n</tr>\n<tr>\n<td>Int</td>\n<td>有符号，固定宽度的整型值，取决于系统最长的 <code>Native</code> 整型，例如 32 位机为 32 位整型。Haskell 保证整型值的位宽不小于 28bits</td>\n<td></td>\n</tr>\n<tr>\n<td>Integer</td>\n<td>有符号无限位宽</td>\n<td></td>\n</tr>\n<tr>\n<td>Double</td>\n<td>浮点数，通常是 64bits，使用系统的 <code>Native</code> 表示</td>\n<td>Float  也存在，但是不鼓励使用，Haskell 更多的在优化 Double 的性能。</td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"info\">\n<p>注意，类型是大写字母开头。</p>\n</div>\n<p>可以使用 <code>expression :: MyTepe</code> 表示该表达式是 <code>MyType</code> 类型的。其中 <code>:: MyType</code> 可以略去，由 Haskell 编译器自行推导。</p>\n<pre><code class=\"language-haskell\">GHCi, version 8.8.4: https://www.haskell.org/ghc/  :? for help\nPrelude&gt; :set prompt &quot;Kuriko&gt; &quot;\nKuriko&gt; :type 'a'\n'a' :: Char\nKuriko&gt; 'a' :: Char\n'a'\nKuriko&gt; [1, 2, 3] :: Int\n\n&lt;interactive&gt;:4:1: error:\n    • Couldn't match expected type ‘Int’ with actual type ‘[Integer]’\n    • In the expression: [1, 2, 3] :: Int\n      In an equation for ‘it’: it = [1, 2, 3] :: Int\nKuriko&gt; [1, 2, 3] :: List[Int]\n\n&lt;interactive&gt;:5:14: error:\n    Not in scope: type constructor or class ‘List’\nKuriko&gt; [1, 2, 3] :: [Int]\n[1,2,3]\nKuriko&gt; [1, 2, 3] :: [Double]\n[1.0,2.0,3.0]\n</code></pre>\n<h3 id=\"function-application\" tabindex=\"-1\">Function Application</h3>\n<p>在 Haskell 中调用函数，需要写出函数名，并依次列出其参数。</p>\n<pre><code class=\"language-haskell\">Kuriko&gt; odd 3\nTrue\nKuriko&gt; even 6\nTrue\nKuriko&gt; compare 2 3\nLT\n</code></pre>\n<p>利用<code>括号</code>可以表明结合关系：</p>\n<pre><code class=\"language-haskell\">Kuriko&gt; compare 2.0 sqrt 3\n\n&lt;interactive&gt;:20:1: error:\n    • Couldn't match expected type ‘Integer -&gt; t’\n                  with actual type ‘Ordering’\n    • The function ‘compare’ is applied to three arguments,\n      but its type ‘(Double -&gt; Double) -&gt; (Double -&gt; Double) -&gt; Ordering’\n      has only two\n      In the expression: compare 2.0 sqrt 3\n      In an equation for ‘it’: it = compare 2.0 sqrt 3\n    • Relevant bindings include it :: t (bound at &lt;interactive&gt;:20:1)\nKuriko&gt; compare 2 (sqrt 3)\nGT\n</code></pre>\n<div class=\"warning\">\n<p>如果没有括号， <code>compare 2 sqrt 3</code> 意思是将三个参数<code>2</code>，<code>sqrt</code>，<code>3</code> 传给函数 <code>compare</code>。显然这是不对的。</p>\n</div>\n<h3 id=\"%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9Alists-and-tuples\" tabindex=\"-1\">复合数据类型：Lists and Tuples</h3>\n<h4 id=\"lists\" tabindex=\"-1\">Lists</h4>\n<p>在 Haskell 中最常见的复合 (Composite) 数据类型是 Lists and Tuples。</p>\n<p>由于 List 中可以承载各种数据类型（但是一旦确定，List 中元素的数据类型必须全部相同），因此 List Type 是 （不定形）<code>polymorphic</code> 的。当我们写出一个 polymorphic type 的时候，可以用 <code>type variable</code> 来表示，规定用小写字母表示。</p>\n<div class=\"explain\">\n<p>Type Name 必须用以大写字母开头：Int</p>\n<p>Type Variable 必须用小写字母开头</p>\n<p>[[Int]] is a list of lists int</p>\n</div>\n<h4 id=\"tuples\" tabindex=\"-1\">Tuples</h4>\n<p>元组是固定大小的数据的集合，允许将不同的数据类型组合在一起。</p>\n<p>其中 <code>()</code> 为特殊的类型，代表零元素的元组。通常被叫做 &quot;unit&quot;，在 C 中可以等价于 <code>void</code></p>\n<pre><code class=\"language-haskell\">Kuriko&gt; :type (1, &quot;2&quot;, (1, True))\n(1, &quot;2&quot;, (1, True)) :: (Num a1, Num a2) =&gt; (a1, [Char], (a2, Bool))\n\nKuriko&gt; :type ()\n() :: ()\n</code></pre>\n<div class=\"info\">\n<p>Haskell 中不存在单元素元组，2-tuple 称之为 <code>pair</code>，3-tuple 称之为 (triple)。</p>\n</div>\n<h3 id=\"functions-over-lists-and-tuples\" tabindex=\"-1\">Functions over Lists and Tuples</h3>\n<div class=\"warning\">\n<p>注意 <code>fst</code> 和 <code>snd</code> 只能作用于 <code>pair</code> 上</p>\n</div>\n<pre><code class=\"language-haskell\">Kuriko&gt; head [1, 2, 3, 4]\n1\nKuriko&gt; tail [1, 2, 3, 4]\n[2,3,4]\nKuriko&gt; fst [1, 2, 3, 4]\n\n&lt;interactive&gt;:34:5: error:\n    • Couldn't match expected type ‘(a, b0)’\n                  with actual type ‘[Integer]’\n    • In the first argument of ‘fst’, namely ‘[1, 2, 3, 4]’\n      In the expression: fst [1, 2, 3, 4]\n      In an equation for ‘it’: it = fst [1, 2, 3, ....]\n    • Relevant bindings include it :: a (bound at &lt;interactive&gt;:34:1)\nKuriko&gt; fst (1, 2, 3)\n\n&lt;interactive&gt;:35:5: error:\n    • Couldn't match expected type ‘(a, b0)’\n                  with actual type ‘(Integer, Integer, Integer)’\n    • In the first argument of ‘fst’, namely ‘(1, 2, 3)’\n      In the expression: fst (1, 2, 3)\n      In an equation for ‘it’: it = fst (1, 2, 3)\n    • Relevant bindings include it :: a (bound at &lt;interactive&gt;:35:1)\nKuriko&gt; fst (1, 2)\n1\nKuriko&gt; snd (1, 2)\n2\n</code></pre>\n<h3 id=\"passing-an-expression-to-a-function\" tabindex=\"-1\">Passing an Expression to a Function</h3>\n<p>在 Haskell 中，函数调用是左结合的，因此 <code>a b c d</code> 等价于 <code>(((a b) c ) d)</code> 所以在改变结合顺序的时候，需要显式的加上括号：</p>\n<pre><code class=\"language-haskell\">Kuriko&gt; drop 3 [1, 2, 3, 4]\n[4]\nKuriko&gt; head (drop 2 [1, 2, 3, 4])\n3\n</code></pre>\n<h3 id=\"function-types-and-purity\" tabindex=\"-1\">Function Types and Purity</h3>\n<div class=\"info\">\n<p>Purity，函数式编程里面的概念，纯函数。</p>\n</div>\n<p>首先看一下函数的类型：</p>\n<pre><code class=\"language-haskell\">Kuriko&gt; :type lines\nlines :: String -&gt; [String]\n\nKuriko&gt; lines &quot;abc\\n111\\n$$$&quot;\n[&quot;abc&quot;,&quot;111&quot;,&quot;$$$&quot;]\n</code></pre>\n<p>可以看出 <code>lines</code> 是一个接收 <code>String</code> 吐出 <code>[String]</code> 的函数。</p>\n<h4 id=\"%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0%EF%BC%9A\" tabindex=\"-1\">什么是纯函数：</h4>\n<p>在解释纯函数之前，请允许栗子先引入一个概念：<code>side effect</code>：</p>\n<div class=\"define\">\n<h5 id=\"side-effect-%E5%89%AF%E4%BD%9C%E7%94%A8\" tabindex=\"-1\">Side Effect 副作用</h5>\n<p>副作用意味着函数的行为和系统的全局状态相挂钩。例如，如果一个函数在执行中依赖于某个全局变量，那么如果某些代码改变了全局状态，则这个函数即使给定了相同的输入参数，也可能会输出不同的结果。因此我们称这个函数是有 <code>side effect</code> 的（即使这个函数自身没有修改过全局变量）</p>\n</div>\n<p>因此基于<code>side effect</code>我们有：</p>\n<div class=\"define\">\n<h4 id=\"%E7%BA%AF%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%9E%E7%BA%AF%E5%87%BD%E6%95%B0-(pure-and-impure)\" tabindex=\"-1\">纯函数与非纯函数 (pure and impure)</h4>\n<p>如果一个函数没有任何的 <code>side effects</code> ，函数的结果完全取决与其参数输入，则该函数是 <code>pure</code>，否则是 <code>impure</code>。</p>\n</div>\n<p>区分 <code>pure</code> and <code>impure</code> 的好处是，Haskell 的类型系统会自动防止我们混用 <code>pure</code> 和 <code>impure</code> 代码。</p>\n<div class=\"extra\">\n<p>函数式编程的哲学思想是：假定副作用是造成不当行为的主要原因，因此如果我们可以控制 impure function 的使用，就能防止 bug 的发生。</p>\n<p>我们确实生活在一个需要 impure 的世界，但是我们可以尽量小心地去和 impure 的东西交互。</p>\n<spoiler>\n<p>栗子姬の吐槽：隔壁的 rust 可能欲言又止 23333。</p>\n<div class=\"quote\">\n<p>世界是 unsafe 的，我们并不是要禁止 unsafe，但是需要小心的区分出 safe 和 unsafe 的边界。</p>\n</div>\n</div>\n</spoiler>\n<p>判断一个函数是不是 <code>pure</code> 的，可以根据函数签名来判断：</p>\n<pre><code class=\"language-haskell\">Kuriko&gt; :type readFile\nreadFile :: FilePath -&gt; IO String\n</code></pre>\n<p><code>IO</code> 代表函数存在 side effect。</p>\n<h3 id=\"%E6%BA%90%E6%96%87%E4%BB%B6%E5%92%8C%E7%AE%80%E5%8D%95%E5%87%BD%E6%95%B0\" tabindex=\"-1\">源文件和简单函数</h3>\n<p>下面我们进入「如何撰写一个简单的函数」的部分。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-08-31\n\nadd a b = a + b\n\n-------------\nGHCi, version 8.8.4: https://www.haskell.org/ghc/  :? for help\nPrelude&gt; :set prompt kuriko &gt;\nkuriko &gt;:load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\nkuriko &gt;add 1 2\n3\n</code></pre>\n<h3 id=\"%E5%8F%98%E9%87%8F-variable\" tabindex=\"-1\">变量 Variable</h3>\n<p>在 Haskell 中，变量实际上是绑定了一个表达式，和传统的编程语言不同，变量并不代表任何一个「存储空间位置」，因此实际上我们并不能改变变量的值，再次定义变量会导致重复声明的错误。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-08-31\n\nx = 10\nx = 11\n\n-------------\nkuriko &gt;:load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\n\nmain.hs:6:1: error:\n    Multiple declarations of ‘x’\n    Declared at: main.hs:5:1\n                 main.hs:6:1\n  |\n6 | x = 11\n  | ^\nFailed, no modules loaded.\n\n</code></pre>\n<h3 id=\"condition-evaluation\" tabindex=\"-1\">Condition Evaluation</h3>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-08-31\n\nmyDrop n xs = if n &lt;= 0 || null xs\n              then xs\n              else myDrop(n-1) (tail xs)\n--------------\nkuriko &gt;:load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\nkuriko &gt;myDrop 2 &quot;123456&quot;\n&quot;3456&quot;\nkuriko &gt;:type null\nnull :: Foldable t =&gt; t a -&gt; Bool\nkuriko &gt;null &quot;t&quot;\nFalse\nkuriko &gt;null &quot;&quot;\nTrue\nkuriko &gt;\n</code></pre>\n<div class=\"info\">\n<ol>\n<li>\n<p><code>xs</code> 代表的 <code>plure of x</code></p>\n</li>\n<li>\n<p>因为 Haskell 是面向表达式的语言 (expression-oriented) 所以 if 这个 expression 如果只有 then 而没有 else 是没有意义的。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-08-31\n\nmyDrop n xs = if n &lt;= 0 || null xs\n              then xs\n\n--------------\nkuriko &gt;:load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\n\nmain.hs:7:1: error:\n    parse error (possibly incorrect indentation or mismatched brackets)\nFailed, no modules loaded.\n</code></pre>\n</li>\n</ol>\n</div>\n<h3 id=\"lazy-evaluation-and-short-circuiting\" tabindex=\"-1\">Lazy Evaluation and Short-circuiting</h3>\n<p>由于 Haskell 语言 Lazy Evaluation 的特点，Haskell 天生具有 Short-circuiting 的特性。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-08-31\n\nnewOr a b = if a\n            then a\n            else b\n---------\nkuriko &gt;newOr True (length [1..] &gt; 0)\nTrue\n</code></pre>\n<p>正常来讲 <code>length [1..] &gt; 0</code> 会因为尝试计算无限长的列表 <code>[1..]</code>而死循环，但是因为 <code>a</code> 永远为 <code>True</code> 导致 表达式 <code>b</code> 不会被计算。因此程序不会死机。</p>\n<h3 id=\"polymorphism-in-haskell\" tabindex=\"-1\">Polymorphism in Haskell</h3>\n<p>当函数的签名存在 Type Variable 的时候，说明她的某些参数可以是任意类型的。这种函数称之为泛函(?)</p>\n<p>举例来说 <code>:type last</code> 的签名是 <code>last :: [a] -&gt; a</code> 这种被称之为 <code>parametric polymorphism</code></p>\n<p>当我们看到一个泛型形参的时候，我们可以肯定「函数无法判断该参数的真正类型」或者「无法操纵该变量的类型」。因此对于函数来讲，这个变量是一个「黑盒」状态。</p>\n<div class=\"info\">\n<p>和其他语言不同，Haskell 不存在：</p>\n<ul>\n<li>子类泛型</li>\n<li>隐式转换泛型，ie 编译器自动进行的 int 和 float 等数值之间的转换。</li>\n</ul>\n</div>\n<p>举一个栗子：</p>\n<pre><code class=\"language-haskell\">kuriko &gt;:type fst\nfst :: (a, b) -&gt; a\n</code></pre>\n<p>对于函数 <code>fst</code> 来讲，其接受一个 pair，同时 pair 的元素的类型可以不同（也可以相同），因为 fst 并不知道 a 和 b 的具体情况，因此她能做的只有返回 a 类型的元素这一件事情。即返回元组的第一个元素。</p>\n<h3 id=\"%E5%A4%9A%E5%BD%A2%E5%8F%82%E5%87%BD%E6%95%B0%E7%9A%84%E7%AD%BE%E5%90%8D\" tabindex=\"-1\">多形参函数的签名</h3>\n<p>对于多形参的函数，举个栗子：</p>\n<pre><code class=\"language-haskell\">kuriko &gt;:type newOr\nnewOr :: Bool -&gt; Bool -&gt; Bool\n</code></pre>\n<p><code>-&gt;</code> 是右结合的，因此上面的等价于 <code>Bool -&gt; (Bool -&gt; Bool)</code>。可以理解为，吃进去一个 Bool，吐出一个「吃进去一个 Bool 吐出一个 Bool」的函数 <spoiler>（套。。。。套娃！）</spoiler></p>\n<div class=\"alert\">\n<p>这种套娃逻辑会对以后的函数编程思想有极大的影响，之后的「Partial Function Application and Currying（偏函数和柯里化）」会讲到。</p>\n</div>\n<h1 id=\"day-3%2C-step-into-the-hell\" tabindex=\"-1\">Day 3, Step into the HELL</h1>\n<div class=\"info\">\n<p>今天开始学习的时候有点困。。打算看看<code>Haskell</code>转换一下心情。</p>\n</div>\n<h2 id=\"chapter-3%3A-defining-types%2C-streamlining-functions\" tabindex=\"-1\">Chapter 3: Defining Types, Streamlining Functions</h2>\n<h3 id=\"%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\" tabindex=\"-1\">定义新的数据类型</h3>\n<p>以一个书店的数据为例：</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\ndata BookInfo = Book Int String [String]\n                deriving (Show)\n</code></pre>\n<p><code> data BookInfo</code> 定义新类型的名字为 <code>BookInfo</code> （由于是定义了一个新的 Type，所以必须首字母大写），称之为 <code>Type Constructor</code>。</p>\n<pre><code class=\"language-haskell\">kuriko&gt; :load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\n\nmain.hs:5:6: error:\n    Malformed head of type or class declaration: bookInfo\n  |\n5 | data bookInfo = Book Int String [String]\n  |      ^^^^^^^^\nFailed, no modules loaded.\n</code></pre>\n<p><code>Book</code> 是 <code>value constructor</code>（有时候也叫做 data constructor）。和 <code>Type</code> 类型一样，也需要首字母大写。</p>\n<p><code>Book</code> 之后的 <code>Int, String, [String]</code> 是 <code>components of the type</code> 在 Haskell 中和其他语言中的结构体或类一样，用作数据的存放位置 (slot)。</p>\n<p>本例子中，<code>Int</code> 用来表示书的标识，<code>String</code> 标识书名，<code>[String]</code> 标识作者的名字。</p>\n<p>注意，即使我们定义了一个仅名字不同的数据类型：<code>data MagazineInfo  = Magazine Int String [String]</code> 两者也属于不同的数据类型。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-01\n\ndata BookInfo = Book Int String [String]\n                deriving (Show)\n\nmyInfo = Book 114514 &quot;Screaming&quot; [&quot;Senpai&quot;, &quot;Kuriko&quot;]\n---------------\nKuriko&gt; :load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\nKuriko&gt; :type myInfo\nmyInfo :: BookInfo\nKuriko&gt; myInfo\nBook 114514 &quot;Screaming&quot; [&quot;Senpai&quot;,&quot;Kuriko&quot;]\n</code></pre>\n<h3 id=\"naming-types-and-values\" tabindex=\"-1\">Naming Types and Values</h3>\n<p>Type Contructor 和 Value Constructor 可以是相同的名字，因为 Type Constructor 只会在定义 type 和 type 签名的时候使用。Value Constructor only in actual code。由于使用的环境不同，两者不会产生歧义。</p>\n<h3 id=\"type-synonyms%EF%BC%88%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%EF%BC%89\" tabindex=\"-1\">Type Synonyms（类型别名）</h3>\n<pre><code class=\"language-haskell\">type CustomerID = Int\ntype ReviewBody = String\n\ndata BetterReview = BetterReview BookInfo CustomerID ReviewBody\n\ntype BookRecord = (BookInfo, BookReview)\n</code></pre>\n<div class=\"alert\">\n<p>使用 <code>type</code> 定义的数据类型仅仅是别名。。两者其实是相同的数据类型。<code>type synonyms</code> 的作用仅仅是提高代码的可读性。</p>\n</div>\n<h3 id=\"algebraic-data-types-%EF%BC%88%E4%BB%A3%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%89\" tabindex=\"-1\">Algebraic Data Types （代数数据类型）</h3>\n<pre><code class=\"language-haskell\">data Bool = False | True\n</code></pre>\n<p><code>Bool</code> 是最简单和常用的 <code>algebraic data type</code>，<s>ADT</s> <code>Algebraic Data Type</code> 可以有多个<code>value constructor</code>。每个 <code>value constructor</code> 用 <code>|</code> 分割。</p>\n<p>:::error</p>\n<p>Algebraic Data Type 不能简称为 ADT，因为 ADT 通常指 Abstract Data Type。</p>\n<p>:::</p>\n<pre><code class=\"language-haskell\">data BillingInfo = CreditCard CardNumber CardHolder Address\n                 | CashOnDelivery\n                 | Invoice CustomID\n                 deriving (Show)\n</code></pre>\n<div class=\"info\">\n<p>实际上我们可以认为所有的 <code>data</code> 定义的数据类型都是 <code>algebraic data type</code>，一些是单分支，一些是多分支的而已。</p>\n</div>\n<h3 id=\"pattern-matching\" tabindex=\"-1\">Pattern Matching</h3>\n<p>在讲完如何生成 <code>algebraic data type</code> 之后，现在开始讨论如何使用这些数据。有两个要点：</p>\n<ul>\n<li>如果类型有多个 <code>value constructor</code>，我们需要知道数据是由哪个 <code>value constructor</code> 生成的。</li>\n<li>如果数据有多个 <code>data components</code> 我们需要获取各个数据的方法。</li>\n</ul>\n<p>以 <code>Not</code> 函数为例：</p>\n<pre><code class=\"language-haskell\">myNot True = False\nmyNot False = True\n</code></pre>\n<div class=\"explain\">\n<p>这里看起来可能有些奇怪，似乎我们定义了两个 myNot 函数。实际上这是因为 Haskell 允许我们定义函数为「一系列等式」：这两个语句在定义相同函数在不同输入状态下的行为。</p>\n</div>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-01\n\nmyNot True = False\nmyNot False = True\nmyNot a = True\n----------\nKuriko&gt; :load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\n\nmain.hs:7:1: warning: [-Woverlapping-patterns]\n    Pattern match is redundant\n    In an equation for ‘myNot’: myNot a = ...\n  |\n7 | myNot a = True\n  | ^^^^^^^^^^^^^^\nOk, one module loaded.\nKuriko&gt; myNot a\n\n&lt;interactive&gt;:20:7: error: Variable not in scope: a :: Bool\nKuriko&gt; myNot 123\n\n&lt;interactive&gt;:21:7: error:\n    • No instance for (Num Bool) arising from the literal ‘123’\n    • In the first argument of ‘myNot’, namely ‘123’\n      In the expression: myNot 123\n      In an equation for ‘it’: it = myNot 123\nKuriko&gt; myNot True\nFalse  \n</code></pre>\n<p>下面分析一个更加复杂的栗子：</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-01\n\nsumList (x:xs) = x + sumList xs\nsumList [] = 0\n----------------\nKuriko&gt; :load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\nKuriko&gt; sumList [1, 2, 3, 4, 5]\n15\nKuriko&gt; :type sumList\nsumList :: Num p =&gt; [p] -&gt; p\n</code></pre>\n<div class=\"explain\">\n<p><code>[1, 2]</code> 是 <code>(1:(2:[]))</code> 的简写</p>\n<p><code>(x:xs)</code> 中 <code>:</code> 是 <code>familiar list constructor</code> ，换句话说，模式匹配的结果为：</p>\n<ul>\n<li>\n<p>x = 1, xs = (2:[])</p>\n</li>\n<li>\n<p>所以，其实写成如下也是可以的：</p>\n<pre><code class=\"language-haskell\">sumList (a:b) = a + sumList b\nsumList [] = 0\n</code></pre>\n</li>\n</ul>\n</div>\n<div class=\"alert\">\n<p>注意，定义是顺序有关的，Haskell 严格按照从上到下的顺序解析定义，找到第一个匹配就会停止匹配。</p>\n</div>\n<h4 id=\"construction-and-deconstruction\" tabindex=\"-1\">Construction and Deconstruction</h4>\n<p>Pattern Matching 可以认为是 <code>Construction</code> 的反过程，可以被认为是 <code>deconstruction</code>。但是注意的是，和 OOP 语言不同，<code>deconstruction</code> 并不对应 <code>destroyer</code> （析构器）的意思，只是单纯的将元素解包找出内部的元素。</p>\n<h4 id=\"further-adventures\" tabindex=\"-1\">Further Adventures</h4>\n<p>一个很复杂的栗子：</p>\n<pre><code class=\"language-haskell\">complicated (True, a, x:xs, 5) = (a, xs)\n-----------\nKuriko&gt; :load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\nKuriko&gt; complicate True, 233, [1, 2, 3, 4], 5\n\n&lt;interactive&gt;:32:16: error: parse error on input ‘,’\nKuriko&gt; complicate (True, 233, [1, 2, 3, 4], 5)\n(233,[2,3,4])\n</code></pre>\n<div class=\"alert\">\n<p>第一次 <code>complicate True, 233, [1, 2, 3, 4], 5</code> 不能成功匹配是因为 <code>[1, 2, 3, 4]</code> 实际上是 <code>(1:(2:(3:(4:(5:[]))))</code> 的简写，很明显这个并不能直接对应到 <code>x:xs</code> 上。</p>\n</div>\n<h4 id=\"%E9%80%9A%E9%85%8D%E7%AC%A6%E6%A8%A1%E5%BC%8F\" tabindex=\"-1\">通配符模式</h4>\n<p>如果我们不关心某些模式，可以用 <code>_</code> 来替代。这个符号叫做通配符。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-01\n\ntype Id = Int\ntype Book = String\ntype Title = String\ntype Author = [String]\n\ngetID (id, book, title, author) = id\nsimpGetId (id, _, _, _) = id\n\n-------------\nKuriko&gt; :load main.hs\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\nKuriko&gt; getID(1, &quot;hi&quot;, &quot;Hello&quot;, [&quot;a&quot;, &quot;b&quot;])\n1\n</code></pre>\n<h4 id=\"exhaustive-patterns-and-wild-cards\" tabindex=\"-1\">Exhaustive Patterns and Wild Cards</h4>\n<p>小 Trick，我们可以利用 <code>_</code> 来匹配最终表达式。</p>\n<pre><code class=\"language-haskell\">goodExample (x:xs) = x + goodExample xs\ngoodExample _ = 0\n</code></pre>\n<h3 id=\"record-syntax\" tabindex=\"-1\">Record Syntax</h3>\n<p>给每一个 <code>Data Type</code> 写访问器。是一个繁琐但是必须的事情，但是 Haskell 提供了一个语法糖来处理部分代码。</p>\n<pre><code class=\"language-haskell\">data Customer = Customer {\n  customerID :: CustomID,\n  customerName :: String,\n  customerAddress :: Address,\n} deriving (Show)\n\n------ 上下两种表达等价，显示表达访问器\n\ndata Customer = Customer Int String [String]\n                deriving (Show)\ncustomerID :: Customer -&gt; Int\ncustomerID (Customer id _ _) = id\n\ncustomerName :: Customer -&gt; String\ncustomerName (Customer _ name _) = name\n\ncustomerAddress :: customerAddress -&gt; [String]\ncustomerAddress (Customer _ _ address) = address\n\n----- 使用栗子\n\ncustomer1 = Customer 114514 &quot;Kuriko Moe&quot; [&quot;N/A&quot;, &quot;Mars&quot;]\n\ncustomer2 = Customer {\n    customerID = 114514,\n    customerAddress = [&quot;N/A&quot;, &quot;Mars&quot;],\n    customerName = &quot;Kuriko Moe&quot;\n}\n</code></pre>\n<h3 id=\"parameterized-types-(%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B)\" tabindex=\"-1\">Parameterized Types (参数化类型)</h3>\n<p><code>Prelude</code> 中定义了一个名叫 <code>Maybe</code> 的类型，用来表示存在或不存在。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-01\n\ndata MyMaybe a = MyJust a\n               | MyNothing\n               deriving (Show)\n\nsomeBool = MyJust True\nsomeString = MyNothing\n-----------\nPrelude&gt; :load main\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\n*Main&gt; :type MyMaybe\n\n&lt;interactive&gt;:1:1: error: Data constructor not in scope: MyMaybe\n*Main&gt; :type MyJust\nMyJust :: a -&gt; MyMaybe a\n*Main&gt; :type MyNothing\nMyNothing :: MyMaybe a\n*Main&gt; :type someBool\nsomeBool :: MyMaybe Bool\n*Main&gt; myJust True\nTrue\n*Main&gt; someBool\nMyJust True\n*Main&gt; Just (Just (Just 114514))\nJust (Just (Just 114514))\n</code></pre>\n<div class=\"explain\">\n<p><code>data Maybe a</code> 定义了一个类型 <code>Maybe</code>，其依赖于类型变量<code>a</code> 。</p>\n<p><spoiler><s>TODO（被学长拉去开车送他回寝室了 QAQ）</s>。回来了，继续 （来自 Day 4 的栗子）。。。</spoiler></p>\n<p>回忆一下我们之前的 Type Constructor 和 Value Constructor 的概念。在上面的程序里面：</p>\n<p>MyMaybe 是一个 Type Constructor。MyJust 是一个 Value Constructor（按照 ghci 的说法是 Data Constructor）。</p>\n<p>所以 MyMaybe 这个 Type 可以由两种 Value Constructor 生成，一个是名叫 MyJust 的，接受一个 a type，另一个是 MyNothing，不依赖于任何数据类型。</p>\n<blockquote>\n<p>栗子：所以说可以理解为。。一个可以利用类型生成类型的玩意？</p>\n</blockquote>\n</div>\n<blockquote>\n<p>参考：<a href=\"https://stackoverflow.com/questions/18808258/what-does-the-just-syntax-mean-in-haskell\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/18808258/what-does-the-just-syntax-mean-in-haskell</a></p>\n</blockquote>\n<h1 id=\"day-4%3A-%E7%A7%91%E7%A0%94%E8%BF%9B%E5%B1%95%E8%89%B0%E9%9A%BE%E3%81%AE%E6%A0%97%E5%AD%90%E3%81%AFhaskell%E5%8B%89%E5%BC%B7%E3%81%8C%E6%AC%B2%E3%81%97%E3%81%84%E3%81%A7%E3%81%99\" tabindex=\"-1\">Day 4: 科研进展艰难の栗子はHaskell勉強が欲しいです</h1>\n<h2 id=\"still-stuck-at-chapter-3.....-sigh\" tabindex=\"-1\">Still Stuck at Chapter 3..... sigh</h2>\n<h3 id=\"recursive-types\" tabindex=\"-1\">Recursive Types</h3>\n<p>最常见的 <code>List Type</code> 就是 <code>recursive</code> 的：即自身定义了自身。为了更好的理解，下面有一个新的栗子</p>\n<p>（栗子：新的栗子？哪里哪里？咱要成为姐姐了么？）</p>\n<pre><code class=\"language-haskell\">-- 列表的定义\ndata List a = Cons a (List a)\n            | Nil\n            deriving (Show)\n--------------\n*Main&gt; Con 1 (Con 2 (Con 3 Nil))\nCon 1 (Con 2 (Con 3 Nil))\n</code></pre>\n<pre><code class=\"language-haskell\">-- 二叉树的定义\ndata Tree a = Node a (Tree a) (Tree a)\n            | Empty\n              deriving (Show)\n</code></pre>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-02\n\ndata List a = Cons a (List a)\n            | Nil\n             deriving (Show)\n\nfromList (x:xs) = Cons x (fromList xs)\nfromList _ = Nil\n--------\n*Main&gt; :load main\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\n*Main&gt; fromList [1, 2, 3, 4, 5, 6]\nCons 1 (Cons 2 (Cons 3 (Cons 4 (Cons 5 (Cons 6 Nil)))))\n*Main&gt; fromList &quot;abcdef&quot;\nCons 'a' (Cons 'b' (Cons 'c' (Cons 'd' (Cons 'e' (Cons 'f' Nil)))))\n</code></pre>\n<h3 id=\"reporting-errors\" tabindex=\"-1\">Reporting Errors</h3>\n<p>Haskell 提供了一个标准函数用来处理代码中的错误：<code>error :: String -&gt; a</code>。那么问题来了，这个 <code>a</code> 从哪里来的。。我们提供了一个 <code>String</code> 但是竟然能吐出一个 <code>a type</code> ？！</p>\n<pre><code class=\"language-haskell\">*Main&gt; error &quot;2333&quot;\n*** Exception: 2333\nCallStack (from HasCallStack):\n  error, called at &lt;interactive&gt;:31:1 in interactive:Ghci3\n*Main&gt; :type error\nerror :: [Char] -&gt; a\n</code></pre>\n<h4 id=\"a-more-controlled-approach\" tabindex=\"-1\">A More Controlled Approach</h4>\n<p>相较于利用 <code>error</code> 强制停止程序，一个更加友善的方式是返回 <code>Nothing</code> 之类的东西，让调用者去处理。</p>\n<pre><code class=\"language-haskell\">-- tidySecond :: [a] -&gt; Maybe a\ntidySecond :: [a] -&gt; Maybe a\n\ntidySecond (_:x:_) = Just x\ntidySecond _ = Nothing\n</code></pre>\n<h3 id=\"%E3%82%88%E3%81%86%E3%81%93%E3%81%9D-%E5%B1%80%E9%83%A8-variable-%EF%BC%81\" tabindex=\"-1\">ようこそ 局部 Variable ！</h3>\n<p><code>let</code> 关键词可以用来定义新的局部变量。</p>\n<pre><code class=\"language-haskell\">lend amount balance = let reserve = 100\n                          newBalance = balance - amount\n                      in if balance &lt; reserve\n                         then Nothing\n                         else Just newBalance\n</code></pre>\n<div class=\"note\">\n<p>定义一个叫做 <code>lend</code> 的函数，<code>amount, balance</code> 是两个形参。</p>\n<p>注意，由于 haskell 是 Lazy Evaluation，所以 let 只是绑定一个表达式，并不是一个值。</p>\n<p>同时需要注意，空格缩进很重要。（栗子：该死的用缩进控制的语言）</p>\n</div>\n<p>我们可以在 <code>let</code> 语句块里和 <code>in</code> 语句块里使用这个变量。</p>\n<h4 id=\"shadowing\" tabindex=\"-1\">Shadowing</h4>\n<p>我们可以在表达式里面嵌套使用 <code>let</code>。</p>\n<pre><code class=\"language-haskell\">foo = let a = 1\n      in let b = 2\n         in a + b\n\n</code></pre>\n<p>之后内部的 <code>let</code> 可以 <code>shadow</code> <code>outer</code> 变量</p>\n<pre><code class=\"language-haskell\">bar = let x = 1\n      in ((let x = &quot;foo&quot; in x), x)\n      \nquux a = let a = &quot;foo&quot; in a ++ &quot;eek!&quot;\n</code></pre>\n<div class=\"note\">\n<p>利用 <code>-fwarn-name-shadowing</code> 可以让编译器提示 Shadowing 问题</p>\n</div>\n<h3 id=\"the-where-clause\" tabindex=\"-1\">The where Clause</h3>\n<pre><code class=\"language-haskell\">lend2 amount balance =\n    if amount &lt; reserve * 0.5\n    then Just newBalance\n    else Nothing\n    where reserve = 100\n          newBalance = balance - amount\n</code></pre>\n<p>Where Clause 可以增加程序的可读性</p>\n<p>和 <code>let in</code> 相比 <code>where clause</code> 将逻辑判断写在前面，局部变量写在后面。</p>\n<h3 id=\"local-functions%2C-global-variables\" tabindex=\"-1\">Local Functions, Global Variables</h3>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-02\n\n\npluralise word counts = plural counts\n    where plural 0 = &quot;no &quot; ++ word ++ &quot;s&quot;\n          plural 1 = &quot;one &quot; ++ word\n          plural n = show n ++ &quot; &quot; ++ word ++ &quot;s&quot;\n-----------\n*Main&gt; pluralise &quot;day&quot; 3\n&quot;3 days&quot;\n*Main&gt; pluralise &quot;day&quot; 1\n&quot;one day&quot;\n*Main&gt; pluralise &quot;day&quot; 0\n&quot;no days&quot;\n</code></pre>\n<p>上面，我们定义了一个局部函数 <code>plural</code>，由若干等式组成。</p>\n<div class=\"note\">\n<p>这里指的是 <code>where</code> 内定义的函数 <code>plural</code> ，这个函数是用一系列等式描述的。</p>\n</div>\n<div class=\"alert\">\n<p>原书的代码有问题，请参照栗子的代码</p>\n</div>\n<p>局部函数可以利用外部函数的变量，这里使用了外部的变量 <code>word</code> 。</p>\n<h2 id=\"the-offside-rule-and-whitespace-in-an-expression\" tabindex=\"-1\">The Offside Rule and Whitespace in an Expression</h2>\n<p>在 Haskell 中，<code>Whitespace</code> 是有意义的。</p>\n<p>Haskell 使用缩进作为代码块的分析线索。这种利用布局来表示结构的方式有时叫做 <code>offside rule</code>。每一个子结构的最顶初的声明必须有相同的缩进。</p>\n<p><code>let</code> 和 <code>where</code> 语句的规则也相似，编译器会记住<code>let where</code> 后面遇到的第一个 token 的缩进，之后作为后面所有后续项目的缩进标准。如果缩进和上一个项目相同，则认为是新的语句块。</p>\n<pre><code class=\"language-haskell\">bar = let b = 2\n          c = True\n       in let a = b\n           in (a, c)\n           \n------或者如下的方式------\nfoo = let { a = 1; b = 2; c = 3; }\n       in a + b + c\n</code></pre>\n<div class=\"note\">\n<p>不会叭不会叭，0202 年了，还有人用这种奇奇怪怪的缩进写法。</p>\n</div>\n<div class=\"alert\">\n<p>但是遗憾的是，根据 <code>Real World Haskell</code> 这个 explicit structuring 写法可能基本不会在 Haskell 程序中使用。</p>\n</div>\n<h3 id=\"the-case-expression\" tabindex=\"-1\">The case Expression</h3>\n<p>函数定义并不是我们唯一可以使用 pattern matching 的地方，另一个使用的地方是 <code>case constructor</code> 下面这个函数 <code>unwrap</code> 了一个 Maybe value。</p>\n<pre><code class=\"language-haskell\">fromMaybe defval wrapped =\n    case wrapped of\n      Nothing -&gt; defval\n      Just value -&gt; value\n-----------\n*Main&gt; fromMaybe 123 (Just 233)\n233\n</code></pre>\n<p><spoiler>栗子：各种 rust 即视感。。。感觉 rust 已经不纯洁了QAQ，原来早就变成了 Haskell 的形状</spoiler></p>\n<div class=\"note\">\n<p>同样的，我们也能用 <code>_</code> 来表达我们不 care 这个 pattern，作为一个 fallback 匹配。</p>\n</div>\n<h3 id=\"conditional-evaluation-with-guards\" tabindex=\"-1\">Conditional Evaluation with Guards</h3>\n<p>Haskell 提供了一个叫做 <code>guards</code> 的功能来做更有表达性的检查。</p>\n<pre><code class=\"language-haskell\">nodesAreSame (Node a _ _) (Node b _ _) \n       | a == b = Just a\n       | a == b &amp;&amp; a == 10 = Just 10\nnodesAreSame _ _ = Nothing\n</code></pre>\n<p>每个 <code>guards</code> 用 <code>|</code> 来分割，之后跟随着一个 <code>=</code> （或者 <code>-&gt;</code> ，在 case 的 pattern matching 情况下）。只要有一个 <code>guards</code> 的结果为 True，则这个 pattern 就会被选取。</p>\n<pre><code class=\"language-haskell\">lends3 amount balance =\n    | amount &lt;= 0            = Nothing\n    | amount &gt; reserve * 0.5 = Nothing\n    | otherwise              = Just newBalance\n    where reserve = 100\n          newBalance = balance - amount\n</code></pre>\n<p>另一个栗子：</p>\n<pre><code class=\"language-haskell\">myDrop n xs = if n &lt;= 0 || null xs\n              then xs\n              else myDrop (n-1) (tail xs)\n------下面是更好(?)的版本-----\nniceDrop n xs | n &lt;= 0 = xs\nniceDrop _ []          = []\nniceDrop n (_:xs)      = niceDrop (n-1) xs\n</code></pre>\n<h1 id=\"day-5%3A-tenet%E6%98%A0%E7%94%BB%E3%82%92%E8%A6%8B%E3%81%BE%E3%81%97%E3%81%9F%EF%BC%81\" tabindex=\"-1\">Day 5: Tenet映画を見ました！</h1>\n<h2 id=\"chapter-4%3A-functional-programming\" tabindex=\"-1\">Chapter 4: Functional Programming</h2>\n<div class=\"note\">\n<p>大家都喜欢的 FP ！</p>\n<p><spoiler>Dive into the Hell of Functional Programming</spoiler></p>\n</div>\n<p>首先放上去一个栗子！（用来献祭）</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-04\n\nimport System.Environment (getArgs)\n\ninteractWith function inputFile outputFile = do\n    input &lt;- readFile inputFile\n    writeFile outputFile (function input)\n\nmain = mainWith myFunction where\n    mainWith function = do\n        args &lt;- getArgs\n        case args of\n          [input, output] -&gt; interactWith function input output\n          _ -&gt; putStrLn &quot;error: exactly two arguments needed&quot;\n\n    myFunction = id\n</code></pre>\n<div class=\"note\">\n<p>上面的代码引入了一个新的关键字：<code>do</code>。<code>do</code> 用来引入能够对现实世界有影响的代码块，比如读写文件。</p>\n<p><code>&lt;-</code> 在<code>do</code>代码块里面等同于赋值语句。</p>\n</div>\n<p>另一个栗子：</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-04\n\nsplitlines :: string -&gt; [string]\n\nsplitlines [] = []\nsplitlines cs =\n    let (pre, suf) = break islineterminator cs in\n        pre : case suf of\n                ('\\r':'\\n':rest) -&gt; splitlines rest\n                ('\\r':rest)      -&gt; splitlines rest\n                ('\\n':rest)      -&gt; splitlines rest\n                _                -&gt; []\nislineterminator c = c == '\\r' || c == '\\n'\n\n----\nPrelude&gt; :type break\nbreak :: (a -&gt; Bool) -&gt; [a] -&gt; ([a], [a])\nPrelude&gt; break odd [2,4,5,6,7]\n([2,4],[5,6,7])\n</code></pre>\n<div class=\"note\">\n<p><code>break</code> 在 <code>prelude</code> 中定义，用来将列表分割成两部分。根据函数来决定在列表的哪个位置进行分割。</p>\n</div>\n<h3 id=\"infix-functions\" tabindex=\"-1\">Infix Functions</h3>\n<p>通常我们在 Haskell 中定义和使用函数的时候，都是先写函数名，再跟着参数。这种方式叫做<code>prefix</code>（前缀）。</p>\n<p>如果函数有2个及以上的参数的时候，我们可以有一个叫做 <code>infix</code> 的形式（类似于运算符的中缀表达式 1 add 1），放在第一个和第二个参数中间。</p>\n<p>为了定义和使用函数的 <code>infix</code> 形式。我们需要把函数名用 ` 包裹起来。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-04\n\na `plus` b = a + b\n\ndata a `Pair` b = a `Pair` b\n                  deriving (Show)\n\n\nfoo = Pair 1 2\nbar = True `Pair` &quot;quux&quot;\n-------\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\n*Main&gt; foo\n1 `Pair` 2\n*Main&gt; bar\nTrue `Pair` &quot;quux&quot;\n*Main&gt; 1 `plus` 2\n3\n*Main&gt; plus 1 2\n3\n</code></pre>\n<h3 id=\"working-with-lists\" tabindex=\"-1\">Working with Lists</h3>\n<h4 id=\"safely-and-sanely-working-with-crashy-functions\" tabindex=\"-1\">Safely and Sanely Working with Crashy Functions</h4>\n<p>由于 Haskell 的 List 并不存储 Length 信息，因此 <code>length</code> 函数获得长度信息的唯一办法是遍历整个序列。 所以 Haskell way 做 List 判断是使用 <code>null</code> 函数</p>\n<pre><code class=\"language-haskell\">myDumbExample xs = if not (null xs)\n                      then head xs\n                      else 'Z'\n</code></pre>\n<h3 id=\"partial-and-total-functions\" tabindex=\"-1\">Partial and Total Functions</h3>\n<div class=\"define\">\n<p>Functions that have only return values defined for a subset of valid inputs are called <code>partial fucntions</code></p>\n<p>We call functions that return valid results over their entire input domains <code>total functions</code></p>\n</div>\n<h3 id=\"how-to-think-about-loops\" tabindex=\"-1\">How to Think About Loops</h3>\n<div class=\"alert\">\n<p>震惊！和其他传统语言不一样，Haskell <strong>没有</strong> <code>for</code> 或者 <code>while</code> 循环。</p>\n</div>\n<p>下面给出对循环的解决方法。</p>\n<h4 id=\"%E6%98%BE%E5%BC%8F%E9%80%92%E5%BD%92-explicit-recursion\" tabindex=\"-1\">显式递归 Explicit Recursion</h4>\n<p>以下面的 <code>CPP</code> 程序为栗：</p>\n<pre><code class=\"language-c++\">int as_int(char *ss) {\n  int acc = 0;\n  for (acc = 0; isdigit(*str); str++) {\n    acc = acc * 10 + (*str - '0');\n  }\n  return acc;\n}\n</code></pre>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-04\n\nimport Data.Char (digitToInt)\n\nasInt :: String -&gt; Int\nasInt xs = loop 0 xs\n\nloop acc [] = acc      -- terminating case / base case\nloop acc (x:xs) = loop (acc * 10 + digitToInt x) xs  -- inductive case\n\n---- or -----\nloop acc [] = acc\nloop acc (x:xs) =  let acc' = acc * 10 + digitToInt x\n                       in loop acc' xs\n</code></pre>\n<div class=\"note\">\n<p><strong>变量名和单引号</strong></p>\n<p>单引号在 Haskell 里面是合法的变量名字符，发音为 prime。一般认为 <code>foo'</code> 是和 <code>foo</code> 相关的变量（通常是 foo 的新值）。</p>\n<p>你甚至可以用 <code>foo''</code></p>\n</div>\n<div class=\"extra\">\n<p><strong>尾递归</strong></p>\n<p>在 Haskell 中，我们用尾递归代替 Loop。通常来讲尾递归相比循环会占用更多的空间和时间。但是 FP 会利用 TCO（尾递归优化）自动把递归调用转换成常数空间占用的代码。</p>\n</div>\n<h3 id=\"transforming-every-piece-of-input\" tabindex=\"-1\">Transforming Every Piece of Input</h3>\n<h3 id=\"mapping-over-a-list\" tabindex=\"-1\">Mapping over a List</h3>\n<pre><code class=\"language-haskell\">*Main Data.List&gt; a = [1, 2, 3, 4]\n*Main Data.List&gt; upper x = x^2\n*Main Data.List&gt; map upper a\n[1,4,9,16]\n</code></pre>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-04\n\nmyMap :: (a-&gt;b) -&gt; [a] -&gt; [b]\n\nmyMap f (x:xs) = f x : myMap f xs\nmyMap _ _ = []\n--------------------\n*Main Data.List&gt; myMap odd [1,2,3,4]\n[True,False,True,False]\n*Main Data.List&gt; a = [1,2,3,4]\n*Main Data.List&gt; myMap odd a\n[True,False,True,False]\n</code></pre>\n<h3 id=\"selecting-pieces-of-input\" tabindex=\"-1\">Selecting Pieces of Input</h3>\n<p>另一个常见的对序列数据的操作是筛选出某些元素。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-04\n\noddList :: [Int] -&gt; [Int]\n\noddList (x:xs) | odd x     = x : oddList xs\n               | otherwise = oddList xs\noddList _                  = []\n----------------\n*Main Data.List&gt; :load main\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\n*Main Data.List&gt; oddList [1,2,3,4,5]\n[1,3,5]\n*Main Data.List&gt; filter odd [1,2,3,4,5]\n[1,3,5]\n</code></pre>\n<h3 id=\"computing-one-answer-over-a-collection\" tabindex=\"-1\">Computing One Answer over a Collection</h3>\n<p>另一个常见的操作上将整个列表聚合成一个元素。</p>\n<pre><code class=\"language-haskell\">mySum xs = helper 0 xs\n    where helper acc (x:xs) = helper (acc + x) xs\n          helper acc _      = acc\n-------------\n*Main Data.List&gt; :load main\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\n*Main Data.List&gt; mySum [1,2,3,4,5,6]\n21\n</code></pre>\n<h3 id=\"the-left-fold\" tabindex=\"-1\">The Left Fold</h3>\n<pre><code class=\"language-haskell\">*Main Data.List&gt; foldl (+) 0 [1,2,3,4,5,6]\n21\n</code></pre>\n<h2 id=\"anonymous-(lambda)-functions\" tabindex=\"-1\">Anonymous (lambda) Functions</h2>\n<p>Haskell 允许我们写完全匿名的函数，从而免去给辅助函数命名的烦恼。匿名函数也经常叫做 &quot;lambda \\(\\lambda\\)&quot; 函数。使用 <code>\\</code> 来引入 lambda 函数，之后是函数的参数，之后用 <code>-&gt;</code> 来引入函数主体。</p>\n<pre><code class=\"language-haskell\">-- file: main.hs\n-- author: kuriko\n-- date: 2020-09-04\n\nimport Data.List (isInfixOf)\n\nisInAny needle haystack = any inSequence haystack\n    where inSequence s = needle `isInfixOf` s\n\n---- lambda version below -----\n\nisInAny2 needle haystack = any (\\s -&gt; needle `isInfixOf` s) haystack\n</code></pre>\n<div class=\"note\">\n<p>lambda 函数被包裹在 <code>()</code> 中来方便 Haskell 编译器确定函数体的范围。</p>\n</div>\n<p>大部分时候匿名函数和普通的函数的行为相同，但是在定义匿名函数的时候 Haskell 加上了一些限制。最重要的一点，在写普通函数的时候我们可以使用多个包含不同 pattern 和 guards 的 Clause。但是 lambda 函数只能有一个 clause。</p>\n<p>单 Clause 限制我们在定义 lambda 时候如何使用 pattern：</p>\n<pre><code class=\"language-haskell\">safeHead (x:_) = Just x\nsafeHead _ = Nothing\n</code></pre>\n<p>但是因为我们不能在定义 lambda 函数的时候使用多个 Clause 因此我们必须写出匹配任意的 pattern：</p>\n<pre><code class=\"language-haskell\">unsafeHead = \\(x:_) -&gt; x\n\n-------\nKuriko&gt; :load main\n[1 of 1] Compiling Main             ( main.hs, interpreted )\nOk, one module loaded.\nKuriko&gt; unsafeHead [1,2,3]\n1\nKuriko&gt; unsafeHead []\n*** Exception: main.hs:5:14-24: Non-exhaustive patterns in lambda\n</code></pre>\n<p>悲惨的是这个错误能通过编译器的语法检查，因此只能在 <code>runtime</code> 触发。。所以。。</p>\n<div class=\"alert\">\n<p>当在匿名函数中使用 patterns 的时候，请一定保证你的 patterns <strong>不会</strong>匹配失败。</p>\n</div>\n<h1 id=\"day-6%3A-%E6%94%BE%E5%81%87%E5%95%A6%EF%BD%9E\" tabindex=\"-1\">Day 6: 放假啦～</h1>\n<h2 id=\"partial-function-application-and-currying\" tabindex=\"-1\">Partial Function Application and Currying</h2>\n<div class=\"note\">\n<p>偏函数和柯里化です</p>\n</div>\n<p>还是先看一个栗子：</p>\n<pre><code class=\"language-haskell\">Kuriko&gt; :type dropWhile\ndropWhile :: (a -&gt; Bool) -&gt; [a] -&gt; [a]\n</code></pre>\n<p>注意一下<code>-&gt;</code>，这里的 <code>-&gt;</code> 似乎有两种意思，但实际上所有的 <code>-&gt;</code> 都可以理解为：左边是参数，右边是返回值。</p>\n<p>这一点在 Haskell 中十分重要，所有的函数都只接收一个且仅接收一个参数。所以 <code>dropwhile</code> 可以认为是接受了一个函数，并返回了一个函数。</p>\n<pre><code class=\"language-haskell\">Kuriko&gt; :type isSpace\nisSpace :: Char -&gt; Bool\nKuriko&gt; :type dropWhile isSpace\ndropWhile isSpace :: [Char] -&gt; [Char]\n</code></pre>\n<p>现在，我们给了 <code>dropWhile</code> 一个函数 <code>isSpace</code> 之后，可以看到返回了一个 <code>[a] -&gt; [a]</code>。</p>\n<p>因此我们可以利用这些函数组合出更高阶的函数：</p>\n<pre><code class=\"language-haskell\">Kuriko&gt; map (dropWhile isSpace) [&quot; a&quot;, &quot;f&quot;, &quot;    e&quot;]\n[&quot;a&quot;,&quot;f&quot;,&quot;e&quot;]\n</code></pre>\n<h1 id=\"day-7%3A-%E3%81%8A%E9%82%AA%E9%AD%94%E3%81%97%E3%81%BE%E3%81%99\" tabindex=\"-1\">Day 7: お邪魔します</h1>\n<div class=\"note\">\n<p>最近忙于把论文排版成 \\(\\LaTeX\\)，没什么时间更新 Blog。。。</p>\n</div>\n<p>接上回，<code>dropWhile isSpace</code> 相当于组成了一个新的函数，能够把一个列表的前面的空格元素去掉。</p>\n<p>当我们给一个函数传递少于她要求个数个参数的时候，我们称其为 <code>partial application</code>。以上一个栗子为例：</p>\n<pre><code class=\"language-haskell\">isInAny3 needle haystack = any (isInfixOf needle) haystack\n</code></pre>\n<p>这里的 <code>isInfixOf needle</code> 是一个 <code>partial function application</code>，我们使用了 <code>isInfixOf</code> 这个函数，并且固定了她的第一个参数。</p>\n<p><code>partial function application</code> 叫做 <code>currying</code>，根据 Haskell Curry 而命名。</p>\n<h3 id=\"sections\" tabindex=\"-1\">Sections</h3>\n<p>Haskell 提供了方便的方法让我们用 <code>infix</code> 的形式写偏函数。如果我们用括号包裹了一个操作，我们可以在括号内的左或右提供她的操作数，从而得到偏函数。这种得到偏函数的方法叫做 <code>section</code></p>\n<pre><code class=\"language-haskell\">Prelude&gt; op = (1+)\nPrelude&gt; op 2\n3\nPrelude&gt; map (*3) [24, 36]\n[72,108]\nPrelude&gt; map (3*) [24, 36]\n[72,108]\n</code></pre>\n<h3 id=\"as-patterns\" tabindex=\"-1\">As-patterns</h3>\n<pre><code class=\"language-haskell\">Prelude Data.List&gt; :type tails\ntails :: [a] -&gt; [[a]]\nPrelude Data.List&gt; tails &quot;kuriko&quot;\n[&quot;kuriko&quot;,&quot;uriko&quot;,&quot;riko&quot;,&quot;iko&quot;,&quot;ko&quot;,&quot;o&quot;,&quot;&quot;]\nPrelude Data.List&gt; tails []\n[[]]\n</code></pre>\n<p>现在如果我们想获得一个不会返回空的 <code>tails</code> 函数呢？下面我们将会实现自己版本的 <code>tails</code></p>\n<p>这里我们引入一个新的记号: <code>@</code> 符号</p>\n<pre><code class=\"language-haskell\">suffixes :: [a] -&gt; [[a]]\n\nsuffixes xs@(_:xs') = xs : suffixes xs'\nsuffixes _ = []\n</code></pre>\n<p>模式 <code>xs@(_:xs')</code> 叫做 <code>as-pattern</code>。意思是：「bind the variable <code>xs</code> to the value that matches the right side of the <code>@</code> symbol」.</p>\n<div class=\"note\">\n<p>即符合 pattern 的那玩意被赋值给了 <code>xs</code> 这个变量。</p>\n</div>\n<p>使用 AsPattern 的好处除了可读性问题之外，还能减少 copy，如果我们用 (x:xs) 代替的话，会在运行时触发一次新的构造。而使用 AsPattern 的话，xs 实际上会被复用。</p>\n<h3 id=\"code-reuse-through-composition\" tabindex=\"-1\">Code Reuse Through Composition</h3>\n<p>在 Haskell 中，Prelude 提供了一个函数 <code>(.)</code> 用于 <code>compose</code>，</p>\n<pre><code class=\"language-haskell\">compose f g x = f (g x)\nsuffixes2 = compose init tails\nsuffixes3 = init . tails\n----------\n*Main Data.List&gt; :type (.)\n(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c\n</code></pre>\n<p>我们可以连锁使用 <code>.</code> 来创造出新的函数。</p>\n<pre><code class=\"language-haskell\">Kuriko &gt; capCount = length . filter (isUpper . head) . words\nKuriko &gt; capCount &quot;Hello, There Mom!&quot;\n3\n</code></pre>\n<h2 id=\"chapter-5%3A-writing-a-library%3A-working-with-json-data\" tabindex=\"-1\">Chapter 5: Writing a Library: Working with JSON Data</h2>\n<h3 id=\"respresenting-json-data-in-haskell\" tabindex=\"-1\">Respresenting JSON Data in Haskell</h3>\n<pre><code class=\"language-haskell\">data JValue = JString String\n            | JNumber Double\n            | JBool Bool\n            | JNull\n            | JObject [(String, JValue)]\n            | JArray [JValue]\n              deriving (Eq, Ord, Show)\n              \ngetString (JString s) = Just s\ngetString _ = Nothing\n\n-- .....\n\nisNull v = v == JNull\n</code></pre>\n<h3 id=\"the-anatomy-of-a-haskell-module\" tabindex=\"-1\">The Anatomy of a Haskell Module</h3>\n<p>一个 Haskell 的源文件包含了单个 <code>module</code> 的定义。一个 <code>module</code> 允许我们决定哪些名字可以在模块外部被访问。</p>\n<div class=\"alert\">\n<p>注意 <code>module</code> 定义关键词必须在所有其他的定义之前。并且 module 名必须是首字母大写（而且不能是 Main）。并且我们的源文件名名字的 <code>base name</code> （The component before the suffix）必须和 module name 一致。</p>\n</div>\n<pre><code class=\"language-haskell\">module SimpleJson\n    (\n        JValue(..),\n        getString,\n        isNull\n    ) where\n\ndata JValue = JString String\n            | JNumber Double\n            | JBool Bool\n            | JNull\n            | JObject [(String, JValue)]\n            | JArray [JValue]\n              deriving (Eq, Ord, Show)\n\ngetString (JString s) = Just s\ngetString _ = Nothing\n\nisNull v = v == JNull\n</code></pre>\n<p>where 代表这 module 的 body 部分开始。</p>\n<p><code>(..)</code> 代表我们将会导出 <code>type</code> 以及其所有的 <code>constructors</code></p>\n<div class=\"explain\">\n<p>虽然看起来我们能导出一个 type 的名字（即其 <code>type constructor</code>）而不是其 <code>value constructor</code> 很奇怪。但是能这么做其实是很重要的：她允许我们对其使用者隐藏类型的细节，使得这个类型 <code>abstract</code> 。如果我们不能看到这个 <code>type</code> 的 <code> value constructor</code> 那么我们就不能对这个 <code>type</code> 进行 pattern match，同时我们也不能根据这个 Type 创建新的 value. 接下来的章节我们会讨论什么时候我们会希望 Type 是 abstract 的。</p>\n</div>\n<p>如果我们去掉 <code>()</code> 和内部的东西，我们就会将 module 里面所有的东西都导出。</p>\n<p>或者如果我们 <code>()</code> 内是空的，那么该 module 里面任何东西都不会被导出。</p>\n<pre><code class=\"language-haskell\">module ExportEverything where\n--------------\nmodule ExportNothing () where\n</code></pre>\n<h3 id=\"compiling-haskell-source\" tabindex=\"-1\">Compiling Haskell Source</h3>\n<p><code>ghc</code> 可以用于编译 haskell 源文件名到 <code>native code</code></p>\n<div class=\"alert\">\n<p>现在的 ghc 会自动根据 import 来查找对应的 <code>.h</code> 文件进行导入（类似于 #include 这种语意）因此不需要编译成 <code>.o</code> 再进行链接。</p>\n<p>另外至少需要导出一个 main 来个外面的世界交互。。</p>\n<pre><code class=\"language-haskell\">➜  haskell ghc Main.hs SimpleJSON.o\n[2 of 2] Compiling Main             ( Main.hs, Main.o )\n\nMain.hs:1:1: error:\n    The IO action ‘main’ is not exported by module ‘Main’\n  |\n1 | -- file: main.hs\n  | ^\n\n</code></pre>\n</div>\n<pre><code class=\"language-haskell\">module Main (main) where\n\nimport SimpleJSON\n\nmain = print (JObject [(&quot;foo&quot;, JNumber 1), (&quot;bar&quot;, JBool False)])\n-------------\n➜  haskell ghc Main.hs  -o simple\nLinking simple ...\n➜  haskell ./simple\nJObject [(&quot;foo&quot;,JNumber 1.0),(&quot;bar&quot;,JBool False)]\n</code></pre>\n<h3 id=\"type-inference-is-a-double-edged-sword\" tabindex=\"-1\">Type Inference Is a Double-Edged Sword</h3>\n<pre><code class=\"language-haskell\">import Data.Char\n\n-- upcaseFirst :: String -&gt; String\n-- upcaseFirst (c:cs) = toUpper c : cs\nupcaseFirst (c:cs) = toUpper c -- supposed that we forgot `: cs`\n</code></pre>\n<p>如果我们忘记了 <code>: cs</code> 同时没有显式的写出 upcaseFirst 的函数签名，那么编译器仍然能够通过这个函数，不过签名自动推导成了 <code>[Char] -&gt; Char</code>。这将会导致之后在使用的时候才爆出问题。如果我们能够一开始就写出函数签名，那么编译器会自动检测到签名不符而报错。</p>\n<pre><code class=\"language-haskell\">Prelude&gt; :reload\n[1 of 1] Compiling Main             ( main.hs, interpreted )\n\nmain.hs:8:22: error:\n    • Couldn't match type ‘Char’ with ‘[Char]’\n      Expected type: String\n        Actual type: Char\n    • In the expression: toUpper c\n      In an equation for ‘upcaseFirst’: upcaseFirst (c : cs) = toUpper c\n  |\n8 | upcaseFirst (c:cs) = toUpper c -- forgot &quot;:cs&quot; here\n  |                      ^^^^^^^^^\n</code></pre>\n<div class=\"info\">\n<p>通常来讲，代码的第一个 <code>definition</code> 应该加上签名。</p>\n</div>\n<h3 id=\"a-more-general-look-at-rendering\" tabindex=\"-1\">A More General Look at Rendering</h3>\n<p>// TODO</p>\n<h3 id=\"pretty-printing-a-string\" tabindex=\"-1\">Pretty Printing a String</h3>\n<pre><code class=\"language-haskell\">string :: String -&gt; Doc\nstring = enclose '&quot;' '&quot;' . hcat . map oneChar\n</code></pre>\n<div class=\"info\">\n<p><strong>Point-free style</strong></p>\n<p>这种将定义写成其他函数的组合形式叫做 <code>point-free sytle</code> ，这里的 point 并不是指 <code>.</code></p>\n<p>Point 大致上指的是 'synonymous (in Hasekll)' with value, 所以这里的 'point-free' 表达式意思是不会提到要作用的值。（大意是表达式里面只有函数的组合）</p>\n<p>所以上面的改写成 pointy 版本是</p>\n<pre><code class=\"language-haskell\">pointyString :: String -&gt; Doc\npointyString s = enclose '&quot;' '&quot;' (hcat (map oneChar s))\n</code></pre>\n</div>\n<h1 id=\"day-%E3%83%8F%E3%83%81%EF%BC%9A%E7%96%B2%E3%82%8C%E3%81%9F\" tabindex=\"-1\">Day ハチ：疲れた</h1>\n<h2 id=\"chapter-6%3A-using-typeclasses\" tabindex=\"-1\">Chapter 6: Using Typeclasses</h2>\n<p>Typeclasses 是 Haskell 里面最重要的特性之一，他允许我们定义泛化的接口从而在广泛的类型上提供通用的特性。在讨论 typeclasses 是什么之前，我们先解释一下我们为什么需要这个特性。</p>\n<h3 id=\"the-need-for-typeclasses\" tabindex=\"-1\">The Need for Typeclasses</h3>\n<p>假设某一天 Haskell 的设计者们拒绝在 Haskell 中实现 <code>==</code> 运算符（明显，他们终于写 Haskell 写疯了）。那么卑微的各位 Haskell 开发者们只好自行实现相应的 <code>equality test</code> 了。</p>\n<pre><code class=\"language-haskell\">data Color = Red | Green | Blue\n\ncolorEq :: Color -&gt; Color -&gt; Bool\n\ncolorEq Red Red = True\ncolorEq Green Green = True\ncolorEq Blue Blue = True\ncolorEq _ _ = False\n</code></pre>\n<p>下面假设我们需要对 <code>String</code> 做 Eq 判断，由于 <code>String</code> 实际上是 <code>[Char]</code> 所以我们应该逐个判断：</p>\n<pre><code class=\"language-haskell\">stringEq :: [Char] -&gt; [Char] -&gt; Bool\nstringEq [] [] = True\nstringEq (x:xs) (y:ys) = x == y &amp;&amp; stringEq xs ys\nstringEq _ _ = False\n</code></pre>\n<p>现在问题来了，对于不同的类型 <code>Color</code>, <code>String</code> 我们需要对每种 Type 都定义对应的比较函数。对应的，当我们做比较的时候，我们甚至需要判断 type 来调用对应的比较函数。而原本的 == 则可以作用在所有的可比较的 type 上。</p>\n<p>此时，当当当，<code>Typeclasses</code> 来拯救大家啦</p>\n<p><code>Typeclasses</code> 定义了一系列函数，这些函数能在不同的 Type 上有不同的实现。</p>\n<div class=\"note\">\n<p>看起来 Typeclasses 有点像 OOP 里面的某些概念，但是实际上是完全不同的。</p>\n</div>\n<p>下面我们用 Typeclasses 来解决一下上一节提出的问题：</p>\n<pre><code class=\"language-haskell\">class BasicEq a where\n\tisEqual :: a -&gt; a -&gt; Bool\n-------------\n*Main&gt; :type isEqual\nisEqual :: BasicEq a =&gt; a -&gt; a -&gt; Bool\n</code></pre>\n<p>For all types <strong>a</strong>, so long as <strong>a</strong> is an instance of <strong>BaiscEq</strong>, <strong>isEqual</strong> takes two parameters of type <strong>a</strong> and returns a <strong>Bool</strong>.</p>\n<pre><code class=\"language-haskell\">instance BasicEq Bool where\n    isEqual True True = True\n    isEqual False False = True\n    isEqual _ _ = False\n</code></pre>\n<p>底下的是提供了默认实现。用户如果想实现这个 <code>Class</code> 则必须至少实现两个中的一个。</p>\n<pre><code class=\"language-haskell\">class BasicEq3 a where\n    isEqual3 :: a -&gt; a -&gt; Bool\n    isEqual3 x y = not (isNotEqual3 x y)\n\n    isNotEqual3 :: a -&gt; a -&gt; Bool\n    isNotEqual3 x y = not (isEqual3 x y)\n</code></pre>\n<h3 id=\"declaring-typeclass-instances\" tabindex=\"-1\">Declaring Typeclass Instances</h3>\n<h3 id=\"important-built-in-typeclasses\" tabindex=\"-1\">Important Built-in Typeclasses</h3>\n<h4 id=\"show\" tabindex=\"-1\">Show</h4>\n<p>Show 用来将 value 转变为 Strings。</p>\n<pre><code class=\"language-haskell\">instance Show Color where\n    show Red = &quot;Red&quot;\n    show _ = &quot;Not Red&quot;\n</code></pre>\n<h4 id=\"read\" tabindex=\"-1\">Read</h4>\n<p><code>Read</code> 的作用和 <code>Show</code> 相反。她接受一个 <code>String</code> 解析并返回任何一个 <code>Read</code> 允许的类型。</p>\n<pre><code class=\"language-haskell\">main = do\n    putStrLn &quot;Please enter a double:&quot;\n    inpStr &lt;- getLine\n    let inpDouble = (read inpStr)::Double\n    putStrLn (&quot;Twice&quot; ++ show inpDouble ++ &quot; is &quot; ++ show (inpDouble *2))\n</code></pre>\n<div class=\"note\">\n<p>这里的 <code>::Double</code> 是类型声明的那个 <code>::</code></p>\n<p><code>isEqual :: BasicEq a =&gt; a -&gt; a -&gt; Bool</code></p>\n</div>\n","slug":"学习笔记/Haskell/Real-World-Haskell-学习笔记","published":true,"date":"2020-08-28T11:54:54.000Z","updated":"2022-04-02T17:45:11.000Z","path":"学习笔记/Haskell/Real-World-Haskell-学习笔记/","api_path":"api/articles/学习笔记/Haskell/Real-World-Haskell-学习笔记.json","keywords":null,"config":{"max_toc_level":2},"tags":[{"name":"学习笔记","path":"api/tags/学习笔记.json"},{"name":"Haskell","path":"api/tags/Haskell.json"}]}]}