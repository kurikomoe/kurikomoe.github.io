{"name":"flag","postlist":[{"title":"程序员面试金典-读书笔记","subtitle":"Chapter 7+8","author":"Kuriko Moe (栗子Chan)","excerpt":"<blockquote>\n<p>不要问 Ch1-6 去哪儿了。。不是被咱吃了OvO</p>\n</blockquote>\n<p>这里是从 Ch7 开始的读书笔记。</p>\n","render_content":"<blockquote>\n<p>不要问 Ch1-6 去哪儿了。。不是被咱吃了OvO</p>\n</blockquote>\n<p>这里是从 Ch7 开始的读书笔记。</p>\n<!-- more -->\n<div class=\"info\">\n<p><strong>就本书的面试题以及亦可能遇到的其他题目，请参照以下几个步骤</strong>:</p>\n<ol>\n<li>\n<p><strong>尽量独立解题</strong>。本书后面有一些提示可供参考，但是尽量不要依赖提示解决问题。\n许多题目确实很难，但是没关系，不要怕！此外，解题时还要考虑空间和时间复杂度。</p>\n</li>\n<li>\n<p><strong>在纸上写代码</strong>（这里咱就直接用无语法高亮的 ViM 写了，相应的题目在Leetcode-cn 上直接浏览器作答）。\n在电脑上编程可以享受到 语法高亮、代码 Lint，快速调试等种种好处，在纸上写代码则不然。\n通过在纸上多多实践来适应这种情况，并对在纸上编写、编辑代码的缓慢习以为常。</p>\n</li>\n<li>\n<p><strong>在纸上测试代码</strong>。就是在纸上写下一般用例、基本用例和错误用例等。面试就需要这么做\n因此需要提前做好准备。</p>\n</li>\n<li>\n<p><strong>将代码照原样的输入计算机</strong>。你也许会犯一大堆错误。请整理一份<strong>清单</strong>，罗列自己\n犯过的所有错误，这样在真正面试时才能牢记在心。</p>\n</li>\n</ol>\n<blockquote>\n<p>此外，尽量多做模拟面试。你可以和朋友轮流给对方做模拟面试。虽然你的朋友不见得 受到过什么专业训练，但至少能带你过一边代码或者算法面试题。你也会在当面试的体验中，获益良多。</p>\n</blockquote>\n</div>\n<h1 id=\"chapter-7\" tabindex=\"-1\">Chapter 7</h1>\n<h2 id=\"%E5%BF%85%E5%A4%87%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\" tabindex=\"-1\">必备的基础知识</h2>\n<h3 id=\"%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%A6%82%E5%BF%B5\" tabindex=\"-1\">核心数据结构、算法以及概念</h3>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>数据结构</th>\n<th>算法</th>\n<th>概念</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>链表✔️</td>\n<td>广度优先搜索✔️</td>\n<td>位操作（需要巩固 Hex &lt;-&gt; Dec  &lt;-&gt; Bin 转换)</td>\n</tr>\n<tr>\n<td>树、单词查找树、图✔️</td>\n<td>深度优先搜索 ✔️</td>\n<td>内存（堆和栈）✔️</td>\n</tr>\n<tr>\n<td>栈和队列✔️</td>\n<td>二分查找 ✔️</td>\n<td>递归✔️</td>\n</tr>\n<tr>\n<td>堆 ✔️</td>\n<td>归并排序（需要亲自写一份）✔️</td>\n<td>动态规划（需要更多的题目）</td>\n</tr>\n<tr>\n<td>向量/数组列表 ✔️</td>\n<td>快排（需要亲自写一份）✔️</td>\n<td>大 \\(\\mathcal{O}\\) 时间以及空间✔️</td>\n</tr>\n<tr>\n<td>散列表 ✔️</td>\n</tr>\n</tbody>\n</table></div>\n<p>✔️ Leetcode 排序测试题目：<a href=\"https://leetcode-cn.com/problems/sort-an-array/\" target=\"_blank\" rel=\"noopener\">适用于快排和归并排序</a></p>\n<h4 id=\"in-place-%E5%BF%AB%E6%8E%92%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83\" tabindex=\"-1\">In-Place 快排算法核心</h4>\n<p>为了减少空间复杂度，快速排序在选取出参考元素之后，可以进行原地数组操作：</p>\n<pre><code class=\"language-rust\">unsafe fn swap&lt;T: Copy + Debug&gt;(a: *mut T, b: *mut T) {\n  let tmp = b.as_ref().unwrap().clone();\n  *b = *a;\n  *a = tmp;\n}\n\n// 将队列参考元素（这里是最左端元素，可以改为随机化选取）与队列末端交换，\n// 使得最左端为缓冲区\nswap(&amp;mut _pNum[r] as *mut i32, &amp;mut _pNum[p_mid] as *mut i32);\n\nfor i in l..r {\n  // 如果元素比参考值小，则放置到左端区域\n   if _pNum[i] &lt; mid {\n     // 交换元素\n     swap(&amp;mut _pNum[p_mid] as *mut i32, &amp;mut _pNum[i] as *mut i32);\n     // 左端缓冲区扩大\n     p_mid += 1;\n   }\n}\n\n// 将参考元素移回到缓冲区头部（缓冲区头部**一定**不满足「小于」参考元素的要求）\nswap(&amp;mut _pNum[r] as *mut i32, &amp;mut _pNum[p_mid] as *mut i32);\n\nSolution::quick_sort(l, p_mid);\nSolution::quick_sort(p_mid + 1, r);\n</code></pre>\n<p>参考资料：<a href=\"https://zh.wikipedia.org/zh-cn/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\" target=\"_blank\" rel=\"noopener\">Wikipedia</a></p>\n<p>// TODO: 添加源代码的 Github Repo 引用</p>\n<h3 id=\"%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83\" tabindex=\"-1\">归并排序算法核心</h3>\n<div class=\"info\">\n<p>归并排序很难做到 In-Place 实现最小化内存占用。。。</p>\n<p>In-Place 算法需要更大的时间复杂度（需要位移元素）</p>\n</div>\n<pre><code class=\"language-rust\">use std::fmt::Debug;\n\nstatic mut P_NUM: *mut Vec&lt;i32&gt; = std::ptr::null_mut();\n\nimpl Solution {\n  unsafe fn swap&lt;T: Copy + Debug&gt;(a: *mut T, b: *mut T) {\n    let tmp = b.as_ref().unwrap().clone();\n    *b = *a;\n    *a = tmp;\n  }\n\n  unsafe fn merge_sort(l: usize, r: usize) {\n    let pNum = P_NUM.as_mut().unwrap();\n\n    if l == r {\n      return;\n    } else if l + 1 == r &amp;&amp; pNum[l] &gt; pNum[r] {\n      Solution::swap(&amp;mut pNum[l], &amp;mut pNum[r]);\n      return;\n    }\n\n    let mid = (l + r) / 2;\n\n    Solution::merge_sort(l, mid);\n    Solution::merge_sort(mid + 1, r);\n\n    // do the merge\n    let (mut i, mut j) = (l, mid + 1);\n\n    let mut tmp = Vec::new();\n\n    while i &lt;= mid &amp;&amp; j &lt;= r {\n      if pNum[i] &lt; pNum[j] {\n        tmp.push(pNum[i]);\n        i += 1;\n      } else {\n        tmp.push(pNum[j]);\n        j += 1;\n      }\n    }\n\n    let (start, end) = if i &gt; mid { (j, r) } else { (i, mid) };\n\n    for k in start..=end {\n      tmp.push(pNum[k]);\n    }\n\n    for i in 0..tmp.len() {\n      pNum[l + i] = tmp[i];\n    }\n  }\n\n  pub fn sort_array(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    let mut ret = nums;\n    unsafe {\n      P_NUM = &amp;mut ret;\n      Solution::merge_sort(0, ret.len() - 1);\n      ret\n    }\n  }\n}\n</code></pre>\n<div class=\"warning\">\n<p>版本：rustc 1.44.0-nightly (b2e36e6c2 2020-04-22)</p>\n<p>对于 static mut 全局变量，并行测试的时候存在随机错误问题。需要使用 --test-threads=1</p>\n<pre class='command-line' data-user='kuriko' data-host='kuriko.moe'>\n<code class='language-bash'>\ncargo test -- --nocapture --test-threads=1\n</code>\n</pre>\n</div>\n<h4 id=\"2-%E7%9A%84%E5%B9%82%E6%AC%A1%EF%BC%88hex-%3C-%3E-dec-%3C-%3E-bin%EF%BC%89\" tabindex=\"-1\">2 的幂次（Hex &lt;-&gt; Dec &lt;-&gt; Bin）</h4>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>Hex</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>A</th>\n<th>B</th>\n<th>C</th>\n<th>D</th>\n<th>E</th>\n<th>F</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Dec</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n<td>5</td>\n<td>6</td>\n<td>7</td>\n<td>8</td>\n<td>9</td>\n<td>10</td>\n<td>11</td>\n<td>12</td>\n<td>13</td>\n<td>14</td>\n<td>15</td>\n</tr>\n<tr>\n<td>Bin</td>\n<td>0</td>\n<td>1</td>\n<td>10</td>\n<td>11</td>\n<td>100</td>\n<td>101</td>\n<td>110</td>\n<td>111</td>\n<td>1000</td>\n<td>1001</td>\n<td>1010</td>\n<td>1011</td>\n<td>1100</td>\n<td>1101</td>\n<td>1110</td>\n<td>1111</td>\n</tr>\n</tbody>\n</table></div>\n<h2 id=\"%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4\" tabindex=\"-1\">解题步骤</h2>\n<p>下面这个流程图是如何逐步解决一个问题：\n<img src=\"https://kurikomoe-1300672427.image.myqcloud.com/images/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/ch7/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%B5%81%E7%A8%8B%E5%9B%BE.png\" alt=\"问题解决流程图\" /></p>\n<h3 id=\"%E9%9D%A2%E8%AF%95%E6%9C%9F%E5%BE%85\" tabindex=\"-1\">面试期待</h3>\n<h4 id=\"%E8%AE%A4%E7%9C%9F%E5%90%AC\" tabindex=\"-1\">认真听</h4>\n<p>注意面试官的问题中蕴含的信息，例如：</p>\n<ul>\n<li>有两个<strong>排序</strong>的数组</li>\n<li>设计一个在<strong>服务器</strong>上经常运行的算法：重复运行不同于只运行一次的算法。也许意味着你可以缓存数据，或者你可以顺理成章的对数据进行预处理。</li>\n</ul>\n<p>相关信息写在白板上对你会有很大的帮助。</p>\n<h4 id=\"%E7%94%BB%E4%B8%AA%E4%BE%8B%E5%9B%BE\" tabindex=\"-1\">画个例图</h4>\n<p>即画出一个有点特殊的例子作为思考的入手，避免例如有序数组，平衡二叉树之类的附加了特殊情况的样例作为思考的入手，这样容易被特殊情况带偏思考。</p>\n<h4 id=\"%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E8%9B%AE%E5%8A%9B%E6%B3%95\" tabindex=\"-1\">给出一个蛮力法</h4>\n<div class=\"warning\">\n<p>一些求职者不想给出蛮力法，是因为他们认为此方法不仅显而易见而且糟糕透顶。但是事实是：即使对你来说轻而易举，也未必对所有求职者来说都是这样。你不会想让面试官认为，即使是想出一个最简单的算法对你来说也是绞尽脑汁。</p>\n<div class=\"info\">\n<p>实际上，根据数据统计，[TODO] 问题的通过率竟然很低。</p>\n</div>\n</div>\n<h4 id=\"%E4%BC%98%E5%8C%96\" tabindex=\"-1\">优化</h4>\n<h4 id=\"%E6%A2%B3%E7%90%86\" tabindex=\"-1\">梳理</h4>\n<h4 id=\"%E5%AE%9E%E7%8E%B0\" tabindex=\"-1\">实现</h4>\n<p>（对于白板编程）写代码时要从白板的左上角开始。代码尽量水平方向写（不要写成一条斜线）</p>\n<p>切记，你只能写一小段代码来证明自己是一个优秀的开发人员。因此，每行代码都至关重要，一定要写的漂亮。</p>\n<div class=\"info\">\n<p>例如：</p>\n<ul>\n<li>模块化的代码。着展现了良好的代码风格，也会使你的解题更为顺畅：<pre><code class=\"language-rust\">let data = vec![vec![1, 2, 3], vec![3, 4, 5]]; // 不推荐\n\n// 推荐，省略数据输入，用模块来替代，防止代码过于细节\nlet data: Vec&lt;Vec&lt;i32&gt;&gt; = initInputData({height, width}); \n</code></pre>\n如果有需要，可以之后再写出来 <code>initInputData</code> 的具体实现。</li>\n<li>错误检查。有些面试官很看重这个，但有些对比不是很在意。一个好的办法是用 <code>TODO</code> 来省略可能需要的异常检查。</li>\n<li>使用恰到好处的类、结构体：如果需要再函数中返回一个列表等数据结构，可以直接用一个数据结构替代（名字要起好），大可以假设存在这样的数据结构。如果后面有富裕的时间，再补充细节就行了。</li>\n<li>好的变量名。只在循环索引的时候使用简单变量名。</li>\n</ul>\n</div>\n<h4 id=\"%E6%B5%8B%E8%AF%95\" tabindex=\"-1\">测试</h4>\n<p>发现了 bug（很有可能）就要修复，但注意不要贸然修改。仔细斟酌，找出问题的所在，找到最佳的修改方法再动手。</p>\n<div class=\"info\">\n<p>过于真实 QAQ，比如本 <code>blog</code> 上线的时候，咱经常在线上浏览的时候发现了 bug，就很匆忙在本地改完，跑一下编译测试就交上去了，但是很快在线上就会发现修改会引发其他问题。。。</p>\n</div>\n<h2 id=\"%E4%BC%98%E5%8C%96%E5%92%8C%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A71%EF%BC%9A%E5%AF%BB%E6%89%BE-bud\" tabindex=\"-1\">优化和解题技巧1：寻找 BUD</h2>\n<div class=\"note\">\n<p>BUD:</p>\n<ul>\n<li>瓶颈（Bottleneck）</li>\n<li>无用功（Unnecessary work）</li>\n<li>重复性工作（Duplicated word）</li>\n</ul>\n</div>\n<h2 id=\"%E4%BC%98%E5%8C%96%E5%92%8C%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A72%3A-%E4%BA%B2%E5%8A%9B%E4%BA%B2%E4%B8%BA\" tabindex=\"-1\">优化和解题技巧2: 亲力亲为</h2>\n<p>有时候单纯的思考算法反而不如先自己动手，在一个小的例子上尝试一下，人脑能很奇妙的给出一个直觉上的Solution。</p>\n<p>重点留意你凭直觉或不经意间做出的任何<code>优化</code>。例如你可能在解题的时候跳过所有以<code>d</code>开头的滑动窗口，因为<code>d</code>不在参考字符串<code>abbc</code>中。</p>\n<h2 id=\"%E4%BC%98%E5%8C%96%E5%92%8C%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A73%3A-%E5%8C%96%E7%B9%81%E4%B8%BA%E7%AE%80\" tabindex=\"-1\">优化和解题技巧3: 化繁为简</h2>\n<h2 id=\"%E4%BC%98%E5%8C%96%E5%92%8C%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A74%3A-%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1\" tabindex=\"-1\">优化和解题技巧4: 由浅入深</h2>\n<p>将一个大的问题分解为一个个小步骤的组合。</p>\n<div class=\"info\">\n<p>例如对于 n = 4 的元素 \\({a, b, c, d}\\)的全排列，可以先考虑</p>\n<p>n = 1,  \\(P(\\\\{a\\\\}) = \\{\\\\{ a \\}\\\\}\\)</p>\n<p>n = 2, \\(P(\\\\{a,b\\\\}) = \\{\\\\{a, b\\\\}, \\\\{b, a\\}\\\\}\\)</p>\n<p>n = 3, \\(P(\\\\{a, b, c\\\\}) = \\\\{\\\\{a, b, c\\\\}, \\\\{a, c, b\\\\}, \\\\{c, a, b\\\\}, \\\\{c, b, a\\\\}, \\cdots \\\\}\\)</p>\n<p>对于 \\(n\\ge3\\) 可以认为在 \\(n-1\\)的组合中插入新元素得到，因此可以得到一个递归的算法。</p>\n</div>\n<h2 id=\"%E4%BC%98%E5%8C%96%E5%92%8C%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A75%3A-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%B4%E8%84%91%E9%A3%8E%E6%9A%B4%E6%B3%95\" tabindex=\"-1\">优化和解题技巧5: 数据结构头脑风暴法</h2>\n<h2 id=\"%E5%8F%AF%E6%83%B3%E8%B1%A1%E7%9A%84%E6%9E%81%E9%99%90%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4\" tabindex=\"-1\">可想象的极限运行时间</h2>\n<p>可想象的极限运行时间（<strong>BCR</strong>），按字面意思理解就是，关于某个问题的解决，你可以想象出的运行时间的极限。你可以轻而易举的证明，BCR 是无法超越的</p>\n<div class=\"note\">\n<p>类似于运行时间上限，\\(O\\) 时间复杂度。</p>\n</div>\n<h3 id=\"%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E\" tabindex=\"-1\">举例说明</h3>\n<p>考虑以下问题：</p>\n<div class=\"question\">\n<p>找到两个排序数组中<strong>相同元素的个数</strong>，这两个数组长度相同，且每个数组中元素都不同。</p>\n<ul>\n<li>A: 13 27 <u>35</u> <u>40</u> 49 <u>55</u> 59</li>\n<li>B: 17 <u>35</u> 39 <u>40</u> <u>55</u> 58 60</li>\n</ul>\n</div>\n<p>这个问题的 BCR 为 \\(O(N)\\)，因为我们知道没个元素都必须访问一次，一共是 \\(2N\\)  个元素。暴力法复杂度为\\(O(N^2)\\)，因此：</p>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th>Complexity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Brute Force:</td>\n<td>\\(O(N^2)\\)</td>\n</tr>\n<tr>\n<td>Optimal Algorithm:</td>\n<td>\\(?\\)</td>\n</tr>\n<tr>\n<td>BCR:</td>\n<td>\\(O(N)\\)</td>\n</tr>\n</tbody>\n</table></div>\n<p>如果当前的算法的运行时间是\\(O(N^2)\\)，那么可以的优化方向是\\(O(N)\\)或\\(O(NlogN)\\)</p>\n<div class='md-table-wrapper'><table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th>Complexity</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Brute Force:</td>\n<td>\\(O(N^2)\\)</td>\n</tr>\n<tr>\n<td>Improved Algorithm:</td>\n<td>\\(O(NlogN)\\)，基于二分查找</td>\n</tr>\n<tr>\n<td>Optimal Algorithm:</td>\n<td>\\(?\\)</td>\n</tr>\n<tr>\n<td>BCR:</td>\n<td>\\(O(N)\\)</td>\n</tr>\n</tbody>\n</table></div>\n<div class=\"info\">\n<p>BCR 说明，解出这个算法的最快运行时间为\\(O(N)\\)，因此我们可以认为任何复杂度在 \\(O(N)\\) 的工作都是“免费的”。从这个意义上来说，对运行时间并无影响。</p>\n</div>\n<p>如何优化运行空间呢？</p>\n<p>对于二分查找，每次并不需要从开始处查找，只要从上一次的停止的位置开始即可。从 BUD 上来考虑，这个搜索的过程是整个算法的瓶颈。</p>\n<h2 id=\"%E5%A5%BD%E4%BB%A3%E7%A0%81%E7%9A%84%E6%A0%87%E5%87%86\" tabindex=\"-1\">好代码的标准</h2>\n<ul>\n<li>正确</li>\n<li>高效</li>\n<li>简洁</li>\n<li>可读性</li>\n<li>可维护性</li>\n</ul>\n<h1 id=\"chapter-9%3A-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE\" tabindex=\"-1\">Chapter 9: 面试题目</h1>\n<h1 id=\"%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2\" tabindex=\"-1\">数组与字符串</h1>\n<h3 id=\"%E6%95%A3%E5%88%97%E8%A1%A8\" tabindex=\"-1\">散列表</h3>\n<div class=\"warning\">\n<p>具体概念略，这个应该都懂吧。。。</p>\n</div>\n<h2 id=\"%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97\" tabindex=\"-1\">散列表的取模运算</h2>\n<p>在高中 OI 的时候，有一个说法是使用素数作为模会减少 Hash 冲突。</p>\n<p>对于一般的随机数，其实并无区别，但是大部分的测例或者现实情况是，数据是有某种规律的，这时候使用素数可以有效防止对面的规律正好存在公因数。</p>\n<blockquote>\n<p>参考资料：<a href=\"https://www.zhihu.com/question/20806796\" target=\"_blank\" rel=\"noopener\">Hash时取模一定要模质数吗？</a></p>\n</blockquote>\n<div class=\"extra\">\n<p>有兴趣的可以记下来这个表：<a href=\"https://planetmath.org/goodhashtableprimes\" target=\"_blank\" rel=\"noopener\">good hash table primes</a>。逃。。。。</p>\n</div>\n<h2 id=\"%E9%93%BE%E8%A1%A8\" tabindex=\"-1\">链表</h2>\n<h3 id=\"%E5%BF%AB%E8%A1%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7\" tabindex=\"-1\">快行指针技巧</h3>\n<p>在处理链表问题的时候，“快行指针”（或称第二个指针）是一种很创建的技巧。“快行指针”指的是同时用两个指针来迭代访问链表，只不过一个比另一个超前一些。“快”指针往往先行几步，或者和“慢”指针相差固定的步数。</p>\n<div class=\"question\">\n<p>假定存在链表 \\(a_1\\rightarrow a_2 \\rightarrow \\dots a_n \\rightarrow b_1 \\rightarrow b_2 \\rightarrow \\dots \\rightarrow b_n\\) 。</p>\n<p>请用  \\(O(N)\\) 的时间，\\(O(1)\\) 的存储，变换为 \\(a_1 \\rightarrow b_a  \\rightarrow a_2  \\rightarrow b_2  \\rightarrow \\dots a_n  \\rightarrow b_n\\)。</p>\n</div>\n<div class=\"info\">\n<p>吐槽 P2.5: 每次写 Rust，都有种。。啊，放过咱吧。让咱用 raw pointer 到处乱指吧 QAQ</p>\n</div>\n<h2 id=\"%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%89%8D%E6%8F%90%E6%98%AF%E4%BD%A0%E8%A6%81%E6%89%BE%E5%88%B0%E5%AF%B9%E8%B1%A1%EF%BC%89\" tabindex=\"-1\">面向对象设计<spoiler>（前提是你要找到对象）</spoiler></h2>\n<p>面向对象设计问题要求求职者设计出类和方法，以实现技术问题或描述真实生活中的对象。这类问题会让或者至少会让面试官了解你的编程风格。</p>\n<p>这些问题并不那么着重于设计模式，而是意在考察你是否懂得如何打造优雅、容易维护的面向对象代码。<strong>若在这类问题上表现不佳，面试可能会亮起红灯。</strong></p>\n<h3 id=\"%E5%A6%82%E4%BD%95%E8%A7%A3%E7%AD%94\" tabindex=\"-1\">如何解答</h3>\n<p>以下解题思路对于解决很多问题大有裨益。</p>\n<h4 id=\"%E6%AD%A5%E9%AA%A41%EF%BC%9A%E5%A4%84%E7%90%86%E4%B8%8D%E6%98%8E%E7%A1%AE%E7%9A%84%E5%9C%B0%E6%96%B9\" tabindex=\"-1\">步骤1：处理不明确的地方</h4>\n<p>碰到面向对象设计问题是，你应该先问清楚<strong>谁</strong>是使用者以及他们将<strong>如何</strong>使用。对于某些问题，你甚至还要问清楚“<strong>6W</strong>”，即 who, what, where, when why how.</p>\n<div class=\"example\">\n<p><strong>请描述一个咖啡机的面向对象设计：</strong></p>\n<p>需要考虑：这台咖啡机可能是一款工业型机器，设计用来放在大餐厅里，每小时要服务几百位顾客，还能制造10种不同口味的咖啡。或者可能只是给老年人设计的简易咖啡机。只要能制作简单的黑咖啡就行。这些额外的用例将会大大影响你的设计。</p>\n</div>\n<h3 id=\"%E6%AD%A5%E9%AA%A42%EF%BC%9A%E5%AE%9A%E4%B9%89%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1\" tabindex=\"-1\">步骤2：定义核心对象</h3>\n<p>了解我「们要设计的东西后，接下来就该思考系统的核心对象了</p>\n<div class=\"info\">\n<p>核心对象可能有：Table, Guest, Party, Order, Meal, Employee, Server, Host</p>\n</div>\n<h3 id=\"%E6%AD%A5%E9%AA%A43%3A%E5%88%86%E6%9E%90%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB\" tabindex=\"-1\">步骤3:分析对象关系</h3>\n<p>定义出核心对象之后，接下来要分析这些对象之间的关系。其中，哪些对象是其他对象的数据成员 ？哪个对象继承自别的对象？对象之间是多对多的关系，还是一对多的关系？</p>\n<div class=\"warning\">\n<p>分析对象关系务必谨慎，因为我们经常会做出错误的假设。比如：</p>\n<p>哪怕一张餐桌也可能设计多个宴席（<em>在热门餐厅，“拼桌”很常见</em>）。进行设计时，你应该跟面试官探讨以下如何让你的设计做到一物多用。</p>\n</div>\n<h3 id=\"%E6%AD%A5%E9%AA%A44%3A-%E7%A0%94%E7%A9%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B7%A5%E4%BD%9C\" tabindex=\"-1\">步骤4: 研究对象的工作</h3>\n<p>到这一步，你的面向对象设计应该初具出行了。接下来，该想想对象可执行的关键动作以及对象之间的关系。你可能会发现自己遗漏了某些对象，这是就需要补全并更新设计。</p>\n<h2 id=\"%E9%80%92%E5%BD%92%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92\" tabindex=\"-1\">递归与动态规划</h2>\n<div class=\"info\">\n<p>当你听到的问题的：设计一个算法计算第 n 个。。。、列出前 n 个。。。、实现一个算法，计算所有。。。等，那么基本上这就是递归问题了。</p>\n</div>\n<h3 id=\"%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%8F%8A%E8%AE%B0%E5%BF%86%E6%B3%95\" tabindex=\"-1\">动态规划及记忆法</h3>\n<div class=\"alert\">\n<p>通常来说，动态规划就是使用递归算法发现重叠子问题（也就是重复的调用）。然后你可以缓存结果以备不时之需。</p>\n<p><spoiler>真的是说的简单。。做起来好难 QAQ </spoiler></p>\n</div>\n<div class=\"quote\">\n<p>つづく</p>\n</div>\n","slug":"学习笔记/程序员面试金典/ch7","published":true,"date":"2020-04-25T07:13:50.000Z","updated":"2020-05-26T06:26:49.000Z","path":"学习笔记/程序员面试金典/ch7/","api_path":"api/articles/学习笔记/程序员面试金典/ch7.json","keywords":null,"tags":[{"name":"读书笔记","path":"api/tags/读书笔记.json"},{"name":"flag","path":"api/tags/flag.json"},{"name":"程序员面试金典","path":"api/tags/程序员面试金典.json"}]}]}